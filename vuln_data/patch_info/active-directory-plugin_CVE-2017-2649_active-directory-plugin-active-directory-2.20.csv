Fix_Path,Fix_Src
"src/main/java/hudson/plugins/active_directory/ActiveDirectorySecurityRealm.java:[205,207]:ActiveDirectorySecurityRealm","    public ActiveDirectorySecurityRealm(String domain, String site, String bindName, String bindPassword, String server) {
        this(domain, site, bindName, bindPassword, server, GroupLookupStrategy.AUTO, false);
    }
"
"src/main/java/hudson/plugins/active_directory/ActiveDirectorySecurityRealm.java:[510,512]:bind","        public DirContext bind(String principalName, String password, List<SocketInfo> ldapServers, Hashtable<String, String> props) throws NamingException {
            return bind(principalName, password, ldapServers, props, TlsConfiguration.TRUST_ALL_CERTIFICATES);
        }
"
"src/main/java/hudson/plugins/active_directory/ActiveDirectoryUnixAuthenticationProvider.java:[181,213]:ActiveDirectoryUnixAuthenticationProvider","    public ActiveDirectoryUnixAuthenticationProvider(ActiveDirectorySecurityRealm realm) {
        this.site = realm.site;
        this.domains = realm.domains;
        this.groupLookupStrategy = realm.getGroupLookupStrategy();
        this.activeDirectoryInternalUser = realm.internalUsersDatabase;
        this.descriptor = realm.getDescriptor();
        this.cache = realm.cache;

        if (cache == null) {
            this.cache = new CacheConfiguration(0, 0);
        }

        // On startup userCache and groupCache are not created and cache is different from null
        if (cache.getUserCache() == null || cache.getGroupCache() == null) {
            this.cache = new CacheConfiguration(cache.getSize(), cache.getTtl());
        }
        this.userCache = cache.getUserCache();
        this.groupCache = cache.getGroupCache();
        this.threadPoolExecutor = new ThreadPoolExecutor(
                corePoolSize,
                maxPoolSize,
                keepAliveTime,
                TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<Runnable>(queueSize),
                new NamingThreadFactory(new DaemonThreadFactory(), ""ActiveDirectory.updateUserCache""),
                new ThreadPoolExecutor.DiscardPolicy()
        );
        Map<String, String> extraEnvVarsMap = ActiveDirectorySecurityRealm.EnvironmentProperty.toMap(realm.environmentProperties);
        props.put(LDAP_CONNECT_TIMEOUT, System.getProperty(LDAP_CONNECT_TIMEOUT, DEFAULT_LDAP_CONNECTION_TIMEOUT));
        props.put(LDAP_READ_TIMEOUT, System.getProperty(LDAP_READ_TIMEOUT, DEFAULT_LDAP_READ_TIMEOUT));
        // put all the user defined properties into our context environment replacing any mappings that already exist.
        props.putAll(extraEnvVarsMap);
    }
"
"src/main/java/hudson/plugins/active_directory/ActiveDirectoryUnixAuthenticationProvider.java:[215,281]:retrieveUser","    protected UserDetails retrieveUser(final String username, final UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {
        try {
            // this is more seriously error, indicating a failure to search
            List<AuthenticationException> errors = new ArrayList<>();

            // this is lesser error, in that we searched and the user was not found
            List<UsernameNotFoundException> notFound = new ArrayList<>();

            for (ActiveDirectoryDomain domain : domains) {
                try {
                    return retrieveUser(username, authentication, domain);
                } catch (NamingException ne) {
                    if (userMatchesInternalDatabaseUser(username)) {
                        LOGGER.log(Level.WARNING, String.format(""Looking into Jenkins Internal Users Database for user %s"", username));
                        User internalUser = hudson.model.User.get(username);
                        HudsonPrivateSecurityRealm.Details hudsonPrivateSecurityRealm = internalUser.getProperty(HudsonPrivateSecurityRealm.Details.class);
                        String password = """";
                        if (authentication.getCredentials() instanceof String) {
                            password = (String) authentication.getCredentials();
                        }
                        if (hudsonPrivateSecurityRealm.isPasswordCorrect(password)) {
                            LOGGER.log(Level.INFO, String.format(""Falling back into the internal user %s"", username));
                            return new ActiveDirectoryUserDetail(username, ""redacted"", true, true, true, true, hudsonPrivateSecurityRealm.getAuthorities(), internalUser.getDisplayName(), """", """");
                        } else {
                            LOGGER.log(Level.WARNING, String.format(""Credential exception trying to authenticate against %s domain"", domain.getName()), ne);
                            errors.add(new MultiCauseUserMayOrMayNotExistException(""We can't tell if the user exists or not: "" + username, notFound));
                        }
                    } else {
                        LOGGER.log(Level.WARNING, String.format(""Communications issues when trying to authenticate against %s domain"", domain.getName()), ne);
                        errors.add(new MultiCauseUserMayOrMayNotExistException(""We can't tell if the user exists or not: "" + username, notFound));
                    }
                } catch (UsernameNotFoundException e) {
                    notFound.add(e);
                } catch (BadCredentialsException bce) {
                    LOGGER.log(Level.WARNING, String.format(""Credential exception trying to authenticate against %s domain"", domain.getName()), bce);
                    errors.add(bce);
                }
            }

            switch (errors.size()) {
                case 0:
                    break;  // fall through
                case 1:
                    throw errors.get(0); // preserve the original exception
                default:
                    throw new MultiCauseBadCredentialsException(""Either no such user '"" + username + ""' or incorrect password"", errors);
            }

            if (notFound.size()==1) {
                throw notFound.get(0);  // preserve the original exception
            }

            if (!Util.filter(notFound,UserMayOrMayNotExistException.class).isEmpty()) {
                // if one domain responds with UserMayOrMayNotExistException, then it might actually exist there,
                // so our response will be ""can't tell""
                throw new MultiCauseUserMayOrMayNotExistException(""We can't tell if the user exists or not: "" + username, notFound);
            }
            if (!notFound.isEmpty()) {
                throw new MultiCauseUserNotFoundException(""No such user: "" + username, notFound);
            }

            throw new AssertionError(""No domain is configured"");
        } catch (AuthenticationException e) {
            LOGGER.log(Level.FINE, String.format(""Failed to retrieve user %s"", username), e);
            throw e;
        }
    }
"
