Fix_Path,Fix_Src
"src/main/java/org/owasp/esapi/crypto/KeyDerivationFunction.java:[43,532]:KeyDerivationFunction","public class KeyDerivationFunction {
	/**
	 * Used to support backward compatibility. {@code kdfVersion} is used as the
	 * version for the serialized encrypted ciphertext on all the ""encrypt""
	 * operations. This static field should be the same as
	 * {@link CipherText#cipherTextVersion} and
	 * {@link CipherTextSerializer#cipherTextSerializerVersion} to make sure
	 * that these classes are all kept in-sync in order to support backward
	 * compatibility of previously encrypted data.
	 * <pre>
	 * Previous versions:	20110203 - Original version (ESAPI releases 2.0 & 2.0.1)
	 *					    20130830 - Fix to issue #306 (release 2.1.0)
	 * </pre>
	 * @see CipherTextSerializer#asSerializedByteArray()
	 * @see CipherText#asPortableSerializedByteArray()
	 * @see CipherText#fromPortableSerializedBytes(byte[])
	 */
	public  static final int  originalVersion  = 20110203;	 // First version. Do not change. EVER!
	public  static final int  kdfVersion       = 20130830;   // Current version. Format: YYYYMMDD, max is 99991231.
	private static final long serialVersionUID = kdfVersion; // Format: YYYYMMDD
	
    // Pseudo-random function algorithms suitable for NIST KDF in counter mode.
	// Note that HmacMD5 is intentionally omitted here!!!
    public enum PRF_ALGORITHMS {
    		// SHA-1, 160-bits
        HmacSHA1(0, 160, ""HmacSHA1""),
        	// SHA-2 candidates, 256-, 384-, and 512-bits
        HmacSHA256(1, 256, ""HmacSHA256""),
        HmacSHA384(2, 384, ""HmacSHA384""),
        HmacSHA512(3, 512, ""HmacSHA512"");
        	// Reserved for SHA-3 winner, 224-, 256-, 384-, and 512-bits
        	// Names not yet known. Will use standard JCE alg names here.
        	//
        	// E.g., might be something like
        	//		HmacSHA3_224(4, 224, ""HmacSHA3-224""),
        	//		HmacSHA3_256(5, 256, ""HmacSHA3-256""),
        	//		HmacSHA3_384(6, 384, ""HmacSHA3-385""),
        	//		HmacSHA3_512(7, 512, ""HmacSHA3-512"");
        // Reserved for future use -- values 8 through 15
        //  Most likely these might be some other strong contenders that
        //  were are based on HMACs from the NIST SHA-3 finalists.
        
        private final byte value;	// Value stored in serialized encrypted data to represent PRF
        private final short bits;
        private final String algName;
        
        PRF_ALGORITHMS(int value, int bits, String algName) {
        	this.value = (byte) value;
        	this.bits  = (short) bits;
        	this.algName = algName;
        }
        
        public byte getValue() { return value; }
        public short getBits() { return bits; }
        public String getAlgName() { return algName; }
    }

	private static final Logger logger = ESAPI.getLogger(""KeyDerivationFunction"");

	private String prfAlg_ = null;
	private int version_ = kdfVersion;
	private String context_ = """";

    // Check if versions of KeyDerivationFunction, CipherText, and
    // CipherTextSerializer are all the same.
    {
        // Ignore error about comparing identical versions and dead code.
        // We expect them to be, but the point is to catch us if they aren't.
        if ( CipherTextSerializer.cipherTextSerializerVersion != CipherText.cipherTextVersion ) {
            throw new ExceptionInInitializerError(""Versions of CipherTextSerializer and CipherText are not compatible."");
        }
        if ( CipherTextSerializer.cipherTextSerializerVersion != KeyDerivationFunction.kdfVersion ) {
            throw new ExceptionInInitializerError(""Versions of CipherTextSerializer and KeyDerivationFunction are not compatible."");
        }
    }
    
	/**
	 * Construct a {@code KeyDerivationFunction}.
	 * @param prfAlg	Specifies a supported algorithm.
	 */
	public KeyDerivationFunction(KeyDerivationFunction.PRF_ALGORITHMS prfAlg) {
		this.prfAlg_ = prfAlg.getAlgName();
	}

	/**
	 * Construct a {@code KeyDerivationFunction} based on the
	 * <b>ESAPI.property</b> property, {@code Encryptor.KDF.PRF}.
	 */
	public KeyDerivationFunction() {			
		String prfName = ESAPI.securityConfiguration().getKDFPseudoRandomFunction();
		if ( ! KeyDerivationFunction.isValidPRF(prfName) ) {
    		throw new ConfigurationException(""Algorithm name "" + prfName +
    							"" not a valid algorithm name for property "" +
    							DefaultSecurityConfiguration.KDF_PRF_ALG);
		}
		prfAlg_ = prfName;
	}

	/**
	 * Return the name of the algorithm for the Pseudo Random Function (PRF)
	 * that is being used.
	 * @return	The PRF algorithm name.
	 */
	public String getPRFAlgName() {
		return prfAlg_;		
	}
	
	/**
	 * Package level method for use by {@code CipherText} class to get default
	 * 
	 */
	static int getDefaultPRFSelection() {
		String prfName = ESAPI.securityConfiguration().getKDFPseudoRandomFunction();
		for (PRF_ALGORITHMS prf : PRF_ALGORITHMS.values()) {
			if ( prf.getAlgName().equals(prfName) ) {
				return prf.getValue();
			}
		}
		throw new ConfigurationException(""Algorithm name "" + prfName +
				"" not a valid algorithm name for property "" +
				DefaultSecurityConfiguration.KDF_PRF_ALG);
	}
	
	/**
	 * Set version so backward compatibility can be supported. Used to set the
	 * version to some previous version so that previously encrypted data can
	 * be decrypted.
	 * @param version	Date as a integer, in format of YYYYMMDD. Maximum
	 * 					version date is 99991231 (December 31, 9999).
	 * @throws	IllegalArgumentException	If {@code version} is not within
	 * 					the valid range of [20110203, 99991231].
	 */
	public void setVersion(int version) throws IllegalArgumentException {
		CryptoHelper.isValidKDFVersion(version, false, true);
		this.version_ = version;
	}

	/**
	 * Return the version used for backward compatibility.
	 * @return	The KDF version #, in format YYYYMMDD, used for supporting
	 * 			backward compatibility.
	 */
	public int getVersion() {
		return version_;
	}
	
	
	// TODO: IMPORTANT NOTE: In a future release (hopefully starting in 2.3),
	// we will be using the 'context' to mix in some additional things. At a
	// minimum, we will be using the KDF version (version_) so that downgrade version
	// attacks are not possible. Other candidates are the cipher xform and
	// the timestamp.
	/**
	 * Set the 'context' as specified by NIST Special Publication 800-108. NIST
	 * defines 'context' as ""A binary string containing the information related
	 * to the derived keying material. It may include identities of parties who
	 * are deriving and/or using the derived keying material and, optionally, a 
	 * once known by the parties who derive the keys."" NIST SP 800-108 seems to
	 * imply that while 'context' is recommended, that it is optional. In section
	 * 7.6 of NIST 800-108, NIST uses ""SHOULD"" rather than ""MUST"":
	 * <blockquote>
	 * ""Derived keying material should be bound to all relying
	 * entities and other information to identify the derived
	 * keying material. This is called context binding.
	 * In particular, the identity (or identifier, as the term
	 * is defined in [NIST SP 800-56A , sic] and [NIST SP
	 * 800-56B , sic]) of each entity that will access (meaning
	 * derive, hold, use, and/or distribute) any segment of
	 * the keying material should be included in the Context
	 * string input to the KDF, provided that this information
	 * is known by each entity who derives the keying material.""
	 * </blockquote>
	 * The ISO/IEC's KDF2 uses a similar construction for their KDF and there
	 * 'context' data is not specified at all. Therefore, ESAPI 2.0's
	 * reference implementation, {@code JavaEncryptor}, chooses not to use
	 * 'context' at all.
	 * 
	 * @param context	Optional binary string containing information related to
	 * 					the derived keying material. By default (if this method
	 * 					is never called), the empty string is used. May have any
	 * 					value but {@code null}.
	 */
	public void setContext(String context) {
		if ( context == null ) {
			throw new IllegalArgumentException(""Context may not be null."");
		}
		context_ = context;
	}
	
	/**
	 * Return the optional 'context' that typically contains information
	 * related to the keying material, such as the identities of the message
	 * sender and recipient.
	 * @see #setContext(String)
	 * @return The 'context' is returned.
	 */
	public String getContext() {
		return context_;
	}

	/**
	 * The method is ESAPI's Key Derivation Function (KDF) that computes a
	 * derived key from the {@code keyDerivationKey} for either
	 * encryption / decryption or for authentication.
	 * <p>
	 * <b>CAUTION:</b> If this algorithm for computing derived keys from the
	 * key derivation key is <i>ever</i> changed, we risk breaking backward compatibility of being
	 * able to decrypt data previously encrypted with earlier / different versions
	 * of this method. Therefore, do not change this unless you are 100% certain that
	 * what you are doing will NOT change either of the derived keys for
	 * ANY ""key derivation key"" AT ALL!!!
	 * <p>
	 * <b>NOTE:</b> This method is generally not intended to be called separately.
	 * It is used by ESAPI's reference crypto implementation class {@code JavaEncryptor}
	 * and might be useful for someone implementing their own replacement class, but
	 * generally it is not something that is useful to application client code.
	 * 
	 * @param keyDerivationKey  A key used as an input to a key derivation function
	 *                          to derive other keys. This is the key that generally
	 *                          is created using some key generation mechanism such as
	 *                          {@link CryptoHelper#generateSecretKey(String, int)}. The
	 *                          ""input"" key from which the other keys are derived.
	 * 							The derived key will have the same algorithm type
	 * 							as this key. This KDK cannot be null.
	 * @param keySize		The cipher's key size (in bits) for the {@code keyDerivationKey}.
	 * 						Must have a minimum size of 56 bits and be an integral multiple of 8-bits.
	 * 						<b>Note:</b> The derived key will have the same size as this.
	 * @param purpose		The purpose for the derived key. <b>IMPORTANT:</b> For the ESAPI reference implementation,
	 * 						{@code JavaEncryptor}, this <i>must</i> be either the string ""encryption"" or
	 * 						""authenticity"", where ""encryption"" is used for creating a derived key to use
	 * 						for confidentiality, and ""authenticity"" is used for creating a derived key to
	 * 						use with a MAC to ensure message authenticity. However, since parameter serves
	 * 						the same purpose as the ""Label"" in section 5.1 of NIST SP 800-108, it really can
	 * 						be set to anything other than {@code null} or an empty string when called outside
	 * 						of ESAPI's {@code JavaEncryptor} reference implementation (but you must consistent).
	 * @return				The derived {@code SecretKey} to be used according
	 * 						to the specified purpose. 
	 * @throws NoSuchAlgorithmException		The {@code keyDerivationKey} has an unsupported
	 * 						encryption algorithm or no current JCE provider supports requested
     * 						Hmac algorithrm used for the PRF for key generation.
	 * @throws EncryptionException		If ""UTF-8"" is not supported as an encoding, then
	 * 						this is thrown with the original {@code UnsupportedEncodingException}
	 * 						as the cause. (NOTE: This should never happen as ""UTF-8"" is supposed to
	 * 						be a common encoding supported by all Java implementations. Support
	 * 					    for it is usually in rt.jar.) This exception is also thrown if the
     * 					    requested {@code keySize} parameter exceeds the length of the number of
     * 					    bytes provded in the {@code keyDerivationKey} parameter.
	 * @throws InvalidKeyException 	Likely indicates a coding error. Should not happen.
	 * @throws EncryptionException  Throw for some precondition violations.
	 */
	public SecretKey computeDerivedKey(SecretKey keyDerivationKey, int keySize, String purpose)
			throws NoSuchAlgorithmException, InvalidKeyException, EncryptionException
	{
		// Acknowledgments: David Wagner first suggested this approach, I (Kevin Wall)
		//				    stumbled upon NIST SP 800-108 and used it as a basis to
		//				    extend it. Later it was changed that conforms more closely
		//					to section 5.1 of NIST SP 800-108 based on feedback from
		//					Jeffrey Walton.
		//

		// These checks used to be assertions prior to ESAPI 2.1.0.1
		if ( keyDerivationKey == null ) {
			throw new IllegalArgumentException(""Key derivation key cannot be null."");
		}
			// We would choose a larger minimum key size, but we want to allow
            // this KDF to be able to accept DES for legacy encryption needs. (Note that
            // elsewhere there are checks that disallow *encryption* for key size
            // less than Encryptor.EncryptionKeyLength bits, so if they want
            // ESAPI to encrypt stuff for DES, they would have to set that up to
            // be 56 bits. But I can't think of any valid symmetric encryption
            // algorithm whose key size is less than 56 bits that we would ever
            // want to allow.
		if ( keySize < 56 ) {
			throw new IllegalArgumentException(""Key has size of "" + keySize +
											   "", which is less than minimum of 56-bits."");
		}
		if ( (keySize % 8) != 0 ) {
			throw new IllegalArgumentException(""Key size ("" + keySize +
											   "") must be a even multiple of 8-bits."");
		}
		if ( purpose == null || """".equals(purpose) ) {
			throw new IllegalArgumentException(""Purpose may not be null or empty."");
		}

        //
        // No longer, since we no longer wish to restrict this to use only by JavaEncryptor, so
        // we no longer test for this.  For details, see the javadoc for '@param purpose', above.
        //
        /*
         *
         *      if ( ! ( purpose.equals(""encryption"") || purpose.equals(""authenticity"") ) ) {
         *          throw new IllegalArgumentException(""Purpose must be \""encryption\"" or \""authenticity\""."");
         *      }
         *
         */

        int providedKeyLen = 8 * keyDerivationKey.getEncoded().length;
        // assert providedKeyLen >= 56 : ""Coding error? Length of keyDerivationKey < 56 bits!"";    // Ugh. DES compatible.

        if ( providedKeyLen < keySize ) {
            throw new EncryptionException(""KeyDerivationFunction.computeDerivedKey() not intended for key stretching: "" +
                                          ""provided key too short ("" + providedKeyLen + "" bits) to provide "" + keySize + "" bits."",
                        ""Key stretching not supported: Provided key, keyDerivationKey, has insufficient entropy ("" +
                            providedKeyLen + "" bits) to generate key of requested size of "" + keySize + "" bits."");
        }

		keySize = calcKeySize( keySize );	// Safely convert from bits to a whole # of bytes.
		byte[] derivedKey = new byte[ keySize ];
		byte[] label;				    	// Same purpose as NIST SP 800-108's ""label"" in section 5.1.
		byte[] context;						// See setContext() for details.
		try {
			label = purpose.getBytes(""UTF-8"");
			context = context_.getBytes(""UTF-8"");
		} catch (UnsupportedEncodingException e) {
			throw new EncryptionException(""Encryption failure (internal encoding error: UTF-8)"",
					 ""UTF-8 encoding is NOT supported as a standard byte encoding: "" + e.getMessage(), e);
		}
		
			// Note that keyDerivationKey is going to be some SecretKey like an AES or
			// DESede key, but not an HmacSHA1 key. That means it is not likely
			// going to be 20 bytes but something different. Experiments show
			// that doesn't really matter though as the SecretKeySpec CTOR on
			// the following line still returns the appropriate sized key for
			// HmacSHA1. So, if keyDerivationKey was originally (say) a 56-bit
            // DES key, then there is apparently some key-stretching going on here
            // under the hood to create 'sk' so that it is 20 bytes. I cannot vouch
            // for how secure this key-stretching is. Worse, it might not be specified
            // as to *how* it is done and left to each JCE provider.
      	SecretKey sk = new SecretKeySpec(keyDerivationKey.getEncoded(), prfAlg_ );
		Mac mac = null;

		try {
    		mac = Mac.getInstance( prfAlg_ );
			mac.init(sk);
		} catch( InvalidKeyException ex ) {
			logger.error(Logger.SECURITY_FAILURE,
					""Created "" + prfAlg_ + "" Mac but SecretKey sk has alg "" +
					sk.getAlgorithm(), ex);
			throw ex;
		}
		
		// Repeatedly call of PRF Hmac until we've collected enough bits
		// for the derived key. The first time through, we calculate the HmacSHA1
		// on the ""purpose"" string, but subsequent calculations are performed
		// on the previous result.
		int ctr = 1;		// Iteration counter for NIST 800-108
		int totalCopied = 0;
		int destPos = 0;
		int len = 0;
		byte[] tmpKey = null;	// Do not declare inside do-while loop!!!
		do {
			//
			// This is to make our KDF more along the line of NIST's.
			// NIST's Special Publication 800-108 performs the following in
            // the iterative loop of Section 5.1:
            //       n := number of blocks required to fulfill request
            //       for i = 1 to n, do
            //           K(i) := PRF(KDK, [i]2 || Label || 0x00 || Context || [L]2)
            //           result(i) := result(i-1) || K(i)
            //       end
            // where '||' is represents bit string concatenation, and PRF is
            // an NIST approved pseudo-random function (such as an HMAC),
            // KDK is the key derivation key, [i]2 is the big-endian binary
            // representation of the iteration, and [L]2 is the bits
            // requested by the caller, and 0x00 represents a null byte
            // used as a separation indicator.  However, other sections of this
            // document (Section 7.6) implies that Context is to be an
            // optional field (based on NIST's use of the word SHOULD
            // rather than MUST)
            // 
			mac.update( ByteConversionUtil.fromInt( ctr++ ) );
			mac.update(label);
			mac.update((byte) '\0');
			mac.update(context); // This is problematic for us. See Jeff Walton's
								  // analysis of ESAPI 2.0's KDF for details.
								  // Maybe for 2.1, we'll see; 2.0 too close to GA.
			
	            // According to the Javadoc for Mac.doFinal(byte[]),
	            // ""A call to this method resets this Mac object to the state it was
	            // in when previously initialized via a call to init(Key) or
	            // init(Key, AlgorithmParameterSpec). That is, the object is reset
	            // and available to generate another MAC from the same key, if
	            // desired, via new calls to update and doFinal."" Therefore, we do
	            // not do an explicit reset().
			tmpKey = mac.doFinal( ByteConversionUtil.fromInt( keySize ) );
			
			if ( tmpKey.length >= keySize ) {
				len = keySize;
			} else {
				len = Math.min(tmpKey.length, keySize - totalCopied);
			}
			System.arraycopy(tmpKey, 0, derivedKey, destPos, len);
			label = tmpKey;
			totalCopied += tmpKey.length;
			destPos += len;
		} while( totalCopied < keySize );
		
		// Don't leave remnants of the partial key in memory. (Note: we could
		// not do this if tmpKey were declared in the do-while loop.
        // Of course, in reality, trying to stomp these bits out is probably not
        // realistic because the JIT is likely toing to be smart enough to
        // optimze this loop away. We probably could try to outsmart it, by
        // (say) writing out the overwritten bits to /dev/null, but then even
        // then we'd still probably have to overwrite with random bits rather
        // than all null chars. How much is enough? Who knows? But it does point
        // to a serious limitation in Java and many other languages that one
        // cannot arbitrarily disable the optimizer either at compile time or
        // run time because of security reasons. Sigh. At least we've tried.
		for ( int i = 0; i < tmpKey.length; i++ ) {
			tmpKey[i] = '\0';
		}
		tmpKey = null;	// Make it immediately eligible for GC.
		
        // Convert it back into a SecretKey of the appropriate type.
		return new SecretKeySpec(derivedKey, keyDerivationKey.getAlgorithm());
	}

	/**
	 * Check if specified algorithm name is a valid PRF that can be used.
	 * @param prfAlgName	Name of the PRF algorithm; e.g., ""HmacSHA1"", ""HmacSHA384"", etc.
	 * @return	True if {@code prfAlgName} is supported, otherwise false.
	 */
	public static boolean isValidPRF(String prfAlgName) {
		for (PRF_ALGORITHMS prf : PRF_ALGORITHMS.values()) {
			if ( prf.getAlgName().equals(prfAlgName) ) {
				return true;
			}
		}
		return false;
	}

	public static PRF_ALGORITHMS convertNameToPRF(String prfAlgName) {
		for (PRF_ALGORITHMS prf : PRF_ALGORITHMS.values()) {
			if ( prf.getAlgName().equals(prfAlgName) ) {
				return prf;
			}
		}
		throw new IllegalArgumentException(""Algorithm name "" + prfAlgName +
				"" not a valid PRF algorithm name for the ESAPI KDF."");
	}
	
	public static PRF_ALGORITHMS convertIntToPRF(int selection) {
		for (PRF_ALGORITHMS prf : PRF_ALGORITHMS.values()) {
			if ( prf.getValue() == selection ) {
				return prf;
			}
		}
		throw new IllegalArgumentException(""No KDF PRF algorithm found for value name "" + selection);		
	}
	
    /**
     * Calculate the size of a key. The key size is given in bits, but we
     * can only allocate them by octets (i.e., bytes), so make sure we
     * round up to the next whole number of octets to have room for all
     * the bits. For example, a key size of 9 bits would require 2 octets
     * to store it.
     *
     * @param ks    The key size, in bits.
     * @return      The key size, in octets, large enough to accommodate
     *              {@code ks} bits.
     */
    private static int calcKeySize(int ks) {
        if ( ks <= 0 ) {
            throw new IllegalArgumentException(""Key size must be > 0 bits."");
        }
        int numBytes = 0;
        int n = ks/8;
        int rem = ks % 8;
        if ( rem == 0 ) {
            numBytes = n;
        } else {
            numBytes = n + 1;
        }
        return numBytes;
    }

    /**
     * Print list of ESAPI supported pseudo-random functions for KDF and
     * KDF version information.
     *
     * @param args  Required, but not used.
     */
	public static final void main(String args[]) {
		System.out.println(""Supported pseudo-random functions for KDF (version: "" + kdfVersion + "")"");
		System.out.println(""Enum Name\tAlgorithm\t# bits"");
		for (PRF_ALGORITHMS prf : PRF_ALGORITHMS.values()) {
		    System.out.println(prf + ""\t"" + prf.getAlgName() + ""\t"" + prf.getBits());
		}
	}
}
"
"src/main/java/org/owasp/esapi/crypto/KeyDerivationFunction.java:[61,61]:kdfVersion","	public  static final int  kdfVersion       = 20130830;   // Current version. Format: YYYYMMDD, max is 99991231.
"
"src/main/java/org/owasp/esapi/crypto/CipherText.java:[468,498]:validateMAC","    public boolean validateMAC(SecretKey authKey) {
        boolean requiresMAC = ESAPI.securityConfiguration().useMACforCipherText();

        if (  requiresMAC && macComputed() ) {  // Uses MAC and it was computed
            // Calculate MAC from HMAC-SHA1(nonce, IV + plaintext) and
            // compare to stored value (separate_mac_). If same, then return true,
            // else return false.
            byte[] mac = computeMAC(authKey);
            if ( mac.length != separate_mac_.length ) {
                    // Note: We want some type of unchecked exception
                    //       here so this will not require code changes.
                    //       Unfortunately, EncryptionException, which might
                    //       make more sense here, is not a RuntimeException.
                    String exm = ""MACs are of different lengths. "" +
                                 ""Should both be the same length"";
                    throw new EnterpriseSecurityRuntimeException(exm,
                                ""Possible tampering of MAC? "" + exm +
                                ""computed MAC len: "" + mac.length +
                                "", received MAC len: "" + separate_mac_.length);
            }
            return java.security.MessageDigest.isEqual(mac, separate_mac_); // Safe compare in JDK 7 and later
        } else if ( ! requiresMAC ) {           // Doesn't require a MAC
            return true;
        } else {
                // This *used* to be the case (for versions 2.0 and 2.0.1) where we tried to
                // accomodate the deprecated decrypt() method from ESAPI 1.4. Unfortunately,
                // that was an EPIC FAIL. (See Google Issue # 306 for details.)
            logger.warning(Logger.SECURITY_FAILURE, ""MAC may have been tampered with (e.g., length set to 0)."");
            return false;    // Deprecated decrypt() method removed, so now return false.
        }
    }
"
"src/main/java/org/owasp/esapi/Encryptor.java:[58,316]:Encryptor","public interface Encryptor {

	/**
	 * Returns a string representation of the hash of the provided plaintext and
	 * salt. The salt helps to protect against a rainbow table attack by mixing
	 * in some extra data with the plaintext. Some good choices for a salt might
	 * be an account name or some other string that is known to the application
	 * but not to an attacker.
	 * See <a href=""http://www.matasano.com/log/958/enough-with-the-rainbow-tables-what-you-need-to-know-about-secure-password-schemes/"">
	 * this article</a> for more information about hashing as it pertains to password schemes.
	 * 
	 * @param plaintext
	 * 		the plaintext String to encrypt
	 * @param salt
	 *      the salt to add to the plaintext String before hashing
	 * 
	 * @return 
	 * 		the encrypted hash of 'plaintext' stored as a String
	 * 
	 * @throws EncryptionException
	 *      if the specified hash algorithm could not be found or another problem exists with 
	 *      the hashing of 'plaintext'
	 */
	String hash(String plaintext, String salt) throws EncryptionException;

	/**
	 * Returns a string representation of the hash of the provided plaintext and
	 * salt. The salt helps to protect against a rainbow table attack by mixing
	 * in some extra data with the plaintext. Some good choices for a salt might
	 * be an account name or some other string that is known to the application
	 * but not to an attacker. 
	 * See <a href=""http://www.matasano.com/log/958/enough-with-the-rainbow-tables-what-you-need-to-know-about-secure-password-schemes/"">
	 * this article</a> for more information about hashing as it pertains to password schemes.
	 * 
	 * @param plaintext
	 * 		the plaintext String to encrypt
	 * @param salt
	 *      the salt to add to the plaintext String before hashing
	 * @param iterations
	 *      the number of times to iterate the hash
	 * 
	 * @return 
	 * 		the encrypted hash of 'plaintext' stored as a String
	 * 
	 * @throws EncryptionException
	 *      if the specified hash algorithm could not be found or another problem exists with 
	 *      the hashing of 'plaintext'
	 */
	String hash(String plaintext, String salt, int iterations) throws EncryptionException;
	
	/**
	 * Encrypts the provided plaintext bytes using the cipher transformation
	 * specified by the property <code>Encryptor.CipherTransformation</code>
	 * and the <i>master encryption key</i> as specified by the property
	 * {@code Encryptor.MasterKey} as defined in the <code>ESAPI.properties</code> file.
	 * </p>
	 * 
	 * @param plaintext	The {@code PlainText} to be encrypted.
	 * @return the {@code CipherText} object from which the raw ciphertext, the
	 * 				IV, the cipher transformation, and many other aspects about
	 * 				the encryption detail may be extracted.
	 * @throws EncryptionException Thrown if something should go wrong such as
	 * 				the JCE provider cannot be found, the cipher algorithm,
	 * 				cipher mode, or padding scheme not being supported, specifying
	 * 				an unsupported key size, specifying an IV of incorrect length,
	 * 				etc.
	 * @see #encrypt(SecretKey, PlainText)
	 * @since 2.0
	 */
	 CipherText encrypt(PlainText plaintext) throws EncryptionException;


	 /**
	  * Encrypts the provided plaintext bytes using the cipher transformation
	  * specified by the property <code>Encryptor.CipherTransformation</code>
	  * as defined in the <code>ESAPI.properties</code> file and the
	  * <i>specified secret key</i>.
	  * </p><p>
	  * This method is similar to {@link #encrypt(PlainText)} except that it
	  * permits a specific {@code SecretKey} to be used for encryption.
	  *
	  * @param key		The {@code SecretKey} to use for encrypting the plaintext.
	  * @param plaintext	The byte stream to be encrypted. Note if a Java
	  * 				{@code String} is to be encrypted, it should be converted
	  * 				using {@code ""some string"".getBytes(""UTF-8"")}.
	  * @return the {@code CipherText} object from which the raw ciphertext, the
	  * 				IV, the cipher transformation, and many other aspects about
	  * 				the encryption detail may be extracted.
	  * @throws EncryptionException Thrown if something should go wrong such as
	  * 				the JCE provider cannot be found, the cipher algorithm,
	  * 				cipher mode, or padding scheme not being supported, specifying
	  * 				an unsupported key size, specifying an IV of incorrect length,
	  * 				etc.
	  * @see #encrypt(PlainText)
	  * @since 2.0
	  */
	 CipherText encrypt(SecretKey key, PlainText plaintext)
	 		throws EncryptionException;

	/**
	 * Decrypts the provided {@link CipherText} using the information from it
	 * and the <i>master encryption key</i> as specified by the property
	 * {@code Encryptor.MasterKey} as defined in the {@code ESAPI.properties}
	 * file.
	 * </p>
	 * @param ciphertext The {@code CipherText} object to be decrypted.
	 * @return The {@code PlainText} object resulting from decrypting the specified
	 * 		   ciphertext. Note that it it is desired to convert the returned
	 * 		   plaintext byte array to a Java String is should be done using
	 * 		   {@code new String(byte[], ""UTF-8"");} rather than simply using
	 * 		   {@code new String(byte[]);} which uses native encoding and may
	 * 		   not be portable across hardware and/or OS platforms.
	 * @throws EncryptionException  Thrown if something should go wrong such as
	 * 				the JCE provider cannot be found, the cipher algorithm,
	 * 				cipher mode, or padding scheme not being supported, specifying
	 * 				an unsupported key size, or incorrect encryption key was
	 * 				specified or a {@code PaddingException} occurs.
	 * @see #decrypt(SecretKey, CipherText)
	 */
	PlainText decrypt(CipherText ciphertext) throws EncryptionException;
	
	/**
	 * Decrypts the provided {@link CipherText} using the information from it
	 * and the <i>specified secret key</i>.
	 * </p><p>
	 * This decrypt method is similar to {@link #decrypt(CipherText)} except that
	 * it allows decrypting with a secret key other than the <i>master secret key</i>.
	 * </p>
	 * @param key		The {@code SecretKey} to use for encrypting the plaintext.
	 * @param ciphertext The {@code CipherText} object to be decrypted.
	 * @return The {@code PlainText} object resulting from decrypting the specified
	 * 		   ciphertext. Note that it it is desired to convert the returned
	 * 		   plaintext byte array to a Java String is should be done using
	 * 		   {@code new String(byte[], ""UTF-8"");} rather than simply using
	 * 		   {@code new String(byte[]);} which uses native encoding and may
	 * 		   not be portable across hardware and/or OS platforms.
	 * @throws EncryptionException  Thrown if something should go wrong such as
	 * 				the JCE provider cannot be found, the cipher algorithm,
	 * 				cipher mode, or padding scheme not being supported, specifying
	 * 				an unsupported key size, or incorrect encryption key was
	 * 				specified or a {@code PaddingException} occurs.
	 * @see #decrypt(CipherText)
	 */
	PlainText decrypt(SecretKey key, CipherText ciphertext) throws EncryptionException;
	
	/**
	 * Create a digital signature for the provided data and return it in a
	 * string.
	 * <p>
	 * <b>Limitations:</b> A new public/private key pair used for ESAPI 2.0 digital
	 * signatures with this method and {@link #verifySignature(String, String)}
	 * are dynamically created when the default reference implementation class,
	 * {@link org.owasp.esapi.reference.crypto.JavaEncryptor} is first created.
	 * Because this key pair is not persisted nor is the public key shared,
	 * this method and the corresponding {@link #verifySignature(String, String)}
	 * can not be used with expected results across JVM instances. This limitation
	 * will be addressed in ESAPI 2.1.
	 * </p>
	 * 
	 * @param data
	 *      the data to sign
	 * 
	 * @return 
	 * 		the digital signature stored as a String
	 * 
	 * @throws EncryptionException
	 * 		if the specified signature algorithm cannot be found
	 */
	String sign(String data) throws EncryptionException;

	/**
	 * Verifies a digital signature (created with the sign method) and returns
	 * the boolean result.
     * <p>
     * <b>Limitations:</b> A new public/private key pair used for ESAPI 2.0 digital
     * signatures with this method and {@link #sign(String)}
     * are dynamically created when the default reference implementation class,
     * {@link org.owasp.esapi.reference.crypto.JavaEncryptor} is first created.
     * Because this key pair is not persisted nor is the public key shared,
     * this method and the corresponding {@link #sign(String)}
     * can not be used with expected results across JVM instances. This limitation
     * will be addressed in ESAPI 2.1.
     * </p>
	 * @param signature
	 *      the signature to verify against 'data'
	 * @param data
	 *      the data to verify against 'signature'
	 * 
	 * @return 
	 * 		true, if the signature is verified, false otherwise
	 */
	boolean verifySignature(String signature, String data);

	/**
	 * Creates a seal that binds a set of data and includes an expiration timestamp.
	 * 
	 * @param data
	 *      the data to seal
	 * @param timestamp
	 *      the absolute expiration date of the data, expressed as seconds since the epoch
	 * 
	 * @return 
     * 		the seal
	 * 
     * @throws IntegrityException
	 */
	String seal(String data, long timestamp) throws IntegrityException;

	/**
	 * Unseals data (created with the seal method) and throws an exception
	 * describing any of the various problems that could exist with a seal, such
	 * as an invalid seal format, expired timestamp, or decryption error.
	 * 
	 * @param seal
	 *      the sealed data
	 * 
	 * @return 
	 * 		the original (unsealed) data
	 * 
	 * @throws EncryptionException 
	 * 		if the unsealed data cannot be retrieved for any reason
	 */
	String unseal( String seal ) throws EncryptionException;
	
	/**
	 * Verifies a seal (created with the seal method) and throws an exception
	 * describing any of the various problems that could exist with a seal, such
	 * as an invalid seal format, expired timestamp, or data mismatch.
	 * 
	 * @param seal
	 *      the seal to verify
	 * 
	 * @return 
	 * 		true, if the seal is valid.  False otherwise
	 */
	boolean verifySeal(String seal);
	
	/**
	 * Gets an absolute timestamp representing an offset from the current time to be used by
	 * other functions in the library.
	 * 
	 * @param offset 
	 * 		the offset to add to the current time
	 * 
	 * @return 
	 * 		the absolute timestamp
	 */
	long getRelativeTimeStamp( long offset );
	
	/**
	 * Gets a timestamp representing the current date and time to be used by
	 * other functions in the library.
	 * 
	 * @return 
	 * 		a timestamp representing the current time
	 */
	long getTimeStamp();

}"
"src/main/java/org/owasp/esapi/Encryptor.java:[127,127]:encrypt","	 CipherText encrypt(PlainText plaintext) throws EncryptionException;
"
"src/main/java/org/owasp/esapi/Encryptor.java:[177,177]:decrypt","	PlainText decrypt(CipherText ciphertext) throws EncryptionException;
"
"src/main/java/org/owasp/esapi/reference/crypto/JavaEncryptor.java:[81,1044]:JavaEncryptor","public final class JavaEncryptor implements Encryptor {
    private static volatile Encryptor singletonInstance;

    // Note: This double-check pattern only works because singletonInstance
    //       is declared to be volatile.  Usually this method is called
    //       via ESAPI.encryptor() rather than directly.
    public static Encryptor getInstance() throws EncryptionException {
        if ( singletonInstance == null ) {
            synchronized ( JavaEncryptor.class ) {
                if ( singletonInstance == null ) {
                    singletonInstance = new JavaEncryptor();
                }
            }
        }
        return singletonInstance;
    }

    private static boolean initialized = false;

    // encryption
    private static SecretKeySpec secretKeySpec = null; // DISCUSS: Why static? Implies one key?!?
    private static String encryptAlgorithm = ""AES"";
    private static String encoding = ""UTF-8"";
    private static int encryptionKeyLength = 128;

    // digital signatures
    private static PrivateKey privateKey = null;
    private static PublicKey publicKey = null;
    private static String signatureAlgorithm = ""SHA1withDSA"";
    private static String randomAlgorithm = ""SHA1PRNG"";
    private static int signatureKeyLength = 1024;

    // hashing
    private static String hashAlgorithm = ""SHA-512"";
    private static int hashIterations = 1024;

    // Logging - DISCUSS: This ""sticks"" us with a specific logger to whatever it was when
    //                    this class is first loaded. Is this a big limitation? Since there
    //                    is no method to reset it, we may has well make it 'final' also.
    private static Logger logger = ESAPI.getLogger(""JavaEncryptor"");
        // Used to print out warnings about deprecated methods.
    private static int encryptCounter = 0;
    private static int decryptCounter = 0;
        // DISCUSS: OK to not have a property for this to set the frequency?
        //          The desire is to persuade people to move away from these
        //          two deprecated encrypt(String) / decrypt(String) methods,
        //          so perhaps the annoyance factor of not being able to
        //          change it will help. For now, it is just hard-coded here.
        //          We could be mean and just print a warning *every* time.
    private static final int logEveryNthUse = 25;

    // *Only* use this string for user messages for EncryptionException when
    // decryption fails. This is to prevent information leakage that may be
    // valuable in various forms of ciphertext attacks, such as the
    // Padded Oracle attack described by Rizzo and Duong.
    private static final String DECRYPTION_FAILED = ""Decryption failed; see logs for details."";

    // # of seconds that all failed decryption attempts will take. Used to
    // help prevent side-channel timing attacks.
    private static int N_SECS = 2;

    // Load the preferred JCE provider if one has been specified.
    static {
        try {
            SecurityProviderLoader.loadESAPIPreferredJCEProvider();
        } catch (NoSuchProviderException ex) {
            // Note that audit logging is done elsewhere in called method.
            logger.fatal(Logger.SECURITY_FAILURE,
                         ""JavaEncryptor failed to load preferred JCE provider."", ex);
            throw new ExceptionInInitializerError(ex);
        }
        setupAlgorithms();
    }

    /**
     * Generates a new strongly random secret key and salt that can be
     * copy and pasted in the <b>ESAPI.properties</b> file.
     *
     * @param args Set first argument to ""-print"" to display available algorithms on standard output.
     * @throws java.lang.Exception  To cover a multitude of sins, mostly in configuring ESAPI.properties.
     */
    public static void main( String[] args ) throws Exception {
        System.out.println( ""Generating a new secret master key"" );

        // print out available ciphers
        if ( args.length == 1 && args[0].equalsIgnoreCase(""-print"" ) ) {
            System.out.println( ""AVAILABLE ALGORITHMS"" );

            Provider[] providers = Security.getProviders();
            TreeMap<String, String> tm = new TreeMap<String, String>();
            // DISCUSS: Note: We go through multiple providers, yet nowhere do I
            //          see where we print out the PROVIDER NAME. Not all providers
            //          will implement the same algorithms and some ""partner"" with
            //          whom we are exchanging different cryptographic messages may
            //          have _different_ providers in their java.security file. So
            //          it would be useful to know the provider name where each
            //          algorithm is implemented. Might be good to prepend the provider
            //          name to the 'key' with something like ""providerName: "". Thoughts?
            for (int i = 0; i != providers.length; i++) {
                // DISCUSS: Print security provider name here???
                // Note: For some odd reason, Provider.keySet() returns
                //       Set<Object> of the property keys (which are Strings)
                //       contained in this provider, but Set<String> seems
                //       more appropriate. But that's why we need the cast below.
                System.out.println(""===== Provider "" + i + "":"" + providers[i].getName() + "" ======"");
                Iterator<Object> it = providers[i].keySet().iterator();
                while (it.hasNext()) {
                    String key = (String)it.next();
                    String value = providers[i].getProperty( key );
                    tm.put(key, value);
                    System.out.println(""\t\t   "" + key + "" -> ""+ value );
                }
            }

            Set< Entry<String,String> > keyValueSet = tm.entrySet();
            Iterator<Entry<String, String>> it = keyValueSet.iterator();
            while( it.hasNext() ) {
                Map.Entry<String,String> entry = it.next();
                String key = entry.getKey();
                String value = entry.getValue();
                System.out.println( ""   "" + key + "" -> ""+ value );
            }
        } else {
            // Used to print a similar line to use '-print' even when it was specified.
            System.out.println( ""\tuse '-print' to also show available crypto algorithms from all the security providers"" );
        }

        // setup algorithms -- Each of these have defaults if not set, although
        //                     someone could set them to something invalid. If
        //                     so a suitable exception will be thrown and displayed.
        encryptAlgorithm = ESAPI.securityConfiguration().getEncryptionAlgorithm();
        encryptionKeyLength = ESAPI.securityConfiguration().getEncryptionKeyLength();
        randomAlgorithm = ESAPI.securityConfiguration().getRandomAlgorithm();

        SecureRandom random = SecureRandom.getInstance(randomAlgorithm);
        SecretKey secretKey = CryptoHelper.generateSecretKey(encryptAlgorithm, encryptionKeyLength);
        byte[] raw = secretKey.getEncoded();
        byte[] salt = new byte[20]; // Or 160-bits; big enough for SHA1, but not SHA-256 or SHA-512.
        random.nextBytes( salt );
        String eol = System.getProperty(""line.separator"", ""\n""); // So it works on Windows too.
        System.out.println( eol + ""Copy and paste these lines into your ESAPI.properties"" + eol);
        System.out.println( ""#=============================================================="");
        System.out.println( ""Encryptor.MasterKey="" + ESAPI.encoder().encodeForBase64(raw, false) );
        System.out.println( ""Encryptor.MasterSalt="" + ESAPI.encoder().encodeForBase64(salt, false) );
        System.out.println( ""#=============================================================="" + eol);
    }


    /**
     * Private CTOR for {@code JavaEncryptor}, called by {@code getInstance()}.
     * @throws EncryptionException if can't construct this object for some reason.
     *                  Original exception will be attached as the 'cause'.
     */
    private JavaEncryptor() throws EncryptionException {
        byte[] salt = ESAPI.securityConfiguration().getMasterSalt();
        byte[] skey = ESAPI.securityConfiguration().getMasterKey();

        if ( salt == null ) {
            throw new ConfigurationException(""Can't obtain master salt, Encryptor.MasterSalt"");
        }

        if ( salt.length < 16 ) {
            throw new ConfigurationException(""Encryptor.MasterSalt must be at least 16 bytes. "" +
                                             ""Length is: "" + salt.length + "" bytes."");
        }

        if ( skey == null ) {
            throw new ConfigurationException(""Can't obtain master key, Encryptor.MasterKey"");
        }

        if ( skey.length < 7 ) {
            throw new ConfigurationException(""Encryptor.MasterKey must be at least 7 bytes. "" +
                                             ""Length is: "" + skey.length + "" bytes."");
        }

        // Set up secretKeySpec for use for symmetric encryption and decryption,
        // and set up the public/private keys for asymmetric encryption /
        // decryption.
        // TODO: Note: Since we've dumped ESAPI 1.4 crypto backward compatibility,
        //       then we probably can ditch the Encryptor.EncryptionAlgorithm
        //       property. If so, encryptAlgorithm should probably use
        //       Encryptor.CipherTransformation and just pull off the cipher
        //       algorithm name so we can use it here. That just requires
        //       advance notice and proper deprecation, which I'm not prepared
        //       to do at this time.    -kevin wall
        synchronized(JavaEncryptor.class) {
            if ( ! initialized ) {
                //
                // For symmetric encryption
                //
                //      NOTE: FindBugs complains about this
                //            (ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD) but
                //            it should be OK since it is synchronized and only
                //            done once. While we could separate this out and
                //            handle in a static initializer, it just seems to
                //            fit better here.
                secretKeySpec = new SecretKeySpec(skey, encryptAlgorithm );

                //
                // For asymmetric encryption (i.e., public/private key)
                //
                try {
                    SecureRandom prng = SecureRandom.getInstance(randomAlgorithm);

                    // Because hash() is not static (but it could be were in not
                    // for the interface method specification in Encryptor), we
                    // cannot do this initialization in a static method or static
                    // initializer.
                    byte[] seed = hash(new String(skey, encoding),new String(salt, encoding)).getBytes(encoding);
                    prng.setSeed(seed);
                    initKeyPair(prng);
                } catch (Exception e) {
                    throw new EncryptionException(""Encryption failure"", ""Error creating Encryptor"", e);
                }

                // Mark everything as initialized.
                initialized = true;
            }
        }
    }



    /**
     * {@inheritDoc}
     *
     * Hashes the data with the supplied salt and the number of iterations specified in
     * the ESAPI SecurityConfiguration.
     */
    public String hash(String plaintext, String salt) throws EncryptionException {
        return hash( plaintext, salt, hashIterations );
    }

    /**
     * {@inheritDoc}
     *
     * Hashes the data using the specified algorithm and the Java MessageDigest class. This method
     * first adds the salt, a separator ("":""), and the data, and then rehashes the specified number of iterations
     * in order to help strengthen weak passwords.
     */
    public String hash(String plaintext, String salt, int iterations) throws EncryptionException {
        byte[] bytes = null;
        try {
            MessageDigest digest = MessageDigest.getInstance(hashAlgorithm);
            digest.reset();
            digest.update(ESAPI.securityConfiguration().getMasterSalt());
            digest.update(salt.getBytes(encoding));
            digest.update(plaintext.getBytes(encoding));

            // rehash a number of times to help strengthen weak passwords
            bytes = digest.digest();
            for (int i = 0; i < iterations; i++) {
                digest.reset();
                bytes = digest.digest(bytes);
            }
            String encoded = ESAPI.encoder().encodeForBase64(bytes,false);
            return encoded;
        } catch (NoSuchAlgorithmException e) {
            throw new EncryptionException(""Internal error"", ""Can't find hash algorithm "" + hashAlgorithm, e);
        } catch (UnsupportedEncodingException ex) {
            throw new EncryptionException(""Internal error"", ""Can't find encoding for "" + encoding, ex);
        }
    }

    /**
    * {@inheritDoc}
    */
     public CipherText encrypt(PlainText plaintext) throws EncryptionException {
         // Now more of a convenience function for using the master key.
         return encrypt(secretKeySpec, plaintext);
     }

     /**
      * {@inheritDoc}
      */
     public CipherText encrypt(SecretKey key, PlainText plain)
                throws EncryptionException
     {
         if ( key == null ) {
             throw new IllegalArgumentException(""(Master) encryption key arg may not be null. Is Encryptor.MasterKey set?"");
         }
         if ( plain == null ) {
             throw new IllegalArgumentException(""PlainText may arg not be null"");
         }
         byte[] plaintext = plain.asBytes();
         boolean overwritePlaintext = ESAPI.securityConfiguration().overwritePlainText();

         boolean success = false;   // Used in 'finally' clause.
         String xform = null;
         int keySize = key.getEncoded().length * 8; // Convert to # bits

        try {
             xform = ESAPI.securityConfiguration().getCipherTransformation();
             String[] parts = xform.split(""/"");
             if ( parts.length != 3 ) {
                 throw new ConfigurationException(""Malformed cipher transformation: "" + xform +
                                                  "". Should have format of cipher_alg/cipher_mode/padding_scheme."");
             }
             String cipherMode = parts[1];

             // This way we can prevent modes like OFB and CFB where the IV should never
             // be repeated with the same encryption key (at least until we support
             // Encryptor.ChooseIVMethod=specified and allow us to specify some mechanism
             // to ensure the IV will never be repeated (such as a time stamp or other
             // monotonically increasing function).
             // DISCUSS: Should we include the permitted cipher modes in the exception msg?
             if ( ! CryptoHelper.isAllowedCipherMode(cipherMode) ) {
                 throw new EncryptionException(""Encryption failure: invalid cipher mode ( "" + cipherMode + "") for encryption"",
                             ""Encryption failure: Cipher transformation "" + xform + "" specifies invalid "" +
                             ""cipher mode "" + cipherMode);
             }

             // Note - Cipher is not thread-safe so we create one locally
             //        Also, we need to change this eventually so other algorithms can
             //        be supported. Eventually, there will be an encrypt() method that
             //        takes a (new class) CryptoControls, as something like this:
             //          public CipherText encrypt(CryptoControls ctrl, SecretKey skey, PlainText plaintext)
             //        and this method will just call that one.
             Cipher encrypter = Cipher.getInstance(xform);
             String cipherAlg = encrypter.getAlgorithm();

             int minKeyLen = 112;   // Use for hard-coded default to support 2TDEA
             try {
                minKeyLen = ESAPI.securityConfiguration().getIntProp(""Encryptor.MinEncryptionKeyLength"");
             } catch( Exception ex ) {
                 logger.warning(Logger.EVENT_FAILURE,
                         ""Property 'Encryptor.MinEncryptionKeyLength' not properly set in ESAPI.properties file; using hard coded default of 112 for min key size for encryption."",
                         ex);
                 ;  // Do NOT rethrow.
             }

             if ( keySize < minKeyLen ) {
                 // NOTE: This used to just log a warning. It now logs an error & throws an exception.
                 //
                 // ESAPI.EncryptionKeyLength defaults to 128. This means that someone wants to use ESAPI to
                 // encrypt with something like 2-key TDES, they would have to set this to that property
                 // to 112 bits.
                 logger.error(Logger.SECURITY_FAILURE, ""Actual key size of "" + keySize + "" bits SMALLER THAN MINIMUM allowed "" +
                         ""encryption key length (ESAPI.EncryptionKeyLength) of "" + minKeyLen + "" bits with cipher algorithm "" + cipherAlg);
                 throw new ConfigurationException(""Actual key size of "" + keySize + "" bits smaller than specified "" +
                                                  ""encryption key length (ESAPI.EncryptionKeyLength) of "" + minKeyLen + "" bits."");
             }
             if ( keySize < 112 ) {     // NIST Special Pub 800-57 considers 112-bits to be the minimally safe key size from 2010-2030.
                                        // Note that 112 bits 'just happens' to be size of 2-key Triple DES! So for example, if they
                                        // have configured ESAPI's Encryptor.EncryptionKeyLength to (say) 56 bits, we are going to
                                        // nag them like their mother! :)
                 logger.warning(Logger.SECURITY_FAILURE, ""Potentially insecure encryption. Key size of "" + keySize + ""bits "" +
                                ""not sufficiently long for "" + cipherAlg + "". Should use appropriate algorithm with key size "" +
                                ""of *at least* 112 bits except when required by legacy apps. See NIST Special Pub 800-57."");
             }
             // Check if algorithm mentioned in SecretKey is same as that being used for Cipher object.
             // They should be the same. If they are different, things could fail. (E.g., DES and DESede
             // require keys with even parity. Even if key was sufficient size, if it didn't have the correct
             // parity it could fail.)
             //
             String skeyAlg = key.getAlgorithm();
             if ( !( cipherAlg.startsWith( skeyAlg + ""/"" ) || cipherAlg.equals( skeyAlg ) ) ) {
                 // DISCUSS: Should we thrown a ConfigurationException here or just log a warning??? I'm game for
                 //          either, but personally I'd prefer the squeaky wheel to the annoying throwing of
                 //          a ConfigurationException (which is a RuntimeException). Less likely to upset
                 //          the development community.
                 logger.warning(Logger.SECURITY_FAILURE, ""Encryption mismatch between cipher algorithm ("" +
                         cipherAlg + "") and SecretKey algorithm ("" + skeyAlg + ""). Cipher will use algorithm "" + cipherAlg);
             }

             byte[] ivBytes = null;
             CipherSpec cipherSpec = new CipherSpec(encrypter, keySize);    // Could pass the ACTUAL (intended) key size

             // Using cipher mode that supports *both* confidentiality *and* authenticity? If so, then
             // use the specified SecretKey as-is rather than computing a derived key from it. We also
             // don't expect a separate MAC in the specified CipherText object so therefore don't try
             // to validate it.
             boolean preferredCipherMode = CryptoHelper.isCombinedCipherMode( cipherMode );
             SecretKey encKey = null;
             if ( preferredCipherMode ) {
                 encKey = key;
             } else {
                 encKey = computeDerivedKey(KeyDerivationFunction.kdfVersion, getDefaultPRF(),
                                            key, keySize, ""encryption"");
             }

             if ( cipherSpec.requiresIV() ) {
                 String ivType = ESAPI.securityConfiguration().getIVType();
                 IvParameterSpec ivSpec = null;
                 if ( ivType.equalsIgnoreCase(""random"") ) {
                     ivBytes = ESAPI.randomizer().getRandomBytes(encrypter.getBlockSize());
                 } else if ( ivType.equalsIgnoreCase(""fixed"") ) {
                     String fixedIVAsHex = ESAPI.securityConfiguration().getFixedIV();
                     ivBytes = Hex.decode(fixedIVAsHex);
                     /* FUTURE       } else if ( ivType.equalsIgnoreCase(""specified"")) {
                            // FUTURE - TODO  - Create instance of specified class to use for IV generation and
                            //                   use it to create the ivBytes. (The intent is to make sure that
                            //                   1) IVs are never repeated for cipher modes like OFB and CFB, and
                            //                   2) to screen for weak IVs for the particular cipher algorithm.
                            //      In meantime, use 'random' for block cipher in feedback mode. Unlikely they will
                            //      be repeated unless you are salting SecureRandom with same value each time. Anything
                            //      monotonically increasing should be suitable, like a counter, but need to remember
                            //      it across JVM restarts. Was thinking of using System.currentTimeMillis(). While
                            //      it's not perfect it probably is good enough. Could even all (advanced) developers
                            //      to define their own class to create a unique IV to allow them some choice, but
                            //      definitely need to provide a safe, default implementation.
                      */
                 } else {
                     // TODO: Update to add 'specified' once that is supported and added above.
                     throw new ConfigurationException(""Property Encryptor.ChooseIVMethod must be set to 'random' or 'fixed'"");
                 }
                 ivSpec = new IvParameterSpec(ivBytes);
                 cipherSpec.setIV(ivBytes);
                 encrypter.init(Cipher.ENCRYPT_MODE, encKey, ivSpec);
             } else {
                 encrypter.init(Cipher.ENCRYPT_MODE, encKey);
             }
             logger.debug(Logger.EVENT_SUCCESS, ""Encrypting with "" + cipherSpec);
             byte[] raw = encrypter.doFinal(plaintext);
                 // Convert to CipherText.
             CipherText ciphertext = new CipherText(cipherSpec, raw);

             // If we are using a ""preferred"" cipher mode--i.e., one that supports *both* confidentiality and
             // authenticity, there is no point to store a separate MAC in the CipherText object. Thus we only
             // do this when we are not using such a cipher mode.
             if ( !preferredCipherMode ) {
                 // Compute derived key, and then use it to compute and store separate MAC in CipherText object.
                 SecretKey authKey = computeDerivedKey(KeyDerivationFunction.kdfVersion, getDefaultPRF(),
                                                       key, keySize, ""authenticity"");
                 ciphertext.computeAndStoreMAC(  authKey );
             }
             logger.debug(Logger.EVENT_SUCCESS, ""JavaEncryptor.encrypt(SecretKey,byte[],boolean,boolean) -- success!"");
             success = true;    // W00t!!!
             return ciphertext;
        } catch (InvalidKeyException ike) {
             throw new EncryptionException(""Encryption failure: Invalid key exception."",
                     ""Requested key size: "" + keySize + ""bits greater than 128 bits. Must install unlimited strength crypto extension from Sun: "" +
                     ike.getMessage(), ike);
         } catch (ConfigurationException cex) {
             throw new EncryptionException(""Encryption failure: Configuration error. Details in log."", ""Key size mismatch or unsupported IV method. "" +
                     ""Check encryption key size vs. ESAPI.EncryptionKeyLength or Encryptor.ChooseIVMethod property."", cex);
         } catch (InvalidAlgorithmParameterException e) {
             throw new EncryptionException(""Encryption failure (invalid IV)"",
                     ""Encryption problem: Invalid IV spec: "" + e.getMessage(), e);
         } catch (IllegalBlockSizeException e) {
             throw new EncryptionException(""Encryption failure (no padding used; invalid input size)"",
                     ""Encryption problem: Invalid input size without padding ("" + xform + ""). "" + e.getMessage(), e);
         } catch (BadPaddingException e) {
             throw new EncryptionException(""Encryption failure"",
                     ""[Note: Should NEVER happen in encryption mode.] Encryption problem: "" + e.getMessage(), e);
         } catch (NoSuchAlgorithmException e) {
             throw new EncryptionException(""Encryption failure (unavailable cipher requested)"",
                     ""Encryption problem: specified algorithm in cipher xform "" + xform + "" not available: "" + e.getMessage(), e);
         } catch (NoSuchPaddingException e) {
             throw new EncryptionException(""Encryption failure (unavailable padding scheme requested)"",
                     ""Encryption problem: specified padding scheme in cipher xform "" + xform + "" not available: "" + e.getMessage(), e);
         } finally {
             // Don't overwrite anything in the case of exceptions because they may wish to retry.
             if ( success && overwritePlaintext ) {
                 plain.overwrite();     // Note: Same as overwriting 'plaintext' byte array.
             }
         }
    }

    /**
    * {@inheritDoc}
    */
    public PlainText decrypt(CipherText ciphertext) throws EncryptionException {
         // Now more of a convenience function for using the master key.
         return decrypt(secretKeySpec, ciphertext);
    }

    /**
     * {@inheritDoc}
     */
    public PlainText decrypt(SecretKey key, CipherText ciphertext)
        throws EncryptionException, IllegalArgumentException
    {
        long start = System.nanoTime();  // Current time in nanosecs; used to prevent timing attacks
        if ( key == null ) {
            throw new IllegalArgumentException(""SecretKey arg may not be null"");
        }
        if ( ciphertext == null ) {
            throw new IllegalArgumentException(""Ciphertext may arg not be null"");
        }

        if ( ! CryptoHelper.isAllowedCipherMode(ciphertext.getCipherMode()) ) {
            // This really should be an illegal argument exception, but it could
            // mean that a partner encrypted something using a cipher mode that
            // you do not accept, so it's a bit more complex than that. Also
            // throwing an IllegalArgumentException doesn't allow us to provide
            // the two separate error messages or automatically log it.
            throw new EncryptionException(DECRYPTION_FAILED,
                    ""Invalid cipher mode "" + ciphertext.getCipherMode() +
                    "" not permitted for decryption or encryption operations."");
        }
        logger.debug(Logger.EVENT_SUCCESS,
                ""Args valid for JavaEncryptor.decrypt(SecretKey,CipherText): "" +
                ciphertext);

        PlainText plaintext = null;
        boolean caughtException = false;
        int progressMark = 0;
        try {
            // First we validate the MAC.
            boolean valid = CryptoHelper.isCipherTextMACvalid(key, ciphertext);
            if ( !valid ) {
                try {
                    // This is going to fail, but we want the same processing
                    // to occur as much as possible so as to prevent timing
                    // attacks. We _could_ just be satisfied by the additional
                    // sleep in the 'finally' clause, but an attacker on the
                    // same server who can run something like 'ps' can tell
                    // CPU time versus when the process is sleeping. Hence we
                    // try to make this as close as possible. Since we know
                    // it is going to fail, we ignore the result and ignore
                    // the (expected) exception.
                    handleDecryption(key, ciphertext); // Ignore return (should fail).
                } catch(Exception ex) {
                    ;   // Ignore
                }
                throw new EncryptionException(DECRYPTION_FAILED,
                        ""Decryption failed because MAC invalid for "" +
                        ciphertext);
            }
            progressMark++;
            // The decryption only counts if the MAC was valid.
            plaintext = handleDecryption(key, ciphertext);
            progressMark++;
        } catch(EncryptionException ex) {
            caughtException = true;
            String logMsg = null;
            switch( progressMark ) {
            case 1:
                logMsg = ""Decryption failed because MAC invalid. See logged exception for details."";
                break;
            case 2:
                logMsg = ""Decryption failed because handleDecryption() failed. See logged exception for details."";
                break;
            default:
                logMsg = ""Programming error: unexpected progress mark == "" + progressMark;
            break;
            }
            logger.error(Logger.SECURITY_FAILURE, logMsg);
            throw ex;           // Re-throw
        }
        finally {
            if ( caughtException ) {
                // The rest of this code is to try to account for any minute differences
                // in the time it might take for the various reasons that decryption fails
                // in order to prevent any other possible timing attacks. Perhaps it is
                // going overboard. If nothing else, if N_SECS is large enough, it might
                // deter attempted repeated attacks by making them take much longer.
                long now = System.nanoTime();
                long elapsed = now - start;
                final long NANOSECS_IN_SEC = 1000000000L; // nanosec is 10**-9 sec
                long nSecs = N_SECS * NANOSECS_IN_SEC;  // N seconds in nano seconds
                if ( elapsed < nSecs ) {
                    // Want to sleep so total time taken is N seconds.
                    long extraSleep = nSecs - elapsed;

                    // 'extraSleep' is in nanoseconds. Need to convert to a millisec
                    // part and nanosec part. Nanosec is 10**-9, millsec is
                    // 10**-3, so divide by (10**-9 / 10**-3), or 10**6 to
                    // convert to from nanoseconds to milliseconds.
                    long millis = extraSleep / 1000000L;
                    long nanos  = (extraSleep - (millis * 1000000L));

                    // N_SECS is hard-coded so assertion should be okay here.
                    assert nanos >= 0 && nanos <= Integer.MAX_VALUE :
                            ""Nanosecs out of bounds; nanos = "" + nanos;
                    try {
                        Thread.sleep(millis, (int)nanos);
                    } catch(InterruptedException ex) {
                        ;   // Ignore
                    }
                } // Else ... time already exceeds N_SECS sec, so do not sleep.
            }
        }
        return plaintext;
    }

    // Handle the actual decryption portion. At this point it is assumed that
    // any MAC has already been validated. (But see ""DISCUSS"" issue, below.)
    private PlainText handleDecryption(SecretKey key, CipherText ciphertext)
        throws EncryptionException
    {
        int keySize = 0;
        try {
            Cipher decrypter = Cipher.getInstance(ciphertext.getCipherTransformation());
            keySize = key.getEncoded().length * 8;  // Convert to # bits

            // Using cipher mode that supports *both* confidentiality *and* authenticity? If so, then
            // use the specified SecretKey as-is rather than computing a derived key from it. We also
            // don't expect a separate MAC in the specified CipherText object so therefore don't try
            // to validate it.
            boolean preferredCipherMode = CryptoHelper.isCombinedCipherMode( ciphertext.getCipherMode() );
            SecretKey encKey = null;
            if ( preferredCipherMode ) {
                encKey = key;
            } else {
                // TODO: PERFORMANCE: Calculate avg time this takes and consider caching for very short interval
                //       (e.g., 2 to 5 sec tops). Otherwise doing lots of encryptions in a loop could take a LOT longer.
                //       But remember Jon Bentley's ""Rule #1 on performance: First make it right, then make it fast.""
                //       This would be a security trade-off as it would leave keys in memory a bit longer, so it
                //       should probably be off by default and controlled via a property.
                //
                // TODO: Feed in some additional parms here to use as the 'context' for the
                //       KeyDerivationFunction...especially the KDF version. We would have to
                //       store that in the CipherText object. We *possibly* could make it
                //       transient so it would not be serialized with the CipherText object,
                //       otherwise we would have to implement readObject() and writeObject()
                //       methods there to support backward compatibility. Anyhow the intent
                //       is to prevent down grade attacks when we finally re-design and
                //       re-implement the MAC. Think about this in version 2.1.1.
                encKey = computeDerivedKey( ciphertext.getKDFVersion(), ciphertext.getKDF_PRF(),
                                            key, keySize, ""encryption"");
            }
            if ( ciphertext.requiresIV() ) {
                decrypter.init(Cipher.DECRYPT_MODE, encKey, new IvParameterSpec(ciphertext.getIV()));
            } else {
                decrypter.init(Cipher.DECRYPT_MODE, encKey);
            }
            byte[] output = decrypter.doFinal(ciphertext.getRawCipherText());
            return new PlainText(output);

        } catch (InvalidKeyException ike) {
            throw new EncryptionException(DECRYPTION_FAILED, ""Must install JCE Unlimited Strength Jurisdiction Policy Files from Sun"", ike);
        } catch (NoSuchAlgorithmException e) {
            throw new EncryptionException(DECRYPTION_FAILED, ""Invalid algorithm for available JCE providers - "" +
                    ciphertext.getCipherTransformation() + "": "" + e.getMessage(), e);
        } catch (NoSuchPaddingException e) {
            throw new EncryptionException(DECRYPTION_FAILED, ""Invalid padding scheme ("" +
                    ciphertext.getPaddingScheme() + "") for cipher transformation "" + ciphertext.getCipherTransformation() +
                    "": "" + e.getMessage(), e);
        } catch (InvalidAlgorithmParameterException e) {
            throw new EncryptionException(DECRYPTION_FAILED, ""Decryption problem: "" + e.getMessage(), e);
        } catch (IllegalBlockSizeException e) {
            throw new EncryptionException(DECRYPTION_FAILED, ""Decryption problem: "" + e.getMessage(), e);
        } catch (BadPaddingException e) {
            // DISCUSS: This needs fixed. Already validated MAC in CryptoHelper.isCipherTextMACvalid() above.
            // So only way we could get a padding exception is if invalid padding were used originally by
            // the party doing the encryption. (This might happen with a buggy padding scheme for instance.)
            // It *seems* harmless though, so will leave it for now, and technically, we need to either catch it
            // or declare it in a throws class. Clearly we don't want to do the later. This should be discussed
            // during a code inspection.
            SecretKey authKey;
            try {
                authKey = computeDerivedKey( ciphertext.getKDFVersion(), ciphertext.getKDF_PRF(),
                                             key, keySize, ""authenticity"");
            } catch (Exception e1) {
                throw new EncryptionException(DECRYPTION_FAILED,
                        ""Decryption problem -- failed to compute derived key for authenticity: "" + e1.getMessage(), e1);
            }
            boolean success = ciphertext.validateMAC( authKey );
            if ( success ) {
                throw new EncryptionException(DECRYPTION_FAILED, ""Decryption problem: "" + e.getMessage(), e);
            } else {
                throw new EncryptionException(DECRYPTION_FAILED,
                        ""Decryption problem: WARNING: Adversary may have tampered with "" +
                        ""CipherText object orCipherText object mangled in transit: "" + e.getMessage(), e);
            }
        }
    }

    /**
    * {@inheritDoc}
    */
    public String sign(String data) throws EncryptionException {
        try {
            Signature signer = Signature.getInstance(signatureAlgorithm);
            signer.initSign(privateKey);
            signer.update(data.getBytes(encoding));
            byte[] bytes = signer.sign();
            return ESAPI.encoder().encodeForBase64(bytes, false);
        } catch (InvalidKeyException ike) {
            throw new EncryptionException(""Encryption failure"", ""Must install unlimited strength crypto extension from Sun"", ike);
        } catch (Exception e) {
            throw new EncryptionException(""Signature failure"", ""Can't find signature algorithm "" + signatureAlgorithm, e);
        }
    }

    /**
    * {@inheritDoc}
    */
    public boolean verifySignature(String signature, String data) {
        try {
            byte[] bytes = ESAPI.encoder().decodeFromBase64(signature);
            Signature signer = Signature.getInstance(signatureAlgorithm);
            signer.initVerify(publicKey);
            signer.update(data.getBytes(encoding));
            return signer.verify(bytes);
        } catch (Exception e) {
            // NOTE: EncryptionException constructed *only* for side-effect of causing logging.
            // FindBugs complains about this and since it examines byte-code, there's no way to
            // shut it up.
            new EncryptionException(""Invalid signature"", ""Problem verifying signature: "" + e.getMessage(), e);
            return false;
        }
    }

    /**
    * {@inheritDoc}
     *
     * @param expiration
     * @throws IntegrityException
     */
    public String seal(String data, long expiration) throws IntegrityException {
        if ( data == null ) {
            throw new IllegalArgumentException(""Data to be sealed may not be null."");
        }

        try {
            String b64data = null;
            try {
                b64data = ESAPI.encoder().encodeForBase64(data.getBytes(""UTF-8""), false);
            } catch (UnsupportedEncodingException e) {
                ; // Ignore; should never happen since UTF-8 built into rt.jar
            }
            // mix in some random data so even identical data and timestamp produces different seals
            String nonce = ESAPI.randomizer().getRandomString(10, EncoderConstants.CHAR_ALPHANUMERICS);
            String plaintext = expiration + "":"" + nonce + "":"" + b64data;
            // add integrity check; signature is already base64 encoded.
            String sig = this.sign( plaintext );
            CipherText ciphertext = this.encrypt( new PlainText(plaintext + "":"" + sig) );
            String sealedData = ESAPI.encoder().encodeForBase64(ciphertext.asPortableSerializedByteArray(), false);
            return sealedData;
        } catch( EncryptionException e ) {
            throw new IntegrityException( e.getUserMessage(), e.getLogMessage(), e );
        }
    }

    /**
    * {@inheritDoc}
    */
    public String unseal(String seal) throws EncryptionException {
        PlainText plaintext = null;
        try {
            byte[] encryptedBytes = ESAPI.encoder().decodeFromBase64(seal);
            CipherText cipherText = null;
            try {
                cipherText = CipherText.fromPortableSerializedBytes(encryptedBytes);
            } catch( AssertionError e) {
                // Some of the tests in EncryptorTest.testVerifySeal() are examples of
                // this if assertions are enabled, but otherwise it should not
                // normally happen.
                throw new EncryptionException(""Invalid seal"",
                                              ""Seal passed garbarge data resulting in AssertionError: "" + e);
            }
            plaintext = this.decrypt(cipherText);

            String[] parts = plaintext.toString().split("":"");
            if (parts.length != 4) {
                throw new EncryptionException(""Invalid seal"", ""Seal was not formatted properly."");
            }

            String timestring = parts[0];
            long now = new Date().getTime();
            long expiration = Long.parseLong(timestring);
            if (now > expiration) {
                throw new EncryptionException(""Invalid seal"", ""Seal expiration date of "" + new Date(expiration) + "" has past."");
            }
            String nonce = parts[1];
            String b64data = parts[2];
            String sig = parts[3];
            if (!this.verifySignature(sig, timestring + "":"" + nonce + "":"" + b64data ) ) {
                throw new EncryptionException(""Invalid seal"", ""Seal integrity check failed"");
            }
            return new String(ESAPI.encoder().decodeFromBase64(b64data), ""UTF-8"");
        } catch (EncryptionException e) {
            throw e;
        } catch (Exception e) {
            throw new EncryptionException(""Invalid seal"", ""Invalid seal:"" + e.getMessage(), e);
        }
    }


    /**
    * {@inheritDoc}
    */
    public boolean verifySeal( String seal ) {
        try {
            unseal( seal );
            return true;
        } catch( EncryptionException e ) {
            return false;
        }
    }

    /**
    * {@inheritDoc}
    */
    public long getTimeStamp() {
        return new Date().getTime();
    }

    /**
    * {@inheritDoc}
    */
    public long getRelativeTimeStamp( long offset ) {
        return new Date().getTime() + offset;
    }

    // DISCUSS: Why experimental? Would have to be added to Encryptor interface
    //          but only 3 things I saw wrong with this was 1) it used HMacMD5 instead
    //          of HMacSHA1 (see discussion below), 2) that the HMac key is the
    //          same one used for encryption (also see comments), and 3) it caught
    //          overly broad exceptions. Here it is with these specific areas
    //          addressed, but no unit testing has been done at this point. -kww
   /**
    * Compute an HMAC for a String.  Experimental.
    * @param input  The input for which to compute the HMac.
    */
/********************
    public String computeHMAC( String input ) throws EncryptionException {
        try {
            Mac hmac = Mac.getInstance(""HMacSHA1""); // DISCUSS: Changed to HMacSHA1. MD5 *badly* broken
                                                   //          SHA1 should really be avoided, but using
                                                   //          for HMAC-SHA1 is acceptable for now. Plan
                                                   //          to migrate to SHA-256 or NIST replacement for
                                                   //          SHA1 in not too distant future.
            // DISCUSS: Also not recommended that the HMac key is the same as the one
            //          used for encryption (namely, Encryptor.MasterKey). If anything it
            //          would be better to use Encryptor.MasterSalt for the HMac key, or
            //          perhaps a derived key based on the master salt. (One could use
            //          KeyDerivationFunction.computeDerivedKey().)
            //
            byte[] salt = ESAPI.securityConfiguration().getMasterSalt();
            hmac.init( new SecretKeySpec(salt, ""HMacSHA1"") );   // Was: hmac.init(secretKeySpec)
            byte[] inBytes;
            try {
                inBytes = input.getBytes(""UTF-8"");
            } catch (UnsupportedEncodingException e) {
                logger.warning(Logger.SECURITY_FAILURE, ""computeHMAC(): Can't find UTF-8 encoding; using default encoding"", e);
                inBytes = input.getBytes();
            }
            byte[] bytes = hmac.doFinal( inBytes );
            return ESAPI.encoder().encodeForBase64(bytes, false);
        } catch (InvalidKeyException ike) {
            throw new EncryptionException(""Encryption failure"", ""Must install unlimited strength crypto extension from Sun"", ike);
        } catch (NoSuchAlgorithmException e) {
            throw new EncryptionException(""Could not compute HMAC"", ""Can't find HMacSHA1 algorithm. "" +
                                                                    ""Problem computing HMAC for "" + input, e );
        }
    }
********************/

    /**
     * Log a security warning every Nth time one of the deprecated encrypt or
     * decrypt methods are called. ('N' is hard-coded to be 25 by default, but
     * may be changed via the system property
     * {@code ESAPI.Encryptor.warnEveryNthUse}.) In other words, we nag
     * them until the give in and change it. ;-)
     *
     * @param where The string ""encrypt"" or ""decrypt"", corresponding to the
     *              method that is being logged.
     * @param msg   The message to log.
     */
    private void logWarning(String where, String msg) {
        int counter = 0;
        if ( where.equals(""encrypt"") ) {
            counter = encryptCounter++;
            where = ""JavaEncryptor.encrypt(): [count="" + counter +""]"";
        } else if ( where.equals(""decrypt"") ) {
            counter = decryptCounter++;
            where = ""JavaEncryptor.decrypt(): [count="" + counter +""]"";
        } else {
            where = ""JavaEncryptor: Unknown method: "";
        }
        // We log the very first time (note the use of post-increment on the
        // counters) and then every Nth time thereafter. Logging every single
        // time is likely to be way too much logging.
        if ( (counter % logEveryNthUse) == 0 ) {
            logger.warning(Logger.SECURITY_FAILURE, where + msg);
        }
    }

    private KeyDerivationFunction.PRF_ALGORITHMS getPRF(String name) {
        String prfName = null;
        if ( name == null ) {
            prfName = ESAPI.securityConfiguration().getKDFPseudoRandomFunction();
        } else {
            prfName = name;
        }
        KeyDerivationFunction.PRF_ALGORITHMS prf = KeyDerivationFunction.convertNameToPRF(prfName);
        return prf;
    }

    private KeyDerivationFunction.PRF_ALGORITHMS getDefaultPRF() {
        String prfName = ESAPI.securityConfiguration().getKDFPseudoRandomFunction();
        return getPRF(prfName);
    }

    // Private interface to call ESAPI's KDF to get key for encryption or authenticity.
    private SecretKey computeDerivedKey(int kdfVersion, KeyDerivationFunction.PRF_ALGORITHMS prf,
                                        SecretKey kdk, int keySize, String purpose)
        throws NoSuchAlgorithmException, InvalidKeyException, EncryptionException
    {
        // These really should be turned into actual runtime checks and an
        // IllegalArgumentException should be thrown if they are violated.
        // But this should be OK since this is a private method. Also, this method will
        // be called quite often so assertions are a big win as they can be disabled or
        // enabled at will.
        assert prf != null : ""Pseudo Random Function for KDF cannot be null"";
        assert kdk != null : ""Key derivation key cannot be null."";
        // We would choose a larger minimum key size, but we want to be
        // able to accept DES for legacy encryption needs. NIST says 112-bits is min. If less than that,
        // we print warning.
        assert keySize >= 56 : ""Key has size of "" + keySize + "", which is less than absolute minimum of 56-bits."";
        assert (keySize % 8) == 0 : ""Key size ("" + keySize + "") must be a even multiple of 8-bits."";

        // However, this one we want as a runtime check because we don't have this check
        // in KeyDerivationFunction.computeDerivedKey() as we want that method
        // to be more general.
        if ( !( purpose.equals(""encryption"") || purpose.equals(""authenticity"") ) ) {
            String exMsg = ""Programming error in ESAPI?? 'purpose' for computeDerivedKey() must be \""encryption\"" or \""authenticity\""."";
            throw new EncryptionException(exMsg, exMsg);
        }

        KeyDerivationFunction kdf = new KeyDerivationFunction(prf);
        if ( kdfVersion != 0 ) {
            kdf.setVersion(kdfVersion);
        }
        return kdf.computeDerivedKey(kdk, keySize, purpose);
    }

    // Get all the algorithms we will be using from ESAPI.properties.
    private static void setupAlgorithms() {
        // setup algorithms
        encryptAlgorithm = ESAPI.securityConfiguration().getEncryptionAlgorithm();
        signatureAlgorithm = ESAPI.securityConfiguration().getDigitalSignatureAlgorithm();
        randomAlgorithm = ESAPI.securityConfiguration().getRandomAlgorithm();
        hashAlgorithm = ESAPI.securityConfiguration().getHashAlgorithm();
        hashIterations = ESAPI.securityConfiguration().getHashIterations();
        encoding = ESAPI.securityConfiguration().getCharacterEncoding();
        encryptionKeyLength = ESAPI.securityConfiguration().getEncryptionKeyLength();
        signatureKeyLength = ESAPI.securityConfiguration().getDigitalSignatureKeyLength();
    }

    // Set up signing key pair using the master password and salt. Called (once)
    // from the JavaEncryptor CTOR.
    private static void initKeyPair(SecureRandom prng) throws NoSuchAlgorithmException {
        String sigAlg = signatureAlgorithm.toLowerCase();
        if ( sigAlg.endsWith(""withdsa"") ) {
            //
            // Admittedly, this is a kludge. However for Sun JCE, even though
            // ""SHA1withDSA"" is a valid signature algorithm name, if one calls
            //      KeyPairGenerator kpg = KeyPairGenerator.getInstance(""SHA1withDSA"");
            // that will throw a NoSuchAlgorithmException with an exception
            // message of ""SHA1withDSA KeyPairGenerator not available"". Since
            // SHA1withDSA and DSA keys should be identical, we use ""DSA""
            // in the case that SHA1withDSA or SHAwithDSA was specified. This is
            // all just to make these 2 work as expected. Sigh. (Note:
            // this was tested with JDK 1.6.0_21, but likely fails with earlier
            // versions of the JDK as well. Haven't experimented with later
            // versions.)
            //
            sigAlg = ""DSA"";
        } else if ( sigAlg.endsWith(""withrsa"") ) {
            // Ditto for RSA.
            sigAlg = ""RSA"";
        }
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(sigAlg);
        keyGen.initialize(signatureKeyLength, prng);
        KeyPair pair = keyGen.generateKeyPair();
        privateKey = pair.getPrivate();
        publicKey = pair.getPublic();
    }
}
"
"src/main/java/org/owasp/esapi/reference/crypto/JavaEncryptor.java:[348,351]:encrypt","     public CipherText encrypt(PlainText plaintext) throws EncryptionException {
         // Now more of a convenience function for using the master key.
         return encrypt(secretKeySpec, plaintext);
     }
"
"src/main/java/org/owasp/esapi/reference/crypto/JavaEncryptor.java:[543,546]:decrypt","    public PlainText decrypt(CipherText ciphertext) throws EncryptionException {
         // Now more of a convenience function for using the master key.
         return decrypt(secretKeySpec, ciphertext);
    }
"
"src/main/java/org/owasp/esapi/crypto/CipherTextSerializer.java:[35,459]:CipherTextSerializer","public class CipherTextSerializer {
    // This should be *same* version as in CipherText & KeyDerivationFunction as
    // these versions all need to work together.  Therefore, when one changes one
    // one these versions, the other should be reviewed and changed as well to
    // accommodate any differences.
    //        Previous versions:    20110203 - Original version (ESAPI releases 2.0 & 2.0.1)
    //                            20130830 - Fix to issue #306 (release 2.1.0)
    // We check that in an static initialization block below.
    public  static final  int cipherTextSerializerVersion = 20130830; // Current version. Format: YYYYMMDD, max is 99991231.
    private static final long serialVersionUID = cipherTextSerializerVersion;

    private static final Logger logger = ESAPI.getLogger(""CipherTextSerializer"");
    
    private CipherText cipherText_ = null;
    
    // Check if versions of KeyDerivationFunction, CipherText, and
    // CipherTextSerializer are all the same.
    {
        // Ignore error about comparing identical versions and dead code.
        // We expect them to be, but the point is to catch us if they aren't.
        if ( CipherTextSerializer.cipherTextSerializerVersion != CipherText.cipherTextVersion ) {
            throw new ExceptionInInitializerError(""Versions of CipherTextSerializer and CipherText are not compatible."");
        }
        if ( CipherTextSerializer.cipherTextSerializerVersion != KeyDerivationFunction.kdfVersion ) {
            throw new ExceptionInInitializerError(""Versions of CipherTextSerializer and KeyDerivationFunction are not compatible."");
        }
    }
    
    public CipherTextSerializer(CipherText cipherTextObj) {
        if ( cipherTextObj == null ) {
            throw new IllegalArgumentException(""CipherText object must not be null."");
        }
        cipherText_ = cipherTextObj;
    }
    
    /**
     * Given byte array in network byte order (i.e., big-endian order), convert
     * it so that a {@code CipherText} can be constructed from it.
     * @param cipherTextSerializedBytes A serialized {@code CipherText} object
     *          with the bytes in network byte order.
     * @throws EncryptionException Thrown if a valid {@code CipherText} object
     *          cannot be reconstructed from the byte array.
     */
    public CipherTextSerializer(byte[] cipherTextSerializedBytes)
        throws EncryptionException /* DISCUSS: Change exception type?? */
    {
        cipherText_ = convertToCipherText(cipherTextSerializedBytes);
    }

    /** Return this {@code CipherText} object as a specialized, portable
     *  serialized byte array.
     * @return A serialization of this object. Note that this is <i>not</i> the
     * Java serialization.
     */
    public byte[] asSerializedByteArray() {
        int kdfInfo = cipherText_.getKDFInfo();
        debug(""asSerializedByteArray: kdfInfo = "" + kdfInfo);
        long timestamp = cipherText_.getEncryptionTimestamp();
        String cipherXform = cipherText_.getCipherTransformation();
        if ( cipherText_.getKeySize() >= Short.MAX_VALUE ) {
            throw new IllegalArgumentException(""Key size is too large. Max is "" + Short.MAX_VALUE);
        }
        short keySize = (short) cipherText_.getKeySize();
        if ( cipherText_.getBlockSize() >= Short.MAX_VALUE ) {
            throw new IllegalArgumentException(""Block size is too large. Max is "" + Short.MAX_VALUE);
        }
        short blockSize = (short) cipherText_.getBlockSize();
        byte[] iv = cipherText_.getIV();
        if ( iv.length >= Short.MAX_VALUE ) {
            throw new IllegalArgumentException(""IV size too large. Max is "" + Short.MAX_VALUE + "" bytes"");
        }
        short ivLen = (short) iv.length;
        byte[] rawCiphertext = cipherText_.getRawCipherText();
        int ciphertextLen = rawCiphertext.length;
        // Coverity issue 1352406, GitHub issue # 364 - possible NPE later if assertion disabled.
        // Replaced assertion with explicit check.
        if ( ciphertextLen < 1 ) {
            throw new IllegalArgumentException(""Raw ciphertext length must be >= 1 byte."");
        }
        byte[] mac = cipherText_.getSeparateMAC();
        if ( mac.length >= Short.MAX_VALUE ) {
            throw new IllegalArgumentException(""MAC length too large. Max is "" + Short.MAX_VALUE + "" bytes"");
        }
        short macLen = (short) mac.length;
        
        byte[] serializedObj = computeSerialization(kdfInfo,
                                                    timestamp,
                                                    cipherXform,
                                                    keySize,
                                                    blockSize,
                                                    ivLen,
                                                    iv,
                                                    ciphertextLen,
                                                    rawCiphertext,
                                                    macLen,
                                                    mac
                                                   );
        
        return serializedObj;
    }
    
    /**
     * Return the actual {@code CipherText} object.
     * @return The {@code CipherText} object that we are serializing.
     */
    public CipherText asCipherText() {
        if ( cipherText_ == null ) {
            throw new IllegalArgumentException(""Program error? CipherText object, cipherText_, must not be null."");
        }
        return cipherText_;
    }
      
    /**
     * Take all the individual elements that make of the serialized ciphertext
     * format and put them in order and return them as a byte array.
     * @param kdfInfo    Info about the KDF... which PRF and the KDF version {@link #asCipherText()}.
     * @param timestamp    Timestamp when the data was encrypted. Intended to help
     *                     facilitate key change operations and nothing more. If it is meaningless,
     *                     then the expectations are just that the recipient should ignore it. Mostly
     *                     intended when encrypted data is kept long term over a period of many
     *                     key change operations.
     * @param cipherXform    Details of how the ciphertext was encrypted. The format used
     *                         is the same as used by {@code javax.crypto.Cipher}, namely,
     *                         ""cipherAlg/cipherMode/paddingScheme"".
     * @param keySize    The key size used for encrypting. Intended for cipher algorithms
     *                     supporting multiple key sizes such as triple DES (DESede) or
     *                     Blowfish.
     * @param blockSize    The cipher block size. Intended to support cipher algorithms
     *                     that support variable block sizes, such as Rijndael.
     * @param ivLen        The length of the IV.
     * @param iv        The actual IV (initialization vector) bytes.
     * @param ciphertextLen    The length of the raw ciphertext.
     * @param rawCiphertext    The actual raw ciphertext itself
     * @param macLen    The length of the MAC (message authentication code).
     * @param mac        The MAC itself.
     * @return    A byte array representing the serialized ciphertext.
     */
    private byte[] computeSerialization(int kdfInfo, long timestamp,
                                        String cipherXform, short keySize,
                                        short blockSize,
                                        short ivLen, byte[] iv,
                                        int ciphertextLen, byte[] rawCiphertext,
                                        short macLen, byte[] mac
                                       )
    {
        debug(""computeSerialization: kdfInfo = "" + kdfInfo);
        debug(""computeSerialization: timestamp = "" + new Date(timestamp));
        debug(""computeSerialization: cipherXform = "" + cipherXform);
        debug(""computeSerialization: keySize = "" + keySize);
        debug(""computeSerialization: blockSize = "" + blockSize);
        debug(""computeSerialization: ivLen = "" + ivLen);
        debug(""computeSerialization: ciphertextLen = "" + ciphertextLen);
        debug(""computeSerialization: macLen = "" + macLen);

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        writeInt(baos, kdfInfo);
        writeLong(baos, timestamp);
        String[] parts = cipherXform.split(""/"");
        if ( parts.length != 3 ) {
            throw new IllegalArgumentException(""Program error? Malformed cipher tranformation: "" + cipherXform);
        }
        writeString(baos, cipherXform); // Size of string is prepended to string
        writeShort(baos, keySize);
        writeShort(baos, blockSize);
        writeShort(baos, ivLen);
        if ( ivLen > 0 ) baos.write(iv, 0, iv.length);
        writeInt(baos, ciphertextLen);
        baos.write(rawCiphertext, 0, rawCiphertext.length);
        writeShort(baos, macLen);
        if ( macLen > 0 ) baos.write(mac, 0, mac.length);
        return baos.toByteArray();
    }
    
    // All strings are written as UTF-8 encoded byte streams with the
    // length prepended before it as a short. The prepended length is
    // more for the benefit of languages like C so they can pre-allocate
    // char arrays without worrying about buffer overflows.
    private void writeString(ByteArrayOutputStream baos, String str) {
        byte[] bytes;
        try {
            if ( str == null || str.length() == 0 ) {
                throw new IllegalArgumentException(""Program error? writeString: str is null or empty!"");
            }
            bytes = str.getBytes(""UTF8"");
            if ( bytes.length >= Short.MAX_VALUE ) {
                throw new IllegalArgumentException(""Program error? writeString: String exceeds max length of "" +
                                                   Short.MAX_VALUE + "" bytes"");
            }
            writeShort(baos, (short)bytes.length);
            baos.write(bytes, 0, bytes.length);
        } catch (UnsupportedEncodingException e) {
            // Should never happen. UTF8 is built into the rt.jar. We don't use native encoding as
            // a fall-back because that simply is not guaranteed to be portable across Java
            // platforms and could cause really bizarre errors way downstream.
            logger.error(Logger.EVENT_FAILURE, ""Ignoring caught UnsupportedEncodingException "" +
                           ""converting string to UTF8 encoding. Results suspect. Corrupt rt.jar????"");
        }
    }
    
    private String readString(ByteArrayInputStream bais, short sz)
        throws NullPointerException, IOException
    {
        byte[] bytes = new byte[sz];
        int ret = bais.read(bytes, 0, sz);
        if ( ret != sz ) {
                throw new IllegalArgumentException(""Program error? readString: Expected to read "" +
                                                   sz + "" bytes, but only read "" + ret + "" bytes"");
        }
        return new String(bytes, ""UTF8"");
    }
    
    private void writeShort(ByteArrayOutputStream baos, short s) {
        byte[] shortAsByteArray = ByteConversionUtil.fromShort(s);
        if ( shortAsByteArray.length != 2 ) {
                throw new IllegalArgumentException(""Program error? writeShort: Excepted byte array != 2 bytes."");
        }
        baos.write(shortAsByteArray, 0, 2);
    }
    
    private short readShort(ByteArrayInputStream bais)
        throws NullPointerException, IndexOutOfBoundsException
    {
        byte[] shortAsByteArray = new byte[2];
        int ret = bais.read(shortAsByteArray, 0, 2);
        if ( ret != 2 ) {
                throw new IllegalArgumentException(""Program error? readShort: Failed to read 2 bytes."");
        }
        return ByteConversionUtil.toShort(shortAsByteArray);
    }
    
    private void writeInt(ByteArrayOutputStream baos, int i) {
        byte[] intAsByteArray = ByteConversionUtil.fromInt(i);
        baos.write(intAsByteArray, 0, 4);
    }
    
    private int readInt(ByteArrayInputStream bais)
        throws NullPointerException, IndexOutOfBoundsException
    {
        byte[] intAsByteArray = new byte[4];
        int ret = bais.read(intAsByteArray, 0, 4);
        if ( ret != 4 ) {
                throw new IllegalArgumentException(""Program error? readInt: Failed to read 4 bytes."");
        }
        return ByteConversionUtil.toInt(intAsByteArray);
    }
    
    private void writeLong(ByteArrayOutputStream baos, long l) {
        byte[] longAsByteArray = ByteConversionUtil.fromLong(l);
        if ( longAsByteArray.length != 8 ) {
                throw new IllegalArgumentException(""Program error? writeLong: Expected byte array != 8 bytes."");
        }
        baos.write(longAsByteArray, 0, 8);
    }
    
    private long readLong(ByteArrayInputStream bais)
        throws NullPointerException, IndexOutOfBoundsException
    {
        byte[] longAsByteArray = new byte[8];
        int ret = bais.read(longAsByteArray, 0, 8);
        if ( ret != 8 ) {
                throw new IllegalArgumentException(""Program error? readLong: Failed to read 8 bytes."");
        }
        return ByteConversionUtil.toLong(longAsByteArray);
    }
    
    /** Convert the serialized ciphertext byte array to a {@code CipherText}
     * object.
     * @param cipherTextSerializedBytes    The serialized ciphertext as a byte array.
     * @return The corresponding {@code CipherText} object.
     * @throws EncryptionException    Thrown if the byte array data is corrupt or
     *                 there are version mismatches, etc.
     */
    private CipherText convertToCipherText(byte[] cipherTextSerializedBytes)
        throws EncryptionException
    {
        try {
            if ( cipherTextSerializedBytes == null ) {
                throw new IllegalArgumentException(""cipherTextSerializedBytes cannot be null."");
            }
            if ( cipherTextSerializedBytes.length == 0 ) {
                throw new IllegalArgumentException(""cipherTextSerializedBytes must be > 0 in length."");
            }
            ByteArrayInputStream bais = new ByteArrayInputStream(cipherTextSerializedBytes);
            int kdfInfo = readInt(bais);
            debug(""kdfInfo: "" + kdfInfo);
            int kdfPrf = (kdfInfo >>> 28);
            debug(""kdfPrf: "" + kdfPrf);
            if ( kdfPrf < 0 || kdfPrf > 16 ) {
                throw new IllegalArgumentException(""Program error? convertToCipherText: kdPrf is "" + kdfPrf +
                                                   "". Must be between 0 and 15 inclusive"");
            }
            int kdfVers = ( kdfInfo & 0x07ffffff);

            // First do a quick sanity check on the argument. Previously this was an assertion.
            if ( ! CryptoHelper.isValidKDFVersion(kdfVers, false, false) ) {
                // TODO: Clean up. Use StringBuilder. Good enough for now.
                String logMsg = ""KDF version read from serialized ciphertext ("" + kdfVers + "") is out of range. "" +
                                ""Valid range for KDF version is ["" + KeyDerivationFunction.originalVersion + "", "" +
                                ""99991231]."";
                // This should never happen under actual circumstances (barring programming errors; but we've
                // tested the code, right?), so it is likely an attempted attack. Thus don't get the originator
                // of the suspect ciphertext too much info. They ought to know what they sent anyhow.
                throw new EncryptionException(""Version info from serialized ciphertext not in valid range."",
                             ""Likely tampering with KDF version on serialized ciphertext."" + logMsg);
            }
            
            debug(""convertToCipherText: kdfPrf = "" + kdfPrf + "", kdfVers = "" + kdfVers);
            if ( ! versionIsCompatible( kdfVers) ) {
                throw new EncryptionException(""This version of ESAPI is not compatible with the version of ESAPI that encrypted your data."",
                        ""KDF version "" + kdfVers + "" from serialized ciphertext not compatibile with current KDF version of "" + 
                        KeyDerivationFunction.kdfVersion);
            }
            long timestamp = readLong(bais);
            debug(""convertToCipherText: timestamp = "" + new Date(timestamp));
            short strSize = readShort(bais);
            debug(""convertToCipherText: length of cipherXform = "" + strSize);
            String cipherXform = readString(bais, strSize);
            debug(""convertToCipherText: cipherXform = "" + cipherXform);
            String[] parts = cipherXform.split(""/"");
            if ( parts.length != 3 ) {
                throw new IllegalArgumentException(""Program error? Malformed cipher transformation. Expecting 3 parts to cipher transformation, "" +
                                                   ""alg/mode/padding, but found "" + parts.length + "" parts ("" + cipherXform + "")."");
            }
            String cipherMode = parts[1];
            if ( ! CryptoHelper.isAllowedCipherMode(cipherMode) ) {
                String msg = ""Cipher mode "" + cipherMode + "" is not an allowed cipher mode"";
                throw new EncryptionException(msg, msg);
            }
            short keySize = readShort(bais);
            debug(""convertToCipherText: keySize = "" + keySize);
            short blockSize = readShort(bais);
            debug(""convertToCipherText: blockSize = "" + blockSize);
            short ivLen = readShort(bais);
            debug(""convertToCipherText: ivLen = "" + ivLen);
            byte[] iv = null;
            if ( ivLen > 0 ) {
                iv = new byte[ivLen];
                bais.read(iv, 0, iv.length);
            }
            int ciphertextLen = readInt(bais);
            debug(""convertToCipherText: ciphertextLen = "" + ciphertextLen);
            if ( ciphertextLen <= 0 ) {
                throw new IllegalArgumentException(""convertToCipherText: Invalid cipher text length; must be > 0."");
            }
            byte[] rawCiphertext = new byte[ciphertextLen];
            bais.read(rawCiphertext, 0, rawCiphertext.length);
            short macLen = readShort(bais);
            debug(""convertToCipherText: macLen = "" + macLen);
            byte[] mac = null;
            if ( macLen > 0 ) {
                mac = new byte[macLen];
                bais.read(mac, 0, mac.length);
            }

            CipherSpec cipherSpec = new CipherSpec(cipherXform, keySize);
            cipherSpec.setBlockSize(blockSize);
            cipherSpec.setIV(iv);
            debug(""convertToCipherText: CipherSpec: "" + cipherSpec);
            CipherText ct = new CipherText(cipherSpec);
            if ( ! (ivLen > 0 && ct.requiresIV()) ) {
                    throw new EncryptionException(""convertToCipherText: Mismatch between IV length and cipher mode."",
                                                  ""Possible tampering of serialized ciphertext?"");
            }
            ct.setCiphertext(rawCiphertext);
              // Set this *AFTER* setting raw ciphertext because setCiphertext()
              // method also sets encryption time.
            ct.setEncryptionTimestamp(timestamp);
            if ( macLen > 0 ) {
                ct.storeSeparateMAC(mac);
            }
                // Fixed in ESAPI crypto version 20130839. Previously is didn't really matter
                // because there was only one version (20110203) and it defaulted to that
                // version, which was the current version. But we don't want that as now there
                // are two versions and we could be decrypting data encrypted using the previous
                // version.
            ct.setKDF_PRF(kdfPrf);
            ct.setKDFVersion(kdfVers);
            return ct;
        } catch(EncryptionException ex) {
            throw new EncryptionException(""Cannot deserialize byte array into CipherText object"",
                                          ""Cannot deserialize byte array into CipherText object"",
                                          ex);
        } catch (IOException e) {
            throw new EncryptionException(""Cannot deserialize byte array into CipherText object"",
                    ""Cannot deserialize byte array into CipherText object"", e);
        }
    }

    /** Check to see if we can support the KSF version that was extracted from
     *  the serialized ciphertext. In particular, we assume that if we have a
     *  newer version of KDF than we can support it as we assume that we have
     *  built in backward compatibility.
     *  
     *  At this point (ESAPI 2.1.0, KDF version 20130830), all we need to check
     *  if the version is either the current version or the previous version as
     *  both versions work the same. This checking may get more complicated in
     *  the future.
     *  
     *  @param readKdfVers    The version information extracted from the serialized
     *                      ciphertext.
     */
    private static boolean versionIsCompatible(int readKdfVers) {
        if ( readKdfVers <= 0 ) {
            throw new IllegalArgumentException(""Extracted KDF version is <= 0. Must be integer >= 1."");
        }
        
        switch ( readKdfVers ) {
        case KeyDerivationFunction.originalVersion:        // First version
            return true;
        // Add new versions here; hard coding is OK...
        // case YYYYMMDD:
        //    return true;
        case KeyDerivationFunction.kdfVersion:            // Current version
            return true;
        default:
            return false;
        }
    }

    private void debug(String msg) {
        if ( logger.isDebugEnabled() ) {
            logger.debug(Logger.EVENT_SUCCESS, msg);
        }
    }
}
"
"src/main/java/org/owasp/esapi/crypto/CipherTextSerializer.java:[43,43]:cipherTextSerializerVersion","    public  static final  int cipherTextSerializerVersion = 20130830; // Current version. Format: YYYYMMDD, max is 99991231.
"
"src/main/java/org/owasp/esapi/crypto/CipherTextSerializer.java:[307,421]:convertToCipherText","    private CipherText convertToCipherText(byte[] cipherTextSerializedBytes)
        throws EncryptionException
    {
        try {
            if ( cipherTextSerializedBytes == null ) {
                throw new IllegalArgumentException(""cipherTextSerializedBytes cannot be null."");
            }
            if ( cipherTextSerializedBytes.length == 0 ) {
                throw new IllegalArgumentException(""cipherTextSerializedBytes must be > 0 in length."");
            }
            ByteArrayInputStream bais = new ByteArrayInputStream(cipherTextSerializedBytes);
            int kdfInfo = readInt(bais);
            debug(""kdfInfo: "" + kdfInfo);
            int kdfPrf = (kdfInfo >>> 28);
            debug(""kdfPrf: "" + kdfPrf);
            if ( kdfPrf < 0 || kdfPrf > 16 ) {
                throw new IllegalArgumentException(""Program error? convertToCipherText: kdPrf is "" + kdfPrf +
                                                   "". Must be between 0 and 15 inclusive"");
            }
            int kdfVers = ( kdfInfo & 0x07ffffff);

            // First do a quick sanity check on the argument. Previously this was an assertion.
            if ( ! CryptoHelper.isValidKDFVersion(kdfVers, false, false) ) {
                // TODO: Clean up. Use StringBuilder. Good enough for now.
                String logMsg = ""KDF version read from serialized ciphertext ("" + kdfVers + "") is out of range. "" +
                                ""Valid range for KDF version is ["" + KeyDerivationFunction.originalVersion + "", "" +
                                ""99991231]."";
                // This should never happen under actual circumstances (barring programming errors; but we've
                // tested the code, right?), so it is likely an attempted attack. Thus don't get the originator
                // of the suspect ciphertext too much info. They ought to know what they sent anyhow.
                throw new EncryptionException(""Version info from serialized ciphertext not in valid range."",
                             ""Likely tampering with KDF version on serialized ciphertext."" + logMsg);
            }
            
            debug(""convertToCipherText: kdfPrf = "" + kdfPrf + "", kdfVers = "" + kdfVers);
            if ( ! versionIsCompatible( kdfVers) ) {
                throw new EncryptionException(""This version of ESAPI is not compatible with the version of ESAPI that encrypted your data."",
                        ""KDF version "" + kdfVers + "" from serialized ciphertext not compatibile with current KDF version of "" + 
                        KeyDerivationFunction.kdfVersion);
            }
            long timestamp = readLong(bais);
            debug(""convertToCipherText: timestamp = "" + new Date(timestamp));
            short strSize = readShort(bais);
            debug(""convertToCipherText: length of cipherXform = "" + strSize);
            String cipherXform = readString(bais, strSize);
            debug(""convertToCipherText: cipherXform = "" + cipherXform);
            String[] parts = cipherXform.split(""/"");
            if ( parts.length != 3 ) {
                throw new IllegalArgumentException(""Program error? Malformed cipher transformation. Expecting 3 parts to cipher transformation, "" +
                                                   ""alg/mode/padding, but found "" + parts.length + "" parts ("" + cipherXform + "")."");
            }
            String cipherMode = parts[1];
            if ( ! CryptoHelper.isAllowedCipherMode(cipherMode) ) {
                String msg = ""Cipher mode "" + cipherMode + "" is not an allowed cipher mode"";
                throw new EncryptionException(msg, msg);
            }
            short keySize = readShort(bais);
            debug(""convertToCipherText: keySize = "" + keySize);
            short blockSize = readShort(bais);
            debug(""convertToCipherText: blockSize = "" + blockSize);
            short ivLen = readShort(bais);
            debug(""convertToCipherText: ivLen = "" + ivLen);
            byte[] iv = null;
            if ( ivLen > 0 ) {
                iv = new byte[ivLen];
                bais.read(iv, 0, iv.length);
            }
            int ciphertextLen = readInt(bais);
            debug(""convertToCipherText: ciphertextLen = "" + ciphertextLen);
            if ( ciphertextLen <= 0 ) {
                throw new IllegalArgumentException(""convertToCipherText: Invalid cipher text length; must be > 0."");
            }
            byte[] rawCiphertext = new byte[ciphertextLen];
            bais.read(rawCiphertext, 0, rawCiphertext.length);
            short macLen = readShort(bais);
            debug(""convertToCipherText: macLen = "" + macLen);
            byte[] mac = null;
            if ( macLen > 0 ) {
                mac = new byte[macLen];
                bais.read(mac, 0, mac.length);
            }

            CipherSpec cipherSpec = new CipherSpec(cipherXform, keySize);
            cipherSpec.setBlockSize(blockSize);
            cipherSpec.setIV(iv);
            debug(""convertToCipherText: CipherSpec: "" + cipherSpec);
            CipherText ct = new CipherText(cipherSpec);
            if ( ! (ivLen > 0 && ct.requiresIV()) ) {
                    throw new EncryptionException(""convertToCipherText: Mismatch between IV length and cipher mode."",
                                                  ""Possible tampering of serialized ciphertext?"");
            }
            ct.setCiphertext(rawCiphertext);
              // Set this *AFTER* setting raw ciphertext because setCiphertext()
              // method also sets encryption time.
            ct.setEncryptionTimestamp(timestamp);
            if ( macLen > 0 ) {
                ct.storeSeparateMAC(mac);
            }
                // Fixed in ESAPI crypto version 20130839. Previously is didn't really matter
                // because there was only one version (20110203) and it defaulted to that
                // version, which was the current version. But we don't want that as now there
                // are two versions and we could be decrypting data encrypted using the previous
                // version.
            ct.setKDF_PRF(kdfPrf);
            ct.setKDFVersion(kdfVers);
            return ct;
        } catch(EncryptionException ex) {
            throw new EncryptionException(""Cannot deserialize byte array into CipherText object"",
                                          ""Cannot deserialize byte array into CipherText object"",
                                          ex);
        } catch (IOException e) {
            throw new EncryptionException(""Cannot deserialize byte array into CipherText object"",
                    ""Cannot deserialize byte array into CipherText object"", e);
        }
    }
"
