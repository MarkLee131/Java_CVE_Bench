Fix_Path,Fix_Src
"src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedCreatorCollector.java:[34,39]:AnnotatedCreatorCollector","    AnnotatedCreatorCollector(AnnotationIntrospector intr,
            TypeResolutionContext tc)
    {
        super(intr);
        _typeContext = tc;
    }
"
"src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedCreatorCollector.java:[249,304]:constructNonDefaultConstructor","    protected AnnotatedConstructor constructNonDefaultConstructor(ClassUtil.Ctor ctor,
            ClassUtil.Ctor mixin)
    {
        final int paramCount = ctor.getParamCount();
        if (_intr == null) { // when annotation processing is disabled
            return new AnnotatedConstructor(_typeContext, ctor.getConstructor(),
                    _emptyAnnotationMap(), _emptyAnnotationMaps(paramCount));
        }

        /* Looks like JDK has discrepancy, whereas annotations for implicit 'this'
         * (for non-static inner classes) are NOT included, but type is?
         * Strange, sounds like a bug. Alas, we can't really fix that...
         */
        if (paramCount == 0) { // no-arg default constructors, can simplify slightly
            return new AnnotatedConstructor(_typeContext, ctor.getConstructor(),
                    collectAnnotations(ctor, mixin),
                    NO_ANNOTATION_MAPS);
        }
        // Also: enum value constructors
        AnnotationMap[] resolvedAnnotations;
        Annotation[][] paramAnns = ctor.getParameterAnnotations();
        if (paramCount != paramAnns.length) {
            // Limits of the work-around (to avoid hiding real errors):
            // first, only applicable for member classes and then either:

            resolvedAnnotations = null;
            Class<?> dc = ctor.getDeclaringClass();
            // (a) is enum, which have two extra hidden params (name, index)
            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {
                Annotation[][] old = paramAnns;
                paramAnns = new Annotation[old.length+2][];
                System.arraycopy(old, 0, paramAnns, 2, old.length);
                resolvedAnnotations = collectAnnotations(paramAnns, null);
            } else if (dc.isMemberClass()) {
                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation
                if (paramCount == (paramAnns.length + 1)) {
                    // hack attack: prepend a null entry to make things match
                    Annotation[][] old = paramAnns;
                    paramAnns = new Annotation[old.length+1][];
                    System.arraycopy(old, 0, paramAnns, 1, old.length);
                    paramAnns[0] = NO_ANNOTATIONS;
                    resolvedAnnotations = collectAnnotations(paramAnns, null);
                }
            }
            if (resolvedAnnotations == null) {
                throw new IllegalStateException(String.format(
""Internal error: constructor for %s has mismatch: %d parameters; %d sets of annotations"",
ctor.getDeclaringClass().getName(), paramCount, paramAnns.length));
            }
        } else {
            resolvedAnnotations = collectAnnotations(paramAnns,
                    (mixin == null) ? null : mixin.getParameterAnnotations());
        }
        return new AnnotatedConstructor(_typeContext, ctor.getConstructor(),
                collectAnnotations(ctor, mixin), resolvedAnnotations);
    }
"
"src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java:[47,58]:EnumSetDeserializer","    public EnumSetDeserializer(JavaType enumType, JsonDeserializer<?> deser)
    {
        super(EnumSet.class);
        _enumType = enumType;
        _enumClass = (Class<Enum>) enumType.getRawClass();
        // sanity check
        if (!_enumClass.isEnum()) {
            throw new IllegalArgumentException(""Type ""+enumType+"" not Java Enum type"");
        }
        _enumDeserializer = (JsonDeserializer<Enum<?>>) deser;
        _unwrapSingle = null;
    }
"
"src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java:[20,184]:SubTypeValidator","public class SubTypeValidator
{
    protected final static String PREFIX_SPRING = ""org.springframework."";

    protected final static String PREFIX_C3P0 = ""com.mchange.v2.c3p0."";

    /**
     * Set of well-known ""nasty classes"", deserialization of which is considered dangerous
     * and should (and is) prevented by default.
     */
    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;
    static {
        Set<String> s = new HashSet<String>();
        // Courtesy of [https://github.com/kantega/notsoserial]:
        // (and wrt [databind#1599])
        s.add(""org.apache.commons.collections.functors.InvokerTransformer"");
        s.add(""org.apache.commons.collections.functors.InstantiateTransformer"");
        s.add(""org.apache.commons.collections4.functors.InvokerTransformer"");
        s.add(""org.apache.commons.collections4.functors.InstantiateTransformer"");
        s.add(""org.codehaus.groovy.runtime.ConvertedClosure"");
        s.add(""org.codehaus.groovy.runtime.MethodClosure"");
        s.add(""org.springframework.beans.factory.ObjectFactory"");
        s.add(""com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"");
        s.add(""org.apache.xalan.xsltc.trax.TemplatesImpl"");
        // [databind#1680]: may or may not be problem, take no chance
        s.add(""com.sun.rowset.JdbcRowSetImpl"");
        // [databind#1737]; JDK provided
        s.add(""java.util.logging.FileHandler"");
        s.add(""java.rmi.server.UnicastRemoteObject"");
        // [databind#1737]; 3rd party
//s.add(""org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor""); // deprecated by [databind#1855]
        s.add(""org.springframework.beans.factory.config.PropertyPathFactoryBean"");

// s.add(""com.mchange.v2.c3p0.JndiRefForwardingDataSource""); // deprecated by [databind#1931]
// s.add(""com.mchange.v2.c3p0.WrapperConnectionPoolDataSource""); // - """" -
        // [databind#1855]: more 3rd party
        s.add(""org.apache.tomcat.dbcp.dbcp2.BasicDataSource"");
        s.add(""com.sun.org.apache.bcel.internal.util.ClassLoader"");
        // [databind#1899]: more 3rd party
        s.add(""org.hibernate.jmx.StatisticsService"");
        s.add(""org.apache.ibatis.datasource.jndi.JndiDataSourceFactory"");
        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities
        s.add(""org.apache.ibatis.parsing.XPathParser"");

        // [databind#2052]: Jodd-db, with jndi/ldap lookup
        s.add(""jodd.db.connection.DataSourceConnectionProvider"");

        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup
        s.add(""oracle.jdbc.connector.OracleManagedConnectionFactory"");
        s.add(""oracle.jdbc.rowset.OracleJDBCRowSet"");

        // [databind#2097]: some 3rd party, one JDK-bundled
        s.add(""org.slf4j.ext.EventData"");
        s.add(""flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor"");
        s.add(""com.sun.deploy.security.ruleset.DRSHelper"");
        s.add(""org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl"");

        // [databind#2186]: yet more 3rd party gadgets
        s.add(""org.jboss.util.propertyeditor.DocumentEditor"");
        s.add(""org.apache.openjpa.ee.RegistryManagedRuntime"");
        s.add(""org.apache.openjpa.ee.JNDIManagedRuntime"");
        s.add(""org.apache.axis2.transport.jms.JMSOutTransportInfo"");

        // [databind#2326] (2.9.9)
        s.add(""com.mysql.cj.jdbc.admin.MiniAdmin"");

        // [databind#2334]: logback-core (2.9.9.1)
        s.add(""ch.qos.logback.core.db.DriverManagerConnectionSource"");

        // [databind#2341]: jdom/jdom2 (2.9.9.1)
        s.add(""org.jdom.transform.XSLTransformer"");
        s.add(""org.jdom2.transform.XSLTransformer"");

        // [databind#2387], [databind#2460]: EHCache
        s.add(""net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup"");
        s.add(""net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup"");

        // [databind#2389]: logback/jndi
        s.add(""ch.qos.logback.core.db.JNDIConnectionSource"");

        // [databind#2410]: HikariCP/metricRegistry config
        s.add(""com.zaxxer.hikari.HikariConfig"");
        // [databind#2449]: and sub-class thereof
        s.add(""com.zaxxer.hikari.HikariDataSource"");

        // [databind#2420]: CXF/JAX-RS provider/XSLT
        s.add(""org.apache.cxf.jaxrs.provider.XSLTJaxbProvider"");

        // [databind#2462]: commons-configuration / -2
        s.add(""org.apache.commons.configuration.JNDIConfiguration"");
        s.add(""org.apache.commons.configuration2.JNDIConfiguration"");

        // [databind#2469]: xalan2
        s.add(""org.apache.xalan.lib.sql.JNDIConnectionPool"");

        // [databind#2478]: comons-dbcp, p6spy
        s.add(""org.apache.commons.dbcp.datasources.PerUserPoolDataSource"");
        s.add(""org.apache.commons.dbcp.datasources.SharedPoolDataSource"");
        s.add(""com.p6spy.engine.spy.P6DataSource"");

        // [databind#2498]: log4j-extras (1.2)
        s.add(""org.apache.log4j.receivers.db.DriverManagerConnectionSource"");
        s.add(""org.apache.log4j.receivers.db.JNDIConnectionSource"");

        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);
    }

    /**
     * Set of class names of types that are never to be deserialized.
     */
    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;

    private final static SubTypeValidator instance = new SubTypeValidator();

    protected SubTypeValidator() { }

    public static SubTypeValidator instance() { return instance; }

    public void validateSubType(DeserializationContext ctxt, JavaType type,
            BeanDescription beanDesc) throws JsonMappingException
    {
        // There are certain nasty classes that could cause problems, mostly
        // via default typing -- catch them here.
        final Class<?> raw = type.getRawClass();
        String full = raw.getName();

        main_check:
        do {
            if (_cfgIllegalClassNames.contains(full)) {
                break;
            }

            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling
            //    for some Spring framework types
            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces
            if (raw.isInterface()) {
                ;
            } else if (full.startsWith(PREFIX_SPRING)) {
                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){
                    String name = cls.getSimpleName();
                    // looking for ""AbstractBeanFactoryPointcutAdvisor"" but no point to allow any is there?
                    if (""AbstractPointcutAdvisor"".equals(name)
                            // ditto  for ""FileSystemXmlApplicationContext"": block all ApplicationContexts
                            || ""AbstractApplicationContext"".equals(name)) {
                        break main_check;
                    }
                }
            } else if (full.startsWith(PREFIX_C3P0)) {
                // [databind#1737]; more 3rd party
                // s.add(""com.mchange.v2.c3p0.JndiRefForwardingDataSource"");
                // s.add(""com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"");
                // [databind#1931]; more 3rd party
                // com.mchange.v2.c3p0.ComboPooledDataSource
                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource 
                if (full.endsWith(""DataSource"")) {
                    break main_check;
                }
            }
            return;
        } while (false);

        ctxt.reportBadTypeDefinition(beanDesc,
                ""Illegal type (%s) to deserialize: prevented for security reasons"", full);
    }
}
"
"src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java:[147,151]:BeanSerializerBase","    protected BeanSerializerBase(BeanSerializerBase src,
            ObjectIdWriter objectIdWriter)
    {
        this(src, objectIdWriter, src._propertyFilterId);
    }
"
"src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java:[409,557]:createContextual","    public JsonSerializer<?> createContextual(SerializerProvider provider,
            BeanProperty property)
        throws JsonMappingException
    {
        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();
        final AnnotatedMember accessor = (property == null || intr == null)
                ? null : property.getMember();
        final SerializationConfig config = provider.getConfig();
        
        // Let's start with one big transmutation: Enums that are annotated
        // to serialize as Objects may want to revert
        JsonFormat.Value format = findFormatOverrides(provider, property, handledType());
        JsonFormat.Shape shape = null;
        if ((format != null) && format.hasShape()) {
            shape = format.getShape();
            // or, alternatively, asked to revert ""back to"" other representations...
            if ((shape != JsonFormat.Shape.ANY) && (shape != _serializationShape)) {
                if (_handledType.isEnum()) {
                    switch (shape) {
                    case STRING:
                    case NUMBER:
                    case NUMBER_INT:
                        // 12-Oct-2014, tatu: May need to introspect full annotations... but
                        //   for now, just do class ones
                        BeanDescription desc = config.introspectClassAnnotations(_beanType);
                        JsonSerializer<?> ser = EnumSerializer.construct(_beanType.getRawClass(),
                                provider.getConfig(), desc, format);
                        return provider.handlePrimaryContextualization(ser, property);
                    }
                // 16-Oct-2016, tatu: Ditto for `Map`, `Map.Entry` subtypes
                } else if (shape == JsonFormat.Shape.NATURAL) {
                    if (_beanType.isMapLikeType() && Map.class.isAssignableFrom(_handledType)) {
                        ;
                    } else if (Map.Entry.class.isAssignableFrom(_handledType)) {
                        JavaType mapEntryType = _beanType.findSuperType(Map.Entry.class);

                        JavaType kt = mapEntryType.containedTypeOrUnknown(0);
                        JavaType vt = mapEntryType.containedTypeOrUnknown(1);

                        // 16-Oct-2016, tatu: could have problems with type handling, as we do not
                        //   see if ""static"" typing is needed, nor look for `TypeSerializer` yet...
                        JsonSerializer<?> ser = new MapEntrySerializer(_beanType, kt, vt,
                                false, null, property);
                        return provider.handlePrimaryContextualization(ser, property);
                    }
                }
            }
        }

        ObjectIdWriter oiw = _objectIdWriter;
        Set<String> ignoredProps = null;
        Object newFilterId = null;

        // Then we may have an override for Object Id
        if (accessor != null) {
            JsonIgnoreProperties.Value ignorals = intr.findPropertyIgnorals(accessor);
            if (ignorals != null) {
                ignoredProps = ignorals.findIgnoredForSerialization();
            }
            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);
            if (objectIdInfo == null) {
                // no ObjectId override, but maybe ObjectIdRef?
                if (oiw != null) {
                    objectIdInfo = intr.findObjectReferenceInfo(accessor, null);
                    if (objectIdInfo != null) {
                        oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());
                    }
                }
            } else {
                // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it
                // to be able to move to SerializerProvider (where it really belongs)
                
                // 2.1: allow modifications by ""id ref"" annotations as well:
                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);
                ObjectIdGenerator<?> gen;
                Class<?> implClass = objectIdInfo.getGeneratorType();
                JavaType type = provider.constructType(implClass);
                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];
                // Property-based generator is trickier
                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work
                    String propName = objectIdInfo.getPropertyName().getSimpleName();
                    BeanPropertyWriter idProp = null;

                    for (int i = 0, len = _props.length; ; ++i) {
                        if (i == len) {
                            provider.reportBadDefinition(_beanType, String.format(
                                    ""Invalid Object Id definition for %s: cannot find property with name '%s'"",
                                    handledType().getName(), propName));
                        }
                        BeanPropertyWriter prop = _props[i];
                        if (propName.equals(prop.getName())) {
                            idProp = prop;
                            // Let's force it to be the first property to output
                            // (although it may still get rearranged etc)
                            if (i > 0) { // note: must shuffle both regular properties and filtered
                                System.arraycopy(_props, 0, _props, 1, i);
                                _props[0] = idProp;
                                if (_filteredProps != null) {
                                    BeanPropertyWriter fp = _filteredProps[i];
                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);
                                    _filteredProps[0] = fp;
                                }
                            }
                            break;
                        }
                    }
                    idType = idProp.getType();
                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);
                    oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());
                } else { // other types need to be simpler
                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);
                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,
                            objectIdInfo.getAlwaysAsId());
                }
            }
            // Or change Filter Id in use?
            Object filterId = intr.findFilterId(accessor);
            if (filterId != null) {
                // but only consider case of adding a new filter id (no removal via annotation)
                if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {
                    newFilterId = filterId;
                }
            }
        }
        // either way, need to resolve serializer:
        BeanSerializerBase contextual = this;
        if (oiw != null) {
            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);
            oiw = oiw.withSerializer(ser);
            if (oiw != _objectIdWriter) {
                contextual = contextual.withObjectIdWriter(oiw);
            }
        }
        // And possibly add more properties to ignore
        if ((ignoredProps != null) && !ignoredProps.isEmpty()) {
            contextual = contextual.withIgnorals(ignoredProps);
        }
        if (newFilterId != null) {
            contextual = contextual.withFilterId(newFilterId);
        }
        if (shape == null) {
            shape = _serializationShape;
        }
        // last but not least; may need to transmute into as-array serialization
        if (shape == JsonFormat.Shape.ARRAY) {
            return contextual.asArraySerializer();
        }
        return contextual;
    }
"
"src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java:[66,115]:_idFrom","    protected String _idFrom(Object value, Class<?> cls, TypeFactory typeFactory)
    {
        // Need to ensure that ""enum subtypes"" work too
        if (Enum.class.isAssignableFrom(cls)) {
            if (!cls.isEnum()) { // means that it's sub-class of base enum, so:
                cls = cls.getSuperclass();
            }
        }
        String str = cls.getName();
        if (str.startsWith(JAVA_UTIL_PKG)) {
            // 25-Jan-2009, tatu: There are some internal classes that we cannot access as is.
            //     We need better mechanism; for now this has to do...

            // Enum sets and maps are problematic since we MUST know type of
            // contained enums, to be able to deserialize.
            // In addition, EnumSet is not a concrete type either
            if (value instanceof EnumSet<?>) { // Regular- and JumboEnumSet...
                Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value);
                // not optimal: but EnumSet is not a customizable type so this is sort of ok
               str = typeFactory.constructCollectionType(EnumSet.class, enumClass).toCanonical();
            } else if (value instanceof EnumMap<?,?>) {
                Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?,?>) value);
                Class<?> valueClass = Object.class;
                // not optimal: but EnumMap is not a customizable type so this is sort of ok
                str = typeFactory.constructMapType(EnumMap.class, enumClass, valueClass).toCanonical();
            }
            // 10-Jan-2018, tatu: Up until 2.9.4 we used to have other conversions for `Collections.xxx()`
            //    and `Arrays.asList(...)`; but it was changed to be handled on receiving end instead
        } else if (str.indexOf('$') >= 0) {
            /* Other special handling may be needed for inner classes,
             * The best way to handle would be to find 'hidden' constructor; pass parent
             * value etc (which is actually done for non-anonymous static classes!),
             * but that is just not possible due to various things. So, we will instead
             * try to generalize type into something we will be more likely to be able
             * construct.
             */
            Class<?> outer = ClassUtil.getOuterClass(cls);
            if (outer != null) {
                // one more check: let's actually not worry if the declared static type is
                // non-static as well; if so, deserializer does have a chance at figuring it all out.
                Class<?> staticType = _baseType.getRawClass();
                if (ClassUtil.getOuterClass(staticType) == null) {
                    // Is this always correct? Seems like it should be...
                    cls = _baseType.getRawClass();
                    str = cls.getName();
                }
            }
        }
        return str;
    }
"
"src/main/java/com/fasterxml/jackson/databind/JavaType.java:[291,291]:isEnumType","    public final boolean isEnumType() { return _class.isEnum(); }
"
"src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java:[20,516]:CreatorCollector","public class CreatorCollector {
    // Since 2.5
    protected final static int C_DEFAULT = 0;
    protected final static int C_STRING = 1;
    protected final static int C_INT = 2;
    protected final static int C_LONG = 3;
    protected final static int C_DOUBLE = 4;
    protected final static int C_BOOLEAN = 5;
    protected final static int C_DELEGATE = 6;
    protected final static int C_PROPS = 7;
    protected final static int C_ARRAY_DELEGATE = 8;

    protected final static String[] TYPE_DESCS = new String[] { ""default"",
            ""from-String"", ""from-int"", ""from-long"", ""from-double"",
            ""from-boolean"", ""delegate"", ""property-based"" };

    /// Type of bean being created
    final protected BeanDescription _beanDesc;

    final protected boolean _canFixAccess;

    /**
     * @since 2.7
     */
    final protected boolean _forceAccess;

    /**
     * Set of creators we have collected so far
     * 
     * @since 2.5
     */
    protected final AnnotatedWithParams[] _creators = new AnnotatedWithParams[9];

    /**
     * Bitmask of creators that were explicitly marked as creators; false for
     * auto-detected (ones included base on naming and/or visibility, not
     * annotation)
     * 
     * @since 2.5
     */
    protected int _explicitCreators = 0;

    protected boolean _hasNonDefaultCreator = false;

    // when there are injectable values along with delegate:
    protected SettableBeanProperty[] _delegateArgs;

    protected SettableBeanProperty[] _arrayDelegateArgs;

    protected SettableBeanProperty[] _propertyBasedArgs;

    /*
    /**********************************************************
    /* Life-cycle
    /**********************************************************
     */

    public CreatorCollector(BeanDescription beanDesc, MapperConfig<?> config) {
        _beanDesc = beanDesc;
        _canFixAccess = config.canOverrideAccessModifiers();
        _forceAccess = config
                .isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);
    }

    public ValueInstantiator constructValueInstantiator(DeserializationContext ctxt)
        throws JsonMappingException
    {
        final DeserializationConfig config = ctxt.getConfig();
        final JavaType delegateType = _computeDelegateType(ctxt,
                _creators[C_DELEGATE], _delegateArgs);
        final JavaType arrayDelegateType = _computeDelegateType(ctxt,
                _creators[C_ARRAY_DELEGATE], _arrayDelegateArgs);
        final JavaType type = _beanDesc.getType();

        // 11-Jul-2016, tatu: Earlier optimization by replacing the whole
        // instantiator did not
        // work well, so let's replace by lower-level check:
        AnnotatedWithParams defaultCtor = StdTypeConstructor
                .tryToOptimize(_creators[C_DEFAULT]);

        StdValueInstantiator inst = new StdValueInstantiator(config, type);
        inst.configureFromObjectSettings(defaultCtor, _creators[C_DELEGATE],
                delegateType, _delegateArgs, _creators[C_PROPS],
                _propertyBasedArgs);
        inst.configureFromArraySettings(_creators[C_ARRAY_DELEGATE],
                arrayDelegateType, _arrayDelegateArgs);
        inst.configureFromStringCreator(_creators[C_STRING]);
        inst.configureFromIntCreator(_creators[C_INT]);
        inst.configureFromLongCreator(_creators[C_LONG]);
        inst.configureFromDoubleCreator(_creators[C_DOUBLE]);
        inst.configureFromBooleanCreator(_creators[C_BOOLEAN]);
        return inst;
    }

    /*
    /**********************************************************
    /* Setters
    /**********************************************************
     */

    /**
     * Method called to indicate the default creator: no-arguments constructor
     * or factory method that is called to instantiate a value before populating
     * it with data. Default creator is only used if no other creators are
     * indicated.
     * 
     * @param creator
     *            Creator method; no-arguments constructor or static factory
     *            method.
     */
    public void setDefaultCreator(AnnotatedWithParams creator) {
        _creators[C_DEFAULT] = _fixAccess(creator);
    }

    public void addStringCreator(AnnotatedWithParams creator, boolean explicit) {
        verifyNonDup(creator, C_STRING, explicit);
    }

    public void addIntCreator(AnnotatedWithParams creator, boolean explicit) {
        verifyNonDup(creator, C_INT, explicit);
    }

    public void addLongCreator(AnnotatedWithParams creator, boolean explicit) {
        verifyNonDup(creator, C_LONG, explicit);
    }

    public void addDoubleCreator(AnnotatedWithParams creator, boolean explicit) {
        verifyNonDup(creator, C_DOUBLE, explicit);
    }

    public void addBooleanCreator(AnnotatedWithParams creator, boolean explicit) {
        verifyNonDup(creator, C_BOOLEAN, explicit);
    }

    public void addDelegatingCreator(AnnotatedWithParams creator,
            boolean explicit, SettableBeanProperty[] injectables,
            int delegateeIndex)
    {
        if (creator.getParameterType(delegateeIndex).isCollectionLikeType()) {
            if (verifyNonDup(creator, C_ARRAY_DELEGATE, explicit)) {
                _arrayDelegateArgs = injectables;
            }
        } else {
            if (verifyNonDup(creator, C_DELEGATE, explicit)) {
                _delegateArgs = injectables;
            }
        }
    }

    public void addPropertyCreator(AnnotatedWithParams creator,
            boolean explicit, SettableBeanProperty[] properties)
    {
        if (verifyNonDup(creator, C_PROPS, explicit)) {
            // Better ensure we have no duplicate names either...
            if (properties.length > 1) {
                HashMap<String, Integer> names = new HashMap<String, Integer>();
                for (int i = 0, len = properties.length; i < len; ++i) {
                    String name = properties[i].getName();
                    // Need to consider Injectables, which may not have
                    // a name at all, and need to be skipped
                    if (name.isEmpty() && (properties[i].getInjectableValueId() != null)) {
                        continue;
                    }
                    Integer old = names.put(name, Integer.valueOf(i));
                    if (old != null) {
                        throw new IllegalArgumentException(String.format(
                                ""Duplicate creator property \""%s\"" (index %s vs %d) for type %s "",
                                name, old, i, ClassUtil.nameOf(_beanDesc.getBeanClass())));
                    }
                }
            }
            _propertyBasedArgs = properties;
        }
    }

    /*
    /**********************************************************
    /* Accessors
    /**********************************************************
     */

    /**
     * @since 2.1
     */
    public boolean hasDefaultCreator() {
        return _creators[C_DEFAULT] != null;
    }

    /**
     * @since 2.6
     */
    public boolean hasDelegatingCreator() {
        return _creators[C_DELEGATE] != null;
    }

    /**
     * @since 2.6
     */
    public boolean hasPropertyBasedCreator() {
        return _creators[C_PROPS] != null;
    }

    /*
    /**********************************************************
    /* Helper methods
    /**********************************************************
     */

    private JavaType _computeDelegateType(DeserializationContext ctxt,
            AnnotatedWithParams creator, SettableBeanProperty[] delegateArgs)
        throws JsonMappingException
    {
        if (!_hasNonDefaultCreator || (creator == null)) {
            return null;
        }
        // need to find type...
        int ix = 0;
        if (delegateArgs != null) {
            for (int i = 0, len = delegateArgs.length; i < len; ++i) {
                if (delegateArgs[i] == null) { // marker for delegate itself
                    ix = i;
                    break;
                }
            }
        }
        final DeserializationConfig config = ctxt.getConfig();

        // 03-May-2018, tatu: need to check possible annotation-based
        //   custom deserializer [databind#2012],
        //   type refinement(s) [databind#2016]. 
        JavaType baseType = creator.getParameterType(ix);
        AnnotationIntrospector intr = config.getAnnotationIntrospector();
        if (intr != null) {
            AnnotatedParameter delegate = creator.getParameter(ix);
            
            // First: custom deserializer(s):
            Object deserDef = intr.findDeserializer(delegate);
            if (deserDef != null) {
                JsonDeserializer<Object> deser = ctxt.deserializerInstance(delegate, deserDef);
                baseType = baseType.withValueHandler(deser);
            } else {
                // Second: type refinement(s), if no explicit deserializer was located
                baseType = intr.refineDeserializationType(config,
                        delegate, baseType);
            }
        }
        return baseType;
    }

    private <T extends AnnotatedMember> T _fixAccess(T member) {
        if (member != null && _canFixAccess) {
            ClassUtil.checkAndFixAccess((Member) member.getAnnotated(),
                    _forceAccess);
        }
        return member;
    }

    /**
     * @return True if specified Creator is to be used
     */
    protected boolean verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)
    {
        final int mask = (1 << typeIndex);
        _hasNonDefaultCreator = true;
        AnnotatedWithParams oldOne = _creators[typeIndex];
        // already had an explicitly marked one?
        if (oldOne != null) {
            boolean verify;
            if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is
                // but skip, if new one not annotated
                if (!explicit) {
                    return false;
                }
                // both explicit: verify
                verify = true;
            } else {
                // otherwise only verify if neither explicitly annotated.
                verify = !explicit;
            }

            // one more thing: ok to override in sub-class
            if (verify && (oldOne.getClass() == newOne.getClass())) {
                // [databind#667]: avoid one particular class of bogus problems
                Class<?> oldType = oldOne.getRawParameterType(0);
                Class<?> newType = newOne.getRawParameterType(0);

                if (oldType == newType) {
                    // 13-Jul-2016, tatu: One more thing to check; since Enum
                    // classes always have
                    // implicitly created `valueOf()`, let's resolve in favor of
                    // other implicit
                    // creator (`fromString()`)
                    if (_isEnumValueOf(newOne)) {
                        return false; // ignore
                    }
                    if (_isEnumValueOf(oldOne)) {
                        ;
                    } else {
                        throw new IllegalArgumentException(String.format(
                                ""Conflicting %s creators: already had %s creator %s, encountered another: %s"",
                                TYPE_DESCS[typeIndex],
                                explicit ? ""explicitly marked""
                                        : ""implicitly discovered"",
                                oldOne, newOne));
                    }
                }
                // otherwise, which one to choose?
                else if (newType.isAssignableFrom(oldType)) {
                    // new type more generic, use old
                    return false;
                }
                // new type more specific, use it
            }
        }
        if (explicit) {
            _explicitCreators |= mask;
        }
        _creators[typeIndex] = _fixAccess(newOne);
        return true;
    }

    /**
     * Helper method for recognizing `Enum.valueOf()` factory method
     *
     * @since 2.8.1
     */
    protected boolean _isEnumValueOf(AnnotatedWithParams creator) {
        return creator.getDeclaringClass().isEnum()
                && ""valueOf"".equals(creator.getName());
    }

    /*
    /**********************************************************
    /* Helper class(es)
    /**********************************************************
     */

    /**
     * Replacement for default constructor to use for a small set of
     * ""well-known"" types.
     * <p>
     * Note: replaces earlier <code>Vanilla</code>
     * <code>ValueInstantiator</code> implementation
     *
     * @since 2.8.1 (replacing earlier <code>Vanilla</code> instantiator
     */
    protected final static class StdTypeConstructor extends AnnotatedWithParams
            implements java.io.Serializable {
        private static final long serialVersionUID = 1L;

        public final static int TYPE_ARRAY_LIST = 1;
        public final static int TYPE_HASH_MAP = 2;
        public final static int TYPE_LINKED_HASH_MAP = 3;

        private final AnnotatedWithParams _base;

        private final int _type;

        public StdTypeConstructor(AnnotatedWithParams base, int t) {
            super(base, null);
            _base = base;
            _type = t;
        }

        public static AnnotatedWithParams tryToOptimize(
                AnnotatedWithParams src) {
            if (src != null) {
                final Class<?> rawType = src.getDeclaringClass();
                if (rawType == List.class || rawType == ArrayList.class) {
                    return new StdTypeConstructor(src, TYPE_ARRAY_LIST);
                }
                if (rawType == LinkedHashMap.class) {
                    return new StdTypeConstructor(src, TYPE_LINKED_HASH_MAP);
                }
                if (rawType == HashMap.class) {
                    return new StdTypeConstructor(src, TYPE_HASH_MAP);
                }
            }
            return src;
        }

        protected final Object _construct() {
            switch (_type) {
            case TYPE_ARRAY_LIST:
                return new ArrayList<Object>();
            case TYPE_LINKED_HASH_MAP:
                return new LinkedHashMap<String, Object>();
            case TYPE_HASH_MAP:
                return new HashMap<String, Object>();
            }
            throw new IllegalStateException(""Unknown type "" + _type);
        }

        @Override
        public int getParameterCount() {
            return _base.getParameterCount();
        }

        @Override
        public Class<?> getRawParameterType(int index) {
            return _base.getRawParameterType(index);
        }

        @Override
        public JavaType getParameterType(int index) {
            return _base.getParameterType(index);
        }

        @Override
        @Deprecated
        public Type getGenericParameterType(int index) {
            return _base.getGenericParameterType(index);
        }

        @Override
        public Object call() throws Exception {
            return _construct();
        }

        @Override
        public Object call(Object[] args) throws Exception {
            return _construct();
        }

        @Override
        public Object call1(Object arg) throws Exception {
            return _construct();
        }

        @Override
        public Class<?> getDeclaringClass() {
            return _base.getDeclaringClass();
        }

        @Override
        public Member getMember() {
            return _base.getMember();
        }

        @Override
        public void setValue(Object pojo, Object value)
                throws UnsupportedOperationException, IllegalArgumentException {
            throw new UnsupportedOperationException();
        }

        @Override
        public Object getValue(Object pojo)
                throws UnsupportedOperationException, IllegalArgumentException {
            throw new UnsupportedOperationException();
        }

        @Override
        public Annotated withAnnotations(AnnotationMap fallback) {
            throw new UnsupportedOperationException();
        }

        @Override
        public AnnotatedElement getAnnotated() {
            return _base.getAnnotated();
        }

        @Override
        protected int getModifiers() {
            return _base.getMember().getModifiers();
        }

        @Override
        public String getName() {
            return _base.getName();
        }

        @Override
        public JavaType getType() {
            return _base.getType();
        }

        @Override
        public Class<?> getRawType() {
            return _base.getRawType();
        }

        @Override
        public boolean equals(Object o) {
            return (o == this);
        }

        @Override
        public int hashCode() {
            return _base.hashCode();
        }

        @Override
        public String toString() {
            return _base.toString();
        }
    }
}
"
"src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java:[346,349]:_isEnumValueOf","    protected boolean _isEnumValueOf(AnnotatedWithParams creator) {
        return creator.getDeclaringClass().isEnum()
                && ""valueOf"".equals(creator.getName());
    }
"
"src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java:[60,62]:StdKeyDeserializer","    protected StdKeyDeserializer(int kind, Class<?> cls) {
        this(kind, cls, null);
    }
"
"src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java:[121,141]:deserializeKey","    public Object deserializeKey(String key, DeserializationContext ctxt)
        throws IOException
    {
        if (key == null) { // is this even legal call?
            return null;
        }
        try {
            Object result = _parse(key, ctxt);
            if (result != null) {
                return result;
            }
        } catch (Exception re) {
            return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"",
                    re.getClass().getName(),
                    ClassUtil.exceptionMessage(re));
        }
        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
            return null;
        }
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
    }
"
"src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java:[126,128]:BasicDeserializerFactory","    protected BasicDeserializerFactory(DeserializerFactoryConfig config) {
        _factoryConfig = config;
    }
"
"src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java:[1299,1401]:createMapDeserializer","    public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt,
            MapType type, BeanDescription beanDesc)
        throws JsonMappingException
    {
        final DeserializationConfig config = ctxt.getConfig();
        JavaType keyType = type.getKeyType();
        JavaType contentType = type.getContentType();
        
        // First: is there annotation-specified deserializer for values?
        @SuppressWarnings(""unchecked"")
        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();

        // Ok: need a key deserializer (null indicates 'default' here)
        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();
        // Then optional type info; either attached to type, or resolved separately:
        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();
        // but if not, may still be possible to find:
        if (contentTypeDeser == null) {
            contentTypeDeser = findTypeDeserializer(config, contentType);
        }

        // 23-Nov-2010, tatu: Custom deserializer?
        JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,
                keyDes, contentTypeDeser, contentDeser);

        if (deser == null) {
            // Value handling is identical for all, but EnumMap requires special handling for keys
            Class<?> mapClass = type.getRawClass();
            if (EnumMap.class.isAssignableFrom(mapClass)) {
                ValueInstantiator inst;

                // 06-Mar-2017, tatu: Should only need to check ValueInstantiator for
                //    custom sub-classes, see [databind#1544]
                if (mapClass == EnumMap.class) {
                    inst = null;
                } else {
                    inst = findValueInstantiator(ctxt, beanDesc);
                }
                Class<?> kt = keyType.getRawClass();
                if (kt == null || !kt.isEnum()) {
                    throw new IllegalArgumentException(""Cannot construct EnumMap; generic (key) type not available"");
                }
                deser = new EnumMapDeserializer(type, inst, null,
                        contentDeser, contentTypeDeser, null);
            }

            // Otherwise, generic handler works ok.
    
            /* But there is one more twist: if we are being asked to instantiate
             * an interface or abstract Map, we need to either find something
             * that implements the thing, or give up.
             *
             * Note that we do NOT try to guess based on secondary interfaces
             * here; that would probably not work correctly since casts would
             * fail later on (as the primary type is not the interface we'd
             * be implementing)
             */
            if (deser == null) {
                if (type.isInterface() || type.isAbstract()) {
                    @SuppressWarnings(""rawtypes"")
                    Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());
                    if (fallback != null) {
                        mapClass = fallback;
                        type = (MapType) config.constructSpecializedType(type, mapClass);
                        // But if so, also need to re-check creators...
                        beanDesc = config.introspectForCreation(type);
                    } else {
                        // [databind#292]: Actually, may be fine, but only if polymorphic deser enabled
                        if (type.getTypeHandler() == null) {
                            throw new IllegalArgumentException(""Cannot find a deserializer for non-concrete Map type ""+type);
                        }
                        deser = AbstractDeserializer.constructForNonPOJO(beanDesc);
                    }
                } else {
                    // 10-Jan-2017, tatu: `java.util.Collections` types need help:
                    deser = JavaUtilCollectionsDeserializers.findForMap(ctxt, type);
                    if (deser != null) {
                        return deser;
                    }
                }
                if (deser == null) {
                    ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);
                    // 01-May-2016, tatu: Which base type to use here gets tricky, since
                    //   most often it ought to be `Map` or `EnumMap`, but due to abstract
                    //   mapping it will more likely be concrete type like `HashMap`.
                    //   So, for time being, just pass `Map.class`
                    MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);
                    JsonIgnoreProperties.Value ignorals = config.getDefaultPropertyIgnorals(Map.class,
                            beanDesc.getClassInfo());
                    Set<String> ignored = (ignorals == null) ? null
                            : ignorals.findIgnoredForDeserialization();
                    md.setIgnorableProperties(ignored);
                    deser = md;
                }
            }
        }
        if (_factoryConfig.hasDeserializerModifiers()) {
            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
                deser = mod.modifyMapDeserializer(config, type, beanDesc, deser);
            }
        }
        return deser;
    }
"
