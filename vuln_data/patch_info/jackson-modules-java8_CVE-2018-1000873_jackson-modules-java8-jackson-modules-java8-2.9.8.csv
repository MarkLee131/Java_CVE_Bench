Fix_Path,Fix_Src
"datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/InstantDeserializer.java:[280,285]:_fromDecimal","    protected T _fromDecimal(DeserializationContext context, BigDecimal value)
    {
        FromDecimalArguments args =
            DecimalUtils.extractSecondsAndNanos(value, (s, ns) -> new FromDecimalArguments(s, ns, getZone(context)));
        return fromNanoseconds.apply(args);
    }
"
"datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/DecimalUtils.java:[28,140]:DecimalUtils","public final class DecimalUtils
{
    private static final BigDecimal ONE_BILLION = new BigDecimal(1_000_000_000L);

    private DecimalUtils() { }

    public static String toDecimal(long seconds, int nanoseconds)
    {
        StringBuilder sb = new StringBuilder(20)
            .append(seconds)
            .append('.');
        // 14-Mar-2016, tatu: Although we do not yet (with 2.7) trim trailing zeroes,
        //   for general case,
        if (nanoseconds == 0L) {
            // !!! TODO: 14-Mar-2016, tatu: as per [datatype-jsr310], should trim
            //     trailing zeroes
            if (seconds == 0L) {
                return ""0.0"";
            }

//            sb.append('0');
            sb.append(""000000000"");
        } else {
            StringBuilder nanoSB = new StringBuilder(9);
            nanoSB.append(nanoseconds);
            // May need to both prepend leading nanos (if value less than 0.1)
            final int nanosLen = nanoSB.length();
            int prepZeroes = 9 - nanosLen;
            while (prepZeroes > 0) {
                --prepZeroes;
                sb.append('0');
            }

            // !!! TODO: 14-Mar-2016, tatu: as per [datatype-jsr310], should trim
            //     trailing zeroes
            /*
            // AND possibly trim trailing ones
            int i = nanosLen;
            while ((i > 1) && nanoSB.charAt(i-1) == '0') {
                --i;
            }
            if (i < nanosLen) {
                nanoSB.setLength(i);
            }
            */
            sb.append(nanoSB);
        }
        return sb.toString();
    }

    /**
     * @since 2.7.3
     */
    public static BigDecimal toBigDecimal(long seconds, int nanoseconds)
    {
        if (nanoseconds == 0L) {
            // 14-Mar-2015, tatu: Let's retain one zero to avoid interpretation
            //    as integral number
            if (seconds == 0L) { // except for ""0.0"" where it can not be done without scientific notation
                return BigDecimal.ZERO.setScale(1);
            }
            return BigDecimal.valueOf(seconds).setScale(9);
        }
        return new BigDecimal(toDecimal(seconds, nanoseconds));
    }

    /**
     * @Deprecated due to potential unbounded latency on some JRE releases.
     */
    public static int extractNanosecondDecimal(BigDecimal value, long integer)
    {
        // !!! 14-Mar-2016, tatu: Somewhat inefficient; should replace with functionally
        //   equivalent code that just subtracts integral part? (or, measure and show
        //   there's no difference and do nothing... )
        return value.subtract(new BigDecimal(integer)).multiply(ONE_BILLION).intValue();
    }


    /**
     * Extracts the seconds and nanoseconds component of {@code seconds} as {@code long} and {@code int}
     * values, passing them to the given converter.   The implementation avoids latency issues present
     * on some JRE releases.
     *
     * @since 2.9.8
     */
    public static <T> T extractSecondsAndNanos(BigDecimal seconds, BiFunction<Long, Integer, T> convert)
    {
        // Complexity is here to workaround unbounded latency in some BigDecimal operations.
        //   https://github.com/FasterXML/jackson-databind/issues/2141

        long secondsOnly;
        int nanosOnly;

        BigDecimal nanoseconds = seconds.scaleByPowerOfTen(9);
        if (nanoseconds.precision() - nanoseconds.scale() <= 0) {
            // There are no non-zero digits to the left of the decimal point.
            // This protects against very negative exponents.
            secondsOnly = nanosOnly = 0;
        }
        else if (seconds.scale() < -63) {
            // There would be no low-order bits once we chop to a long.
            // This protects against very positive exponents.
            secondsOnly = nanosOnly = 0;
        }
        else {
            // Now we know that seconds has reasonable scale, we can safely chop it apart.
            secondsOnly = seconds.longValue();
            nanosOnly = nanoseconds.subtract(new BigDecimal(secondsOnly).scaleByPowerOfTen(9)).intValue();
        }

        return convert.apply(secondsOnly, nanosOnly);
    }
}
"
"datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/DecimalUtils.java:[34,76]:toDecimal","    public static String toDecimal(long seconds, int nanoseconds)
    {
        StringBuilder sb = new StringBuilder(20)
            .append(seconds)
            .append('.');
        // 14-Mar-2016, tatu: Although we do not yet (with 2.7) trim trailing zeroes,
        //   for general case,
        if (nanoseconds == 0L) {
            // !!! TODO: 14-Mar-2016, tatu: as per [datatype-jsr310], should trim
            //     trailing zeroes
            if (seconds == 0L) {
                return ""0.0"";
            }

//            sb.append('0');
            sb.append(""000000000"");
        } else {
            StringBuilder nanoSB = new StringBuilder(9);
            nanoSB.append(nanoseconds);
            // May need to both prepend leading nanos (if value less than 0.1)
            final int nanosLen = nanoSB.length();
            int prepZeroes = 9 - nanosLen;
            while (prepZeroes > 0) {
                --prepZeroes;
                sb.append('0');
            }

            // !!! TODO: 14-Mar-2016, tatu: as per [datatype-jsr310], should trim
            //     trailing zeroes
            /*
            // AND possibly trim trailing ones
            int i = nanosLen;
            while ((i > 1) && nanoSB.charAt(i-1) == '0') {
                --i;
            }
            if (i < nanosLen) {
                nanoSB.setLength(i);
            }
            */
            sb.append(nanoSB);
        }
        return sb.toString();
    }
"
"datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/TestDecimalUtils.java:[44,48]:testExtractNanosecondDecimal01","    public void testExtractNanosecondDecimal01()
    {
        BigDecimal value = new BigDecimal(""0"");
        checkExtractNanos(0L, 0, value);
    }
"
"datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/TestDecimalUtils.java:[51,55]:testExtractNanosecondDecimal02","    public void testExtractNanosecondDecimal02()
    {
        BigDecimal value = new BigDecimal(""15.000000072"");
        checkExtractNanos(15L, 72, value);
    }
"
"datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/TestDecimalUtils.java:[58,62]:testExtractNanosecondDecimal03","    public void testExtractNanosecondDecimal03()
    {
        BigDecimal value = new BigDecimal(""15.72"");
        checkExtractNanos(15L, 720000000, value);
    }
"
"datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/TestDecimalUtils.java:[65,69]:testExtractNanosecondDecimal04","    public void testExtractNanosecondDecimal04()
    {
        BigDecimal value = new BigDecimal(""19827342231.192837465"");
        checkExtractNanos(19827342231L, 192837465, value);
    }
"
"datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/TestDecimalUtils.java:[72,76]:testExtractNanosecondDecimal05","    public void testExtractNanosecondDecimal05()
    {
        BigDecimal value = new BigDecimal(""19827342231"");
        checkExtractNanos(19827342231L, 0, value);
    }
"
"datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/TestDecimalUtils.java:[79,83]:testExtractNanosecondDecimal06","    public void testExtractNanosecondDecimal06()
    {
        BigDecimal value = new BigDecimal(""19827342231.999999999"");
        checkExtractNanos(19827342231L, 999999999, value);
    }
"
"datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/DurationDeserializer.java:[43,46]:DurationDeserializer","    private DurationDeserializer()
    {
        super(Duration.class);
    }
"
"datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/DurationDeserializer.java:[49,83]:deserialize","    public Duration deserialize(JsonParser parser, DeserializationContext context) throws IOException
    {
        switch (parser.getCurrentTokenId())
        {
            case JsonTokenId.ID_NUMBER_FLOAT:
                BigDecimal value = parser.getDecimalValue();
                return DecimalUtils.extractSecondsAndNanos(value, Duration::ofSeconds);

            case JsonTokenId.ID_NUMBER_INT:
                if(context.isEnabled(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)) {
                    return Duration.ofSeconds(parser.getLongValue());
                }
                return Duration.ofMillis(parser.getLongValue());

            case JsonTokenId.ID_STRING:
                String string = parser.getText().trim();
                if (string.length() == 0) {
                    return null;
                }
                try {
                    return Duration.parse(string);
                } catch (DateTimeException e) {
                    return _handleDateTimeException(context, e, string);
                }
            case JsonTokenId.ID_EMBEDDED_OBJECT:
                // 20-Apr-2016, tatu: Related to [databind#1208], can try supporting embedded
                //    values quite easily
                return (Duration) parser.getEmbeddedObject();
                
            case JsonTokenId.ID_START_ARRAY:
            	return _deserializeFromArray(parser, context);
        }
        return _handleUnexpectedToken(context, parser, JsonToken.VALUE_STRING,
                JsonToken.VALUE_NUMBER_INT, JsonToken.VALUE_NUMBER_FLOAT);
    }
"
