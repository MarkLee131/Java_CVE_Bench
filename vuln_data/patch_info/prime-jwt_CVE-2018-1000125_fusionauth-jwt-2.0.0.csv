Fix_Path,Fix_Src
"src/test/java/org/primeframework/jwt/JWTTest.java:[54,420]:JWTTest","public class JWTTest extends BaseTest {

  /**
   * Performance
   * <pre>
   *   Performance Summary:
   *   - HMAC is dramatically faster
   *   - SHA length does not dramatically affect the results
   *   - Size of JWT will negatively affect the performance of encoding and decoding
   *   - Verifying an RSA signature is much faster than generating the signature
   *
   *   Performance Recommendations:
   *   - Keep the JWT as small as possible
   *   - Use HMAC when you can safely share the HMAC secret or performance is paramount
   * </pre>
   */
  @Test(enabled = false)
  public void decoding_performance() throws Exception {
    String secret = JWTUtils.generateSHA256HMACSecret();
    Signer hmacSigner = HMACSigner.newSHA256Signer(secret);
    Signer rsaSigner = RSASigner.newSHA256Signer(new String(Files.readAllBytes(Paths.get(""src/test/resources/rsa_private_key_2048.pem""))));

    Verifier hmacVerifier = HMACVerifier.newVerifier(secret);
    Verifier rsaVerifier = RSAVerifier.newVerifier(new String(Files.readAllBytes(Paths.get(""src/test/resources/rsa_public_key_2048.pem""))));

    JWT jwt = new JWT().setSubject(UUID.randomUUID().toString())
        .addClaim(""exp"", ZonedDateTime.now(ZoneOffset.UTC).plusMinutes(5).toInstant().toEpochMilli())
        .setAudience(UUID.randomUUID().toString())
        .addClaim(""roles"", new ArrayList<>(Arrays.asList(""admin"", ""user"")))
        .addClaim(""iat"", ZonedDateTime.now(ZoneOffset.UTC).toInstant().toEpochMilli())
        .setIssuer(""inversoft.com"");

    long iterationCount = 250_000;
    for (Verifier verifier : Arrays.asList(hmacVerifier, rsaVerifier)) {
      Instant start = Instant.now();
      Signer signer = verifier instanceof HMACVerifier ? hmacSigner : rsaSigner;
// Uncomment the following line to run without a signer, no signature, no verification is very fast.
//      Signer signer = new UnsecuredSigner();
      String encodedJWT = JWT.getEncoder().encode(jwt, signer);

      for (int i = 0; i < iterationCount; i++) {
        JWT.getDecoder().decode(encodedJWT, verifier);
// Uncomment the following line to run without a signer, no signature, no verification is very fast.
//        JWT.getDecoder().decode(encodedJWT); // no verifier, no signature
      }

      Duration duration = Duration.between(start, Instant.now());
      BigDecimal durationInMillis = BigDecimal.valueOf(duration.toMillis());
      BigDecimal average = durationInMillis.divide(BigDecimal.valueOf(iterationCount), RoundingMode.HALF_DOWN);
      long perSecond = iterationCount / (duration.toMillis() / 1000);

      System.out.println(""["" + signer.getAlgorithm().getName() + ""] "" + duration.toMillis() + "" milliseconds total. ["" + iterationCount + ""] iterations. ["" + average + ""] milliseconds per iteration. Approx. ["" + perSecond + ""] per second."");

    }
  }

  @Test(enabled = false)
  public void encoding_performance() throws Exception {
    Signer hmacSigner = HMACSigner.newSHA256Signer(JWTUtils.generateSHA256HMACSecret());
    Signer rsaSigner = RSASigner.newSHA256Signer(new String(Files.readAllBytes(Paths.get(""src/test/resources/rsa_private_key_2048.pem""))));

    JWT jwt = new JWT().setSubject(UUID.randomUUID().toString())
        .addClaim(""exp"", ZonedDateTime.now(ZoneOffset.UTC).plusMinutes(5).toInstant().toEpochMilli())
        .setAudience(UUID.randomUUID().toString())
        .addClaim(""roles"", new ArrayList<>(Arrays.asList(""admin"", ""user"")))
        .addClaim(""iat"", ZonedDateTime.now(ZoneOffset.UTC).toInstant().toEpochMilli())
        .setIssuer(""inversoft.com"");

    long iterationCount = 10_000;
    for (Signer signer : Arrays.asList(hmacSigner, rsaSigner)) {
// Uncomment the following line to run without a signer, no signature, no verification is very fast.
//      signer = new UnsecuredSigner();
      Instant start = Instant.now();
      for (int i = 0; i < iterationCount; i++) {
        JWT.getEncoder().encode(jwt, signer);
      }
      Duration duration = Duration.between(start, Instant.now());
      BigDecimal durationInMillis = BigDecimal.valueOf(duration.toMillis());
      BigDecimal average = durationInMillis.divide(BigDecimal.valueOf(iterationCount), RoundingMode.HALF_DOWN);
      long perSecond = iterationCount / (duration.toMillis() / 1000);

      System.out.println(""["" + signer.getAlgorithm().getName() + ""] "" + duration.toMillis() + "" milliseconds total. ["" + iterationCount + ""] iterations. ["" + average + ""] milliseconds per iteration. Approx. ["" + perSecond + ""] per second."");
    }
  }

  @Test
  public void expired() {
    // no expiration
    assertFalse(new JWT()
        .setSubject(""123456789"").isExpired());

    assertFalse(new JWT()
        .setExpiration(ZonedDateTime.now(ZoneOffset.UTC).plusMinutes(1))
        .setSubject(""123456789"").isExpired());

    assertTrue(new JWT()
        .setExpiration(ZonedDateTime.now(ZoneOffset.UTC).minusMinutes(1))
        .setSubject(""123456789"").isExpired());
  }

  @Test
  public void test_HS256() {
    JWT jwt = new JWT().setSubject(""123456789"");
    Signer signer = HMACSigner.newSHA256Signer(""secret"");

    assertEquals(JWT.getEncoder().encode(jwt, signer), ""eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkifQ.qHdut1UR4-2FSAvh7U3YdeRR5r5boVqjIGQ16Ztp894"");
  }

  @Test
  public void test_HS256_manualAddedClaim() {
    JWT jwt = new JWT().addClaim(""test"", ""123456789"");
    Signer signer = HMACSigner.newSHA256Signer(""secret"");

    assertEquals(JWT.getEncoder().encode(jwt, signer), ""eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0ZXN0IjoiMTIzNDU2Nzg5In0.0qgr4ztqB0mNXA8mtqaBSL6UJT3aqEyjHMrWDZmT4Bc"");
  }

  @Test
  public void test_HS384() {
    JWT jwt = new JWT().setSubject(""123456789"");
    Signer signer = HMACSigner.newSHA384Signer(""secret"");

    String encodedJWT = JWT.getEncoder().encode(jwt, signer);
    assertEquals(encodedJWT, ""eyJhbGciOiJIUzM4NCIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkifQ.sCHKynlQkBveA063_Z-fwcXmRYp_lKQ0fRqGNzplb14qMUj5CV3CfXwluclTF17P"");

    assertEquals(JWT.getDecoder().decode(encodedJWT, HMACVerifier.newVerifier(""secret"")).subject, jwt.subject);
  }

  @Test
  public void test_HS512() {
    JWT jwt = new JWT().setSubject(""123456789"");
    Signer signer = HMACSigner.newSHA512Signer(""secret"");

    assertEquals(JWT.getEncoder().encode(jwt, signer), ""eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkifQ.MgAi9gfGkep-IoFYPHMhHz6w2Kxf0u8TZ-wNeQOLPwc8emLNKOMqBU-5dJXeaY5-8wQ1CvZycWHbEilvHgN6Ug"");
  }

  @Test
  public void test_RS256() throws Exception {
    JWT jwt = new JWT().setSubject(""123456789"");
    Signer signer = RSASigner.newSHA256Signer(new String(Files.readAllBytes(Paths.get(""src/test/resources/rsa_private_key_4096.pem""))));

    assertEquals(JWT.getEncoder().encode(jwt, signer), ""eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkifQ.kRXJkOHC98D0LCT2oPg5fTmQJDFXkMRQJopbt7QM6prmQDHwjJL_xO-_EXRXnbvf5NLORto45By3XNn2ZzWmY3pAOxj46MlQ5elhROx2S-EnHZNLfQhoG8ZXPZ54q-Obz_6K7ZSlkAQ8jmeZUO3Ryi8jRlHQ2PT4LbBtLpaf982SGJfeTyUMw1LbvowZUTZSF-E6JARaokmmx8M2GeLuKcFhU-YsBTXUarKp0IJCy3jpMQ2zW_HGjyVWH8WwSIbSdpBn7ztoQEJYO-R5H3qVaAz2BsTuGLRxoyIu1iy2-QcDp5uTufmX1roXM8ciQMpcfwKGiyNpKVIZm-lF8aROXRL4kk4rqp6KUzJuOPljPXRU--xKSua-DeR0BEerKzI9hbwIMWiblCslAciNminoSc9G7pUyVwV5Z5IT8CGJkVgoyVGELeBmYCDy7LHwXrr0poc0hPbE3mJXhzolga4BB84nCg2Hb9tCNiHU8F-rKgZWCONaSSIdhQ49x8OiPafFh2DJBEBe5Xbm6xdCfh3KVG0qe4XL18R5s98aIP9UIC4i62UEgPy6W7Fr7QgUxpXrjRCERBV3MiNu4L8NNJb3oZleq5lQi72EfdS-Bt8ZUOVInIcAvSmu-3i8jB_2sF38XUXdl8gkW8k_b9dJkzDcivCFehvSqGmm3vBm5X4bNmk"");
  }

  @Test
  public void test_RS384() throws Exception {
    JWT jwt = new JWT().setSubject(""123456789"");
    Signer signer = RSASigner.newSHA384Signer(new String(Files.readAllBytes(Paths.get(""src/test/resources/rsa_private_key_4096.pem""))));

    String encodedJWT = JWT.getEncoder().encode(jwt, signer);
    assertEquals(encodedJWT, ""eyJhbGciOiJSUzM4NCIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkifQ.OkmWXzhTm7mtfpeMVNLlFjw3fJvc7yMQ1rgI5BXBPqaLSb_fpLHYAq_q5pQDDaIGg8klg9y2f784smc7-o9czX3JnzEDvO9e_sA10YIEA6Q9qRh17EATNXFG-WzSocpxPgEOQZ8lqSqZ_0waCGaUMwK5J5BB1A_70AcNGPnI7PrX76lWNNHwdK0OjkhkxX7vHR6B-uAIzih0ntQP_afr1UIzXkllmnnb1oU9cgFFD1AGDa3V0XCgitVYZA_ozbGELGMrUl_7fB_uNVEvcreUoZIEI4cfUKI6iZ8Ll4j_iLAdlpH4GRGNiQ7gMLq35AqqxKbEG8r-S-SrlRL6PkKlaJ-viMVLxoHreZow634r8A1fxR1mnrdUnn0vGmOthyjpP_TgfAsER9EJ_UUIamsKC8s6pip2jcPB7G6huHocyKBTxsoxclQgk1jOy4lZq4Js2KKM5sGfcq5SWQTW4B44KlUU1kWWmUg21jtflna38sWFdTk845phi5ITOBZ_ElJ9MdYVAgjvDsRFs_XxFENlwpwKeLD9PsaCiJhdG7EJN5qJvVogYuUMM0wyS-SOGZ1ILsTeYsjc7TtI0JUKndlUXFPubwaaxW_06zrCJR-dvWye99fIDH-u3I74XK5MKhknlgewzsXpsiPdvsMW59WUbdIZqkvok5vdkIlm4XGIqcM"");

    assertEquals(JWT.getDecoder().decode(encodedJWT, RSAVerifier.newVerifier(new String(Files.readAllBytes(Paths.get(""src/test/resources/rsa_public_key_4096.pem""))))).subject, jwt.subject);
  }

  @Test
  public void test_RS512() throws Exception {
    JWT jwt = new JWT().setSubject(""123456789"");
    Signer signer = RSASigner.newSHA512Signer(new String(Files.readAllBytes(Paths.get(""src/test/resources/rsa_private_key_4096.pem""))));

    assertEquals(JWT.getEncoder().encode(jwt, signer), ""eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkifQ.ei28WNoJdUpMlLnHr78HiTnnuKwSRLYcOpgUC3daVInT5RAc0kk2Ipx16Z-bHL_eFLSYgF3TSKdymFpNf8cnEu5T6rH0azYSZLrPmVCetDxjo-ixXK9asPOF3JuIbDjN7ow3K-CMbMCWzWp04ZAh-DNecYEd3HiGgooPVGA4HuVXZFHH8XfQ9TD-64ppBQTWgW32vkna8ILKyIXdwWXSEfCZYfLzLZnilJrz820wZJ5JMXimv2au0OwwRobUMLEBUM4iuEPXLf5wFJU6LcU0XMuovavfIXKDpvP9Yfz6UplMlFvIr9y72xExfaNt32vwneAP-Fpg2x9wYvR0W8LhXKZaFRfcYwhbj17GCAbpx34hjiqnwyFStn5Qx_QHz_Y7ck-ZXB2MGUkiYGj9y_8bQNx-LIaTQUX6sONTNdVVCfnOnMHFqVbupGho24K7885-8BxCRojvA0ggneF6dsKCQvAt2rsVRso0TrCVxwYItb9tRsyhCbWou-zh_08JlYGVXPiGY3RRQDfxCc9RHQUflWRS9CBcPtoaco4mFKZSM-9e_xoYx__DEzM3UjaI4jReLM-IARwlVPoHJa2Vcb5wngZTaxGf2ToMq7R_8KecZymb3OaA2X1e8GS2300ySwsXbOz0sJv2a7_JUncSEBPSsb2vMMurxSJ4E3RTAc4s3aU"");
  }

  @Test
  public void test_RSA_1024Key() {
    expectException(InvalidKeyLengthException.class, ()
        -> RSASigner.newSHA256Signer(new String(Files.readAllBytes(Paths.get(""src/test/resources/rsa_private_key_1024.pem"")))));
    expectException(InvalidKeyLengthException.class, ()
        -> RSAVerifier.newVerifier(new String(Files.readAllBytes(Paths.get(""src/test/resources/rsa_public_key_1024.pem"")))));
  }

  @Test
  public void test_badEncoding() throws Exception {
    Verifier verifier = RSAVerifier.newVerifier(new String(Files.readAllBytes(Paths.get(""src/test/resources/rsa_public_key_2048.pem""))));
    // add a space to the header, invalid Base64 character point 20 (space)
    expectException(InvalidJWTException.class, ()
        -> JWT.getDecoder().decode(""eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9 .foo.bar"", verifier));
  }

  @Test
  public void test_complexPayload() {
    JWT expectedJWT = new JWT()
        .setAudience(Arrays.asList(""www.acme.com"", ""www.vandelayindustries.com""))
        .setExpiration(ZonedDateTime.now(ZoneOffset.UTC).plusMinutes(60).truncatedTo(ChronoUnit.SECONDS))
        .setIssuedAt(ZonedDateTime.now(ZoneOffset.UTC).truncatedTo(ChronoUnit.SECONDS))
        .setIssuer(""www.inversoft.com"")
        .setNotBefore(ZonedDateTime.now(ZoneOffset.UTC).minusMinutes(5).truncatedTo(ChronoUnit.SECONDS))
        .setUniqueId(UUID.randomUUID().toString())
        .setSubject(""123456789"")
        .addClaim(""foo"", ""bar"")
        .addClaim(""timestamp"", 1476062602926L)
        .addClaim(""bigInteger"", new BigInteger(""100000000000000000000000000000000000000000000000000000000000000000000000000000000""))
        .addClaim(""bigDecimal"", new BigDecimal(""11.2398732934908570987534209857423098743209857""))
        .addClaim(""double"", 3.14d)
        .addClaim(""float"", 3.14f)
        .addClaim(""meaningOfLife"", 42)
        .addClaim(""bar"", Arrays.asList(""bing"", ""bam"", ""boo""))
        .addClaim(""object"", Collections.singletonMap(""nested"", Collections.singletonMap(""foo"", ""bar"")))
        .addClaim(""www.inversoft.com/claims/is_admin"", true);

    Signer signer = HMACSigner.newSHA256Signer(""secret"");
    Verifier verifier = HMACVerifier.newVerifier(""secret"");

    String encodedJWT = JWT.getEncoder().encode(expectedJWT, signer);
    JWT actualJwt = JWT.getDecoder().decode(encodedJWT, verifier);

    assertEquals(actualJwt.audience, expectedJWT.audience);
    assertEquals(actualJwt.expiration, expectedJWT.expiration);
    assertEquals(actualJwt.issuedAt, expectedJWT.issuedAt);
    assertEquals(actualJwt.issuer, expectedJWT.issuer);
    assertEquals(actualJwt.notBefore, expectedJWT.notBefore);
    assertEquals(actualJwt.uniqueId, expectedJWT.uniqueId);
    assertEquals(actualJwt.subject, expectedJWT.subject);
    assertEquals(actualJwt.getString(""foo""), expectedJWT.getString(""foo""));
    assertEquals(actualJwt.getBigInteger(""timestamp""), expectedJWT.getBigInteger(""timestamp""));
    assertEquals(actualJwt.getLong(""timestamp""), expectedJWT.getLong(""timestamp""));
    assertEquals(actualJwt.getNumber(""timestamp""), expectedJWT.getNumber(""timestamp""));
    assertEquals(actualJwt.getBigInteger(""meaningOfLife""), expectedJWT.getBigInteger(""meaningOfLife""));
    assertEquals(actualJwt.getInteger(""meaningOfLife""), expectedJWT.getInteger(""meaningOfLife""));
    assertEquals(actualJwt.getNumber(""meaningOfLife""), expectedJWT.getNumber(""meaningOfLife""));
    assertEquals(actualJwt.getBigDecimal(""double""), expectedJWT.getBigDecimal(""double""));
    assertEquals(actualJwt.getDouble(""double""), expectedJWT.getDouble(""double""));
    assertEquals(actualJwt.getNumber(""double""), expectedJWT.getNumber(""double""));
    assertEquals(actualJwt.getBigDecimal(""float""), expectedJWT.getBigDecimal(""float""));
    assertEquals(actualJwt.getFloat(""float""), expectedJWT.getFloat(""float""));
    assertEquals(actualJwt.getNumber(""float""), expectedJWT.getNumber(""float""));
    assertEquals(actualJwt.getBigInteger(""bigInteger""), expectedJWT.getBigInteger(""bigInteger""));
    assertEquals(actualJwt.getNumber(""bigInteger""), expectedJWT.getNumber(""bigInteger""));
    assertEquals(actualJwt.getBigDecimal(""bigDecimal""), expectedJWT.getBigDecimal(""bigDecimal""));
    assertEquals(actualJwt.getNumber(""bigDecimal""), expectedJWT.getNumber(""bigDecimal""));
    assertEquals(actualJwt.getObject(""bar""), expectedJWT.getObject(""bar""));
    assertEquals(actualJwt.getList(""bar""), expectedJWT.getList(""bar""));
    assertEquals(actualJwt.getMap(""object""), expectedJWT.getObject(""object""));
    assertEquals(actualJwt.getBoolean(""www.inversoft.com/claims/is_admin""), expectedJWT.getBoolean(""www.inversoft.com/claims/is_admin""));

    // validate raw claims
    Map<String, Object> rawClaims = actualJwt.getRawClaims();
    assertEquals(rawClaims.get(""aud""), expectedJWT.audience);
    assertEquals(rawClaims.get(""exp""), expectedJWT.expiration.toEpochSecond());
    assertEquals(rawClaims.get(""iat""), expectedJWT.issuedAt.toEpochSecond());
    assertEquals(rawClaims.get(""iss""), expectedJWT.issuer);
    assertEquals(rawClaims.get(""nbf""), expectedJWT.notBefore.toEpochSecond());
    assertEquals(rawClaims.get(""jti""), expectedJWT.uniqueId);
    assertEquals(rawClaims.get(""sub""), expectedJWT.subject);
    assertEquals(rawClaims.get(""foo""), expectedJWT.getString(""foo""));
    assertEquals(rawClaims.get(""timestamp""), expectedJWT.getBigInteger(""timestamp""));
    assertEquals(rawClaims.get(""meaningOfLife""), expectedJWT.getBigInteger(""meaningOfLife""));
    assertEquals(rawClaims.get(""bar""), expectedJWT.getObject(""bar""));
    assertEquals(rawClaims.get(""object""), expectedJWT.getObject(""object""));
    assertEquals(rawClaims.get(""www.inversoft.com/claims/is_admin""), expectedJWT.getBoolean(""www.inversoft.com/claims/is_admin""));

    // validate all claims
    Map<String, Object> allClaims = actualJwt.getAllClaims();
    assertEquals(allClaims.get(""aud""), expectedJWT.audience);
    assertEquals(allClaims.get(""exp""), expectedJWT.expiration);
    assertEquals(allClaims.get(""iat""), expectedJWT.issuedAt);
    assertEquals(allClaims.get(""iss""), expectedJWT.issuer);
    assertEquals(allClaims.get(""nbf""), expectedJWT.notBefore);
    assertEquals(allClaims.get(""jti""), expectedJWT.uniqueId);
    assertEquals(allClaims.get(""sub""), expectedJWT.subject);
    assertEquals(allClaims.get(""foo""), expectedJWT.getString(""foo""));
    assertEquals(allClaims.get(""timestamp""), expectedJWT.getBigInteger(""timestamp""));
    assertEquals(allClaims.get(""meaningOfLife""), expectedJWT.getBigInteger(""meaningOfLife""));
    assertEquals(allClaims.get(""bar""), expectedJWT.getObject(""bar""));
    assertEquals(allClaims.get(""object""), expectedJWT.getObject(""object""));
    assertEquals(allClaims.get(""www.inversoft.com/claims/is_admin""), expectedJWT.getBoolean(""www.inversoft.com/claims/is_admin""));
  }

  @Test
  public void test_expiredThrows() {
    JWT expectedJWT = new JWT()
        .setExpiration(ZonedDateTime.now(ZoneOffset.UTC).minusMinutes(1).truncatedTo(ChronoUnit.SECONDS));

    Signer signer = HMACSigner.newSHA256Signer(""secret"");
    Verifier verifier = HMACVerifier.newVerifier(""secret"");

    String encodedJWT = JWT.getEncoder().encode(expectedJWT, signer);

    expectException(JWTExpiredException.class, ()
        -> JWT.getDecoder().decode(encodedJWT, verifier));
  }

  @Test
  public void test_multipleSignersAndVerifiers() throws Exception {
    JWT jwt = new JWT().setSubject(""123456789"");

    // Three separate signers
    Signer signer1 = HMACSigner.newSHA512Signer(""secret1"");
    Signer signer2 = HMACSigner.newSHA512Signer(""secret2"");
    Signer signer3 = RSASigner.newSHA256Signer(new String(Files.readAllBytes(Paths.get(""src/test/resources/rsa_private_key_2048.pem""))));

    // Encode the same JWT with each signer, writing the Key ID to the header
    String encodedJWT1 = JWT.getEncoder().encode(jwt, signer1, h -> h.set(""kid"", ""verifier1""));
    String encodedJWT2 = JWT.getEncoder().encode(jwt, signer2, h -> h.set(""kid"", ""verifier2""));
    String encodedJWT3 = JWT.getEncoder().encode(jwt, signer3, h -> h.set(""kid"", ""verifier3""));

    Verifier verifier1 = HMACVerifier.newVerifier(""secret1"");
    Verifier verifier2 = HMACVerifier.newVerifier(""secret2"");
    Verifier verifier3 = RSAVerifier.newVerifier(new String(Files.readAllBytes(Paths.get(""src/test/resources/rsa_public_key_2048.pem""))));

    Map<String, Verifier> verifiers = new HashMap<>();
    verifiers.put(""verifier1"", verifier1);
    verifiers.put(""verifier2"", verifier2);
    verifiers.put(""verifier3"", verifier3);

    // decode all of the encoded JWTs and ensure they come out the same.
    JWT jwt1 = JWT.getDecoder().decode(encodedJWT1, verifiers);
    JWT jwt2 = JWT.getDecoder().decode(encodedJWT2, verifiers);
    JWT jwt3 = JWT.getDecoder().decode(encodedJWT3, verifiers);

    assertEquals(jwt1.subject, jwt2.subject);
    assertEquals(jwt2.subject, jwt3.subject);
  }

  @Test
  public void test_none() {
    JWT jwt = new JWT().setSubject(""123456789"");
    Signer signer = new UnsecuredSigner();

    String encodedJWT = JWT.getEncoder().encode(jwt, signer);
    assertEquals(encodedJWT, ""eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkifQ."");

    JWT actual = JWT.getDecoder().decode(encodedJWT);
    assertEquals(actual.subject, jwt.subject);

    // Remove the last '.' (dot) and try again - this will fail, invalid JWT. All three parts are required, even for 'none'
    expectException(InvalidJWTException.class, () -> JWT.getDecoder().decode(""eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkifQ""));
  }

  @Test
  public void test_notBeforeThrows() {
    JWT expectedJWT = new JWT()
        .setExpiration(ZonedDateTime.now(ZoneOffset.UTC).plusMinutes(60).truncatedTo(ChronoUnit.SECONDS))
        .setIssuedAt(ZonedDateTime.now(ZoneOffset.UTC).truncatedTo(ChronoUnit.SECONDS))
        .setIssuer(""www.inversoft.com"")
        .setNotBefore(ZonedDateTime.now(ZoneOffset.UTC).plusMinutes(5).truncatedTo(ChronoUnit.SECONDS));

    Signer signer = HMACSigner.newSHA256Signer(""secret"");
    Verifier verifier = HMACVerifier.newVerifier(""secret"");

    String encodedJWT = JWT.getEncoder().encode(expectedJWT, signer);

    expectException(JWTUnavailableForProcessingException.class, ()
        -> JWT.getDecoder().decode(encodedJWT, verifier));
  }

  @Test
  public void test_nullFailFast() {
    expectException(NullPointerException.class, () -> JWTDecoder.getInstance().decode(null, null, null));
    expectException(NullPointerException.class, () -> JWTDecoder.getInstance().decode(""foo"", null, null));
    expectException(NullPointerException.class, () -> JWTDecoder.getInstance().decode(""foo"", Collections.emptyMap(), null));
  }

  @Test
  public void test_zonedDateTime() {
    ZonedDateTime expiration = ZonedDateTime.now(ZoneOffset.UTC).plusMinutes(60).truncatedTo(ChronoUnit.SECONDS);
    JWT expectedJWT = new JWT().setExpiration(expiration);

    Signer signer = HMACSigner.newSHA256Signer(""secret"");
    Verifier verifier = HMACVerifier.newVerifier(""secret"");

    String encodedJWT1 = JWT.getEncoder().encode(expectedJWT, signer);
    JWT actualJWT1 = JWT.getDecoder().decode(encodedJWT1, verifier);

    assertEquals(actualJWT1.expiration, expectedJWT.expiration);
  }

}
"
"src/main/java/org/primeframework/jwt/JWTDecoder.java:[41,234]:JWTDecoder","public class JWTDecoder {

  private static JWTDecoder instance;

  public static JWTDecoder getInstance() {
    if (instance == null) {
      instance = new JWTDecoder();
    }

    return instance;
  }

  /**
   * Decode the JWT using one of they provided verifiers. One more verifiers may be provided, the first verifier found
   * supporting the algorithm reported by the JWT header will be utilized.
   * <p>
   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link
   * JWTUnavailableForProcessingException} exception will be thrown respectively.
   *
   * @param encodedJWT The encoded JWT in string format.
   * @param verifiers  A map of verifiers.
   * @return a decoded JWT.
   */
  public JWT decode(String encodedJWT, Verifier... verifiers) {
    Objects.requireNonNull(encodedJWT);
    Objects.requireNonNull(verifiers);

    String[] parts = getParts(encodedJWT);

    Header header = Mapper.deserialize(base64Decode(parts[0]), Header.class);
    Verifier verifier = Arrays.stream(verifiers).filter(v -> v.canVerify(header.algorithm)).findFirst().orElse(null);

    // The 'none' algorithm is only allowed when no verifiers are provided.
    boolean allowNoneAlgorithm = verifiers.length == 0;

    return validate(encodedJWT, parts, header, verifier, allowNoneAlgorithm);
  }

  /**
   * Decode the JWT using one of they provided verifiers. A JWT header value named <code>kid</code> is expected to
   * contain the key to lookup the correct verifier.
   * <p>
   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link
   * JWTUnavailableForProcessingException} exception will be thrown respectively.
   *
   * @param encodedJWT The encoded JWT in string format.
   * @param verifiers  A map of verifiers.
   * @return a decoded JWT.
   */
  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers) {
    return decode(encodedJWT, verifiers, h -> h.get(""kid""));
  }

  /**
   * Decode the JWT using one of they provided verifiers. The key used to lookup the correct verifier is provided by the
   * <code>keyFunction</code>. The key function is provided the JWT header and is expected to return a string key to
   * look up the correct verifier.
   * <p>
   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link
   * JWTUnavailableForProcessingException} exception will be thrown respectively.
   *
   * @param encodedJWT  The encoded JWT in string format.
   * @param verifiers   A map of verifiers.
   * @param keyFunction A function used to lookup the verifier key from the header.
   * @return a decoded JWT.
   */
  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers, Function<Header, String> keyFunction) {
    Objects.requireNonNull(encodedJWT);
    Objects.requireNonNull(verifiers);
    Objects.requireNonNull(keyFunction);

    String[] parts = getParts(encodedJWT);

    Header header = Mapper.deserialize(base64Decode(parts[0]), Header.class);
    String key = keyFunction.apply(header);
    Verifier verifier = verifiers.get(key);

    // The 'none' algorithm is only allowed when no verifiers are provided.
    boolean allowNoneAlgorithm = verifiers.isEmpty();

    return validate(encodedJWT, parts, header, verifier, allowNoneAlgorithm);
  }

  /**
   * Decode the provided base64 encoded string.
   *
   * @param string the input string to decode, it is expected to be a valid base64 encoded string.
   * @return a decoded byte array
   */
  private byte[] base64Decode(String string) {
    try {
      // Equal to calling : .decode(string.getBytes(StandardCharsets.ISO_8859_1))
      // If this is a properly base64 encoded string, decoding using ISO_8859_1 should be fine.
      return Base64.getUrlDecoder().decode(string);
    } catch (IllegalArgumentException e) {
      throw new InvalidJWTException(""The encoded JWT is not properly Base64 encoded."", e);
    }
  }

  /**
   * Split the encoded JWT on a period (.), and return the parts.
   * <p>
   * A secured JWT will be in the format : <code>XXXXX.YYYYY.ZZZZZ</code> and an un-secured JWT (no signature) will be in the format <code>XXXXX.YYYYY</code>.
   *
   * @param encodedJWT the encoded form of the JWT
   * @return an array of parts, 2 for an un-secured JWT, and 3 parts for a secured JWT.
   */
  private String[] getParts(String encodedJWT) {
    String[] parts = encodedJWT.split(""\\."");
    if (parts.length == 3 || (parts.length == 2 && encodedJWT.endsWith("".""))) {
      return parts;
    }

    throw new InvalidJWTException(""The encoded JWT is not properly formatted. Expected a three part dot separated string."");
  }

  /**
   * Validate the encoded JWT and return the constructed JWT object if valid.
   *
   * @param encodedJWT         the encoded JWT
   * @param parts              the parts of the encoded JWT
   * @param header             the JWT header
   * @param verifier           the selected JWT verifier
   * @param allowNoneAlgorithm true if un-secured JWTs may be decoded, i.e. 'none' algorithm is allowed
   * @return the constructed JWT object containing identity claims
   */
  private JWT validate(String encodedJWT, String[] parts, Header header, Verifier verifier, boolean allowNoneAlgorithm) {
    // When parts.length == 2, we have no signature.
    //  - Case 1: If one or more verifiers are provided, we will not decode an un-secured JWT. Throw NoneNotAllowedException
    //  - Case 2: If no verifiers are provided, we will decode an un-secured JWT, the algorithm must be 'none'.
    if (parts.length == 2) {
      if (!allowNoneAlgorithm) {
        throw new NoneNotAllowedException();
      }

      if (header.algorithm != Algorithm.none) {
        throw new MissingSignatureException(""Your provided a JWT with the algorithm ["" + header.algorithm.getName() + ""] but it is missing a signature"");
      }
    } else {
      // When parts.length == 3, we have a signature.
      // - Case 1: The algorithm in the header is 'none', we do not expect a signature.
      // - Case 2: No verifier was provided that can verify the algorithm in the header, or no verifier found by the kid in the header
      // - Case 3: The requested verifier cannot verify the signature based upon the algorithm value in the header
      if (header.algorithm == Algorithm.none) {
        throw new InvalidJWTException(""You provided a JWT with a signature and an algorithm of none"");
      }

      if (verifier == null) {
        throw new MissingVerifierException(""No Verifier has been provided for verify a signature signed using ["" + header.algorithm.getName() + ""]"");
      }

      // When the verifier has been selected based upon the 'kid' or other identifier in the header, we must verify it can verify the algorithm.
      // - When multiple verifiers are provided to .decode w/out a kid, we may have already called 'canVerify', this is ok.
      if (!verifier.canVerify(header.algorithm)) {
        throw new MissingVerifierException(""No Verifier has been provided for verify a signature signed using ["" + header.algorithm.getName() + ""]"");
      }

      verifySignature(verifier, header, parts[2], encodedJWT);
    }

    // Signature is valid or there is no signature to validate for an un-secured JWT, verify time based JWT claims
    JWT jwt = Mapper.deserialize(base64Decode(parts[1]), JWT.class);

    // Verify expiration claim
    if (jwt.isExpired()) {
      throw new JWTExpiredException();
    }

    // Verify the notBefore claim
    if (jwt.isUnavailableForProcessing()) {
      throw new JWTUnavailableForProcessingException();
    }

    return jwt;
  }

  /**
   * Verify the signature of the encoded JWT. If the signature is invalid a {@link InvalidJWTSignatureException} will be thrown.
   *
   * @param verifier   the verifier
   * @param header     the JWT header
   * @param signature  the JWT signature
   * @param encodedJWT the encoded JWT
   * @throws InvalidJWTSignatureException if the JWT signature is invalid.
   */
  private void verifySignature(Verifier verifier, Header header, String signature, String encodedJWT) {
    // The message comprises the first two segments of the entire JWT, the signature is the last segment.
    int index = encodedJWT.lastIndexOf(""."");
    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);

    byte[] signatureBytes = base64Decode(signature);
    verifier.verify(header.algorithm, message, signatureBytes);
  }
}"
"src/main/java/org/primeframework/jwt/JWTDecoder.java:[64,77]:decode","  public JWT decode(String encodedJWT, Verifier... verifiers) {
    Objects.requireNonNull(encodedJWT);
    Objects.requireNonNull(verifiers);

    String[] parts = getParts(encodedJWT);

    Header header = Mapper.deserialize(base64Decode(parts[0]), Header.class);
    Verifier verifier = Arrays.stream(verifiers).filter(v -> v.canVerify(header.algorithm)).findFirst().orElse(null);

    // The 'none' algorithm is only allowed when no verifiers are provided.
    boolean allowNoneAlgorithm = verifiers.length == 0;

    return validate(encodedJWT, parts, header, verifier, allowNoneAlgorithm);
  }
"
