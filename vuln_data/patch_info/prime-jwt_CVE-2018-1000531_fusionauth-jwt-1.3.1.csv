Fix_Path,Fix_Src
"src/main/java/org/primeframework/jwt/JWTDecoder.java:[41,234]:JWTDecoder","public class JWTDecoder {

  private static JWTDecoder instance;

  public static JWTDecoder getInstance() {
    if (instance == null) {
      instance = new JWTDecoder();
    }

    return instance;
  }

  /**
   * Decode the JWT using one of they provided verifiers. One more verifiers may be provided, the first verifier found
   * supporting the algorithm reported by the JWT header will be utilized.
   * <p>
   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link
   * JWTUnavailableForProcessingException} exception will be thrown respectively.
   *
   * @param encodedJWT The encoded JWT in string format.
   * @param verifiers  A map of verifiers.
   * @return a decoded JWT.
   */
  public JWT decode(String encodedJWT, Verifier... verifiers) {
    Objects.requireNonNull(encodedJWT);
    Objects.requireNonNull(verifiers);

    String[] parts = getParts(encodedJWT);

    Header header = Mapper.deserialize(base64Decode(parts[0]), Header.class);
    Verifier verifier = Arrays.stream(verifiers).filter(v -> v.canVerify(header.algorithm)).findFirst().orElse(null);

    // The 'none' algorithm is only allowed when no verifiers are provided.
    boolean allowNoneAlgorithm = verifiers.length == 0;

    return validate(encodedJWT, parts, header, verifier, allowNoneAlgorithm);
  }

  /**
   * Decode the JWT using one of they provided verifiers. A JWT header value named <code>kid</code> is expected to
   * contain the key to lookup the correct verifier.
   * <p>
   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link
   * JWTUnavailableForProcessingException} exception will be thrown respectively.
   *
   * @param encodedJWT The encoded JWT in string format.
   * @param verifiers  A map of verifiers.
   * @return a decoded JWT.
   */
  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers) {
    return decode(encodedJWT, verifiers, h -> h.get(""kid""));
  }

  /**
   * Decode the JWT using one of they provided verifiers. The key used to lookup the correct verifier is provided by the
   * <code>keyFunction</code>. The key function is provided the JWT header and is expected to return a string key to
   * look up the correct verifier.
   * <p>
   * A JWT that is expired or not yet valid will not be decoded, instead a {@link JWTExpiredException} or {@link
   * JWTUnavailableForProcessingException} exception will be thrown respectively.
   *
   * @param encodedJWT  The encoded JWT in string format.
   * @param verifiers   A map of verifiers.
   * @param keyFunction A function used to lookup the verifier key from the header.
   * @return a decoded JWT.
   */
  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers, Function<Header, String> keyFunction) {
    Objects.requireNonNull(encodedJWT);
    Objects.requireNonNull(verifiers);
    Objects.requireNonNull(keyFunction);

    String[] parts = getParts(encodedJWT);

    Header header = Mapper.deserialize(base64Decode(parts[0]), Header.class);
    String key = keyFunction.apply(header);
    Verifier verifier = verifiers.get(key);

    // The 'none' algorithm is only allowed when no verifiers are provided.
    boolean allowNoneAlgorithm = verifiers.isEmpty();

    return validate(encodedJWT, parts, header, verifier, allowNoneAlgorithm);
  }

  /**
   * Decode the provided base64 encoded string.
   *
   * @param string the input string to decode, it is expected to be a valid base64 encoded string.
   * @return a decoded byte array
   */
  private byte[] base64Decode(String string) {
    try {
      // Equal to calling : .decode(string.getBytes(StandardCharsets.ISO_8859_1))
      // If this is a properly base64 encoded string, decoding using ISO_8859_1 should be fine.
      return Base64.getUrlDecoder().decode(string);
    } catch (IllegalArgumentException e) {
      throw new InvalidJWTException(""The encoded JWT is not properly Base64 encoded."", e);
    }
  }

  /**
   * Split the encoded JWT on a period (.), and return the parts.
   * <p>
   * A secured JWT will be in the format : <code>XXXXX.YYYYY.ZZZZZ</code> and an un-secured JWT (no signature) will be in the format <code>XXXXX.YYYYY</code>.
   *
   * @param encodedJWT the encoded form of the JWT
   * @return an array of parts, 2 for an un-secured JWT, and 3 parts for a secured JWT.
   */
  private String[] getParts(String encodedJWT) {
    String[] parts = encodedJWT.split(""\\."");
    if (parts.length == 3 || (parts.length == 2 && encodedJWT.endsWith("".""))) {
      return parts;
    }

    throw new InvalidJWTException(""The encoded JWT is not properly formatted. Expected a three part dot separated string."");
  }

  /**
   * Validate the encoded JWT and return the constructed JWT object if valid.
   *
   * @param encodedJWT         the encoded JWT
   * @param parts              the parts of the encoded JWT
   * @param header             the JWT header
   * @param verifier           the selected JWT verifier
   * @param allowNoneAlgorithm true if un-secured JWTs may be decoded, i.e. 'none' algorithm is allowed
   * @return the constructed JWT object containing identity claims
   */
  private JWT validate(String encodedJWT, String[] parts, Header header, Verifier verifier, boolean allowNoneAlgorithm) {
    // When parts.length == 2, we have no signature.
    //  - Case 1: If one or more verifiers are provided, we will not decode an un-secured JWT. Throw NoneNotAllowedException
    //  - Case 2: If no verifiers are provided, we will decode an un-secured JWT, the algorithm must be 'none'.
    if (parts.length == 2) {
      if (!allowNoneAlgorithm) {
        throw new NoneNotAllowedException();
      }

      if (header.algorithm != Algorithm.none) {
        throw new MissingSignatureException(""Your provided a JWT with the algorithm ["" + header.algorithm.getName() + ""] but it is missing a signature"");
      }
    } else {
      // When parts.length == 3, we have a signature.
      // - Case 1: The algorithm in the header is 'none', we do not expect a signature.
      // - Case 2: No verifier was provided that can verify the algorithm in the header, or no verifier found by the kid in the header
      // - Case 3: The requested verifier cannot verify the signature based upon the algorithm value in the header
      if (header.algorithm == Algorithm.none) {
        throw new InvalidJWTException(""You provided a JWT with a signature and an algorithm of none"");
      }

      if (verifier == null) {
        throw new MissingVerifierException(""No Verifier has been provided for verify a signature signed using ["" + header.algorithm.getName() + ""]"");
      }

      // When the verifier has been selected based upon the 'kid' or other identifier in the header, we must verify it can verify the algorithm.
      // - When multiple verifiers are provided to .decode w/out a kid, we may have already called 'canVerify', this is ok.
      if (!verifier.canVerify(header.algorithm)) {
        throw new MissingVerifierException(""No Verifier has been provided for verify a signature signed using ["" + header.algorithm.getName() + ""]"");
      }

      verifySignature(verifier, header, parts[2], encodedJWT);
    }

    // Signature is valid or there is no signature to validate for an un-secured JWT, verify time based JWT claims
    JWT jwt = Mapper.deserialize(base64Decode(parts[1]), JWT.class);

    // Verify expiration claim
    if (jwt.isExpired()) {
      throw new JWTExpiredException();
    }

    // Verify the notBefore claim
    if (jwt.isUnavailableForProcessing()) {
      throw new JWTUnavailableForProcessingException();
    }

    return jwt;
  }

  /**
   * Verify the signature of the encoded JWT. If the signature is invalid a {@link InvalidJWTSignatureException} will be thrown.
   *
   * @param verifier   the verifier
   * @param header     the JWT header
   * @param signature  the JWT signature
   * @param encodedJWT the encoded JWT
   * @throws InvalidJWTSignatureException if the JWT signature is invalid.
   */
  private void verifySignature(Verifier verifier, Header header, String signature, String encodedJWT) {
    // The message comprises the first two segments of the entire JWT, the signature is the last segment.
    int index = encodedJWT.lastIndexOf(""."");
    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);

    byte[] signatureBytes = base64Decode(signature);
    verifier.verify(header.algorithm, message, signatureBytes);
  }
}"
"src/main/java/org/primeframework/jwt/JWTDecoder.java:[64,77]:decode","  public JWT decode(String encodedJWT, Verifier... verifiers) {
    Objects.requireNonNull(encodedJWT);
    Objects.requireNonNull(verifiers);

    String[] parts = getParts(encodedJWT);

    Header header = Mapper.deserialize(base64Decode(parts[0]), Header.class);
    Verifier verifier = Arrays.stream(verifiers).filter(v -> v.canVerify(header.algorithm)).findFirst().orElse(null);

    // The 'none' algorithm is only allowed when no verifiers are provided.
    boolean allowNoneAlgorithm = verifiers.length == 0;

    return validate(encodedJWT, parts, header, verifier, allowNoneAlgorithm);
  }
"
"src/test/java/org/primeframework/jwt/VulnerabilityTest.java:[40,141]:VulnerabilityTest","public class VulnerabilityTest extends BaseTest {

  @Test
  public void test_SignedWithoutSignature() throws Exception {
    JWT inputJwt = new JWT()
        .setSubject(""123456789"")
        .setIssuedAt(ZonedDateTime.now(ZoneOffset.UTC))
        .setExpiration(ZonedDateTime.now(ZoneOffset.UTC).plusHours(2));

    String encodedJWT = JWT.getEncoder().encode(inputJwt, HMACSigner.newSHA256Signer(""secret""));
    String encodedJWTNoSignature = encodedJWT.substring(0, encodedJWT.lastIndexOf('.') + 1);

    expectException(NoneNotAllowedException.class, () -> JWT.getDecoder().decode(encodedJWTNoSignature, HMACVerifier.newVerifier(""secret"")));

    // Also cannot be decoded even if the caller calls decode w/out a signature because the header still indicates a signature algorithm.
    expectException(MissingSignatureException.class, () -> JWT.getDecoder().decode(encodedJWTNoSignature));
  }

  @Test
  public void test_encodedJwtWithSignatureRemoved() throws Exception {
    // Sign a JWT and then attempt to verify it using None.
    JWT jwt = new JWT().setSubject(""art"");
    String encodedJWT = JWT.getEncoder().encode(jwt, HMACSigner.newSHA256Signer(""secret""));

    String hackedJWT = encodedJWT.substring(0, encodedJWT.lastIndexOf("".""));

    expectException(InvalidJWTException.class, () -> JWT.getDecoder().decode(hackedJWT, HMACVerifier.newVerifier(""secret"")));
  }

  @Test
  public void test_noVerification() throws Exception {
    // Sign a JWT and then attempt to verify it using None.
    JWT jwt = new JWT().setSubject(""art"");
    String encodedJWT = JWT.getEncoder().encode(jwt, HMACSigner.newSHA256Signer(""secret""));

    expectException(MissingVerifierException.class, () -> JWT.getDecoder().decode(encodedJWT));
  }

  @Test
  public void test_unsecuredJWT_validation() throws Exception {
    JWT jwt = new JWT().setSubject(""123456789"");
    Signer signer = new UnsecuredSigner();
    Verifier hmacVerifier = HMACVerifier.newVerifier(""too many secrets"");

    String encodedUnsecuredJWT = JWTEncoder.getInstance().encode(jwt, signer);

    // Ensure that attempting to decode an un-secured JWT fails when we provide a verifier
    expectException(NoneNotAllowedException.class, () -> JWT.getDecoder().decode(encodedUnsecuredJWT, hmacVerifier));

    String encodedUnsecuredJWT_withKid = JWTEncoder.getInstance().encode(jwt, signer, (header) -> header.set(""kid"", ""abc""));
    String encodedUnsecuredJWT_withoutKid = JWTEncoder.getInstance().encode(jwt, signer);

    Map<String, Verifier> verifierMap = new HashMap<>();
    verifierMap.put(null, hmacVerifier);
    verifierMap.put(""abc"", hmacVerifier);

    // Ensure that attempting to decode an un-secured JWT fails when we provide a verifier with or without using a kid
    expectException(NoneNotAllowedException.class, () -> JWT.getDecoder().decode(encodedUnsecuredJWT_withKid, verifierMap));
    expectException(NoneNotAllowedException.class, () -> JWT.getDecoder().decode(encodedUnsecuredJWT_withoutKid, verifierMap));
  }

  @Test
  public void test_vulnerability_HMAC_forgery() throws Exception {
    // Generate a JWT using HMAC with an RSA public key to attempt to trick the library into verifying the JWT

    // Testing for the vulnerability described by Tim McLean
    // https://threatpost.com/critical-vulnerabilities-affect-json-web-token-libraries/111943/
    // https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/

    JWT jwt = new JWT().setSubject(""123456789"");
    // Hacked signer, obtain a publicly available RSA Public Key in use by the JWT issuer
    Signer hackedSigner = HMACSigner.newSHA512Signer(new String(Files.readAllBytes(Paths.get(""src/test/resources/rsa_public_key_2048.pem""))));

    // Forged a JWT - sign your own token using the hacked Signer
    String hmacSignedJWT = JWTEncoder.getInstance().encode(jwt, hackedSigner, h -> h.set(""kid"", ""abc""));

    // Server side Verifiers used to validate JWTs they have issued
    Verifier rsaVerifier = RSAVerifier.newVerifier(new String(Files.readAllBytes(Paths.get(""src/test/resources/rsa_public_key_2048.pem""))));
    Verifier hmacVerifier = HMACVerifier.newVerifier(""secret"");

    // Attempt to decode using var-args call to decode, no kid. This correctly fails because we only ask the HMAC verifier to decode an HMAC signed JWT.
    // And the server has built an HMAC verifier using their shared secret.
    expectException(InvalidJWTSignatureException.class, () -> JWTDecoder.getInstance().decode(hmacSignedJWT, rsaVerifier, hmacVerifier));

    Map<String, Verifier> verifierMap = new HashMap<>();
    verifierMap.put(""abc"", rsaVerifier);
    verifierMap.put(""def"", hmacVerifier);

    // Attempt to decode using a map of verifiers. This correctly fails because the verifier for the kid does not support the algorithm in the header
    // The kid in this case causes us to look up the verifier built by the server which is an RSA verifier.
    expectException(MissingVerifierException.class, () -> JWTDecoder.getInstance().decode(hmacSignedJWT, verifierMap));

    // Forge another JWT - but assume we know ahead of time all of the kids and which one maps to the hmac verifier
    String hmacSignedJWTTakeTwo = JWTEncoder.getInstance().encode(jwt, hackedSigner, h -> h.set(""kid"", ""def""));

    // This call fails because we ask the HMAC verifier to validate a signature built using a public key.
    expectException(InvalidJWTSignatureException.class, () -> JWTDecoder.getInstance().decode(hmacSignedJWTTakeTwo, rsaVerifier, hmacVerifier));
    // This call fails because in this case we have the correct kid 'def' which is the hmac verifier - but again the verifier was not built with the public key.
    // The kid in this case causes us to look up the HMAC verifier which is what the hacker wants, but it again is already built using the correct shared secret.
    expectException(InvalidJWTSignatureException.class, () -> JWTDecoder.getInstance().decode(hmacSignedJWTTakeTwo, verifierMap));
  }
}
"
"src/test/java/org/primeframework/jwt/VulnerabilityTest.java:[59,67]:test_encodedJwtWithSignatureRemoved","  public void test_encodedJwtWithSignatureRemoved() throws Exception {
    // Sign a JWT and then attempt to verify it using None.
    JWT jwt = new JWT().setSubject(""art"");
    String encodedJWT = JWT.getEncoder().encode(jwt, HMACSigner.newSHA256Signer(""secret""));

    String hackedJWT = encodedJWT.substring(0, encodedJWT.lastIndexOf("".""));

    expectException(InvalidJWTException.class, () -> JWT.getDecoder().decode(hackedJWT, HMACVerifier.newVerifier(""secret"")));
  }
"
"src/test/java/org/primeframework/jwt/VulnerabilityTest.java:[70,76]:test_noVerification","  public void test_noVerification() throws Exception {
    // Sign a JWT and then attempt to verify it using None.
    JWT jwt = new JWT().setSubject(""art"");
    String encodedJWT = JWT.getEncoder().encode(jwt, HMACSigner.newSHA256Signer(""secret""));

    expectException(MissingVerifierException.class, () -> JWT.getDecoder().decode(encodedJWT));
  }
"
