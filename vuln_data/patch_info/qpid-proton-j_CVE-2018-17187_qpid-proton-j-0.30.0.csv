Fix_Path,Fix_Src
"proton-j/src/test/java/org/apache/qpid/proton/engine/impl/ssl/SimpleSslTransportWrapperTest.java:[48,475]:SimpleSslTransportWrapperTest","public class SimpleSslTransportWrapperTest
{
    private RememberingTransportInput _underlyingInput;
    private CannedTransportOutput _underlyingOutput;
    private SimpleSslTransportWrapper _sslWrapper;
    private CapitalisingDummySslEngine _dummySslEngine;

    @Rule
    public ExpectedException _expectedException = ExpectedException.none();

    @Before
    public void setUp()
    {
        _underlyingInput = new RememberingTransportInput();
        _underlyingOutput = new CannedTransportOutput();
        _dummySslEngine = new CapitalisingDummySslEngine();
        _sslWrapper = new SimpleSslTransportWrapper(_dummySslEngine, _underlyingInput, _underlyingOutput);
    }

    @Test
    public void testInputDecodesOnePacket()
    {
        String encodedBytes = ""<-A->"";

        putBytesIntoTransport(encodedBytes);

        assertEquals(""a_"", _underlyingInput.getAcceptedInput());
        assertEquals(CapitalisingDummySslEngine.MAX_ENCODED_CHUNK_SIZE, _sslWrapper.capacity());
        assertEquals(2, _dummySslEngine.getUnwrapCount());// 1 packet, 1 underflow
        assertEquals(1, _underlyingInput.getProcessCount());
    }

    /**
     * Note that this only feeds 1 encoded packet in at a time due to default settings of the dummy engine,
     * See {@link #testUnderlyingInputUsingSmallBuffer_receivesAllDecodedInputRequiringMultipleUnwraps}
     * for a related test that passes multiple encoded packets into the ssl wrapper at once.
     */
    @Test
    public void testInputWithMultiplePackets()
    {
        String encodedBytes = ""<-A-><-B-><-C-><>"";

        putBytesIntoTransport(encodedBytes);

        assertEquals(""a_b_c_z_"", _underlyingInput.getAcceptedInput());
        assertEquals(CapitalisingDummySslEngine.MAX_ENCODED_CHUNK_SIZE, _sslWrapper.capacity());
        assertEquals(8, _dummySslEngine.getUnwrapCount()); // (1 decode + 1 underflow) * 4 packets
        assertEquals(4, _underlyingInput.getProcessCount()); // 1 process per decoded packet
    }

    @Test
    public void testInputIncompletePacket_isNotPassedToUnderlyingInputUntilCompleted()
    {
        String incompleteEncodedBytes = ""<-A-><-B-><-C""; // missing the trailing '>' to cause the underflow
        String remainingEncodedBytes = ""-><-D->"";

        putBytesIntoTransport(incompleteEncodedBytes);
        assertEquals(""a_b_"", _underlyingInput.getAcceptedInput());
        assertEquals(5, _dummySslEngine.getUnwrapCount()); // 2 * (1 decode + 1 underflow) + 1 underflow
        assertEquals(2, _underlyingInput.getProcessCount()); // 1 process per decoded packet

        putBytesIntoTransport(remainingEncodedBytes);
        assertEquals(""a_b_c_d_"", _underlyingInput.getAcceptedInput());
        assertEquals(4, _underlyingInput.getProcessCount()); // earlier + 2
        assertEquals(9, _dummySslEngine.getUnwrapCount()); // Earlier + 2 * (1 decode + 1 underflow)
                                                           // due to way the bytes are fed in across
                                                           // boundary of encoded packets
    }

    /**
     * As per {@link #testInputIncompletePacket_isNotPassedToUnderlyingInputUntilCompleted()}
     * but this time it takes TWO chunks to complete the ""dangling"" packet.
     */
    @Test
    public void testInputIncompletePacketInThreeParts()
    {
        String firstEncodedBytes = ""<-A-><-B-><-"";
        String secondEncodedBytes = ""C""; // Sending this causes the impl to have to hold the data without producing more input yet
        String thirdEncodedBytes = ""-><-D->"";

        putBytesIntoTransport(firstEncodedBytes);
        assertEquals(""a_b_"", _underlyingInput.getAcceptedInput());
        assertEquals(5, _dummySslEngine.getUnwrapCount()); // 2 * (1 decode + 1 underflow) + 1 underflow
        assertEquals(2, _underlyingInput.getProcessCount()); // 1 process per decoded packet

        putBytesIntoTransport(secondEncodedBytes);
        assertEquals(""a_b_"", _underlyingInput.getAcceptedInput());
        assertEquals(6, _dummySslEngine.getUnwrapCount()); // earlier + 1 underflow
        assertEquals(2, _underlyingInput.getProcessCount()); // as earlier

        putBytesIntoTransport(thirdEncodedBytes);
        assertEquals(""a_b_c_d_"", _underlyingInput.getAcceptedInput());
        assertEquals(4, _underlyingInput.getProcessCount()); // 1 process per decoded packet
        assertEquals(10, _dummySslEngine.getUnwrapCount()); // Earlier + (decode + underflow) * 2
                                                           // due to way the bytes are fed in across
                                                           // boundary of encoded packets
    }

    /**
     * Tests that when a small underlying input buffer (1 byte here) is used, all of the encoded
     * data packet (5 bytes each here) can be processed despite multiple attempts being required to
     * pass the decoded bytes (2 bytes here) to the underlying input layer for processing.
     */
    @Test
    public void testUnderlyingInputUsingSmallBuffer_receivesAllDecodedInputRequiringMultipleUnderlyingProcesses()
    {
        int underlyingInputBufferSize = 1;
        int encodedPacketSize = 5;

        _underlyingInput.setInputBufferSize(underlyingInputBufferSize);
        assertEquals(""Unexpected underlying input capacity"", underlyingInputBufferSize, _underlyingInput.capacity());

        assertEquals(""Unexpected max encoded chunk size"", encodedPacketSize, CapitalisingDummySslEngine.MAX_ENCODED_CHUNK_SIZE);

        byte[] bytes = ""<-A-><-B->"".getBytes(StandardCharsets.UTF_8);
        ByteBuffer encodedByteSource = ByteBuffer.wrap(bytes);

        assertEquals(""Unexpected initial capacity"", encodedPacketSize, _sslWrapper.capacity());

        // Process the first 'encoded packet' (<-A->)
        int numberPoured = pour(encodedByteSource, _sslWrapper.tail());
        assertEquals(""Unexpected number of bytes poured into the wrapper input buffer"", encodedPacketSize, numberPoured);
        assertEquals(""Unexpected position in encoded source byte buffer"", encodedPacketSize * 1, encodedByteSource.position());
        assertEquals(""Unexpected capacity"", 0, _sslWrapper.capacity());
        _sslWrapper.process();
        assertEquals(""Unexpected capacity"", encodedPacketSize, _sslWrapper.capacity());

        assertEquals(""unexpected underlying output after first wrapper process"", ""a_"", _underlyingInput.getAcceptedInput());
        assertEquals(""unexpected underlying process count after first wrapper process"", 2 , _underlyingInput.getProcessCount());

        // Process the second 'encoded packet' (<-B->)
        numberPoured = pour(encodedByteSource, _sslWrapper.tail());
        assertEquals(""Unexpected number of bytes poured into the wrapper input buffer"", encodedPacketSize, numberPoured);
        assertEquals(""Unexpected position in encoded source byte buffer"", encodedPacketSize * 2, encodedByteSource.position());
        assertEquals(""Unexpected capacity"", 0, _sslWrapper.capacity());
        _sslWrapper.process();
        assertEquals(""Unexpected capacity"", encodedPacketSize, _sslWrapper.capacity());

        assertEquals(""unexpected underlying output after second wrapper process"", ""a_b_"", _underlyingInput.getAcceptedInput());
        assertEquals(""unexpected underlying process count after second wrapper process"", 4 , _underlyingInput.getProcessCount());
    }

    /**
     * Tests that when a small underlying input buffer (1 byte here) is used, all of the encoded
     * data packets (20 bytes total here) can be processed despite multiple unwraps being required
     * to process a given set of input (3 packets, 15 bytes here) and then as a result also multiple
     * attempts to pass the decoded packet (2 bytes here) to the underlying input layer for processing.
     */
    @Test
    public void testUnderlyingInputUsingSmallBuffer_receivesAllDecodedInputRequiringMultipleUnwraps()
    {
        int underlyingInputBufferSize = 1;
        int encodedPacketSize = 5;
        int sslEngineBufferSize = 15;

        assertEquals(""Unexpected max encoded chunk size"", encodedPacketSize, CapitalisingDummySslEngine.MAX_ENCODED_CHUNK_SIZE);

        _underlyingOutput = new CannedTransportOutput();
        _underlyingInput = new RememberingTransportInput();
        _underlyingInput.setInputBufferSize(underlyingInputBufferSize);
        assertEquals(""Unexpected underlying input capacity"", underlyingInputBufferSize, _underlyingInput.capacity());

        // Create a dummy ssl engine that has buffers that holds multiple encoded/decoded
        // packets, but still can't fit all of the input
        _dummySslEngine = new CapitalisingDummySslEngine();
        _dummySslEngine.setApplicationBufferSize(sslEngineBufferSize);
        _dummySslEngine.setPacketBufferSize(sslEngineBufferSize);

        _sslWrapper = new SimpleSslTransportWrapper(_dummySslEngine, _underlyingInput, _underlyingOutput);

        byte[] bytes = ""<-A-><-B-><-C-><-D->"".getBytes(StandardCharsets.UTF_8);
        ByteBuffer encodedByteSource = ByteBuffer.wrap(bytes);

        assertEquals(""Unexpected initial capacity"", sslEngineBufferSize, _sslWrapper.capacity());

        // Process the first three 'encoded packets' (<-A-><-B-><-C->). This will require 3 'proper' unwraps, and
        // as each decoded packet is 2 bytes, each of those will require 2 underlying input processes.
        int numberPoured = pour(encodedByteSource, _sslWrapper.tail());
        assertEquals(""Unexpected number of bytes poured into the wrapper input buffer"", sslEngineBufferSize, numberPoured);
        assertEquals(""Unexpected position in encoded source byte buffer"", encodedPacketSize * 3, encodedByteSource.position());
        assertEquals(""Unexpected capacity"", 0, _sslWrapper.capacity());

        _sslWrapper.process();

        assertEquals(""a_b_c_"", _underlyingInput.getAcceptedInput());
        assertEquals(""Unexpected capacity"", sslEngineBufferSize, _sslWrapper.capacity());
        assertEquals(""unexpected underlying process count after wrapper process"", 6 , _underlyingInput.getProcessCount());
        assertEquals(4, _dummySslEngine.getUnwrapCount()); // 3 decodes + 1 underflow

        // Process the fourth 'encoded packet' (<-D->)
        numberPoured = pour(encodedByteSource, _sslWrapper.tail());
        assertEquals(""Unexpected number of bytes poured into the wrapper input buffer"", encodedPacketSize, numberPoured);
        assertEquals(""Unexpected position in encoded source byte buffer"", encodedPacketSize * 4, encodedByteSource.position());
        assertEquals(""Unexpected capacity"", sslEngineBufferSize - encodedPacketSize, _sslWrapper.capacity());

        _sslWrapper.process();

        assertEquals(""a_b_c_d_"", _underlyingInput.getAcceptedInput());
        assertEquals(""Unexpected capacity"", sslEngineBufferSize, _sslWrapper.capacity());
        assertEquals(""unexpected underlying process count after second wrapper process"", 8 , _underlyingInput.getProcessCount());
        assertEquals(6, _dummySslEngine.getUnwrapCount()); // earlier + 1 decode + 1 underflow
    }

    /**
     * Tests that an exception is thrown when the underlying input has zero capacity when the call
     * with newly decoded input is initially made.
     */
    @Test (timeout = 5000)
    public void testUnderlyingInputHasZeroCapacityInitially()
    {
        int underlyingInputBufferSize = 1;
        int encodedPacketSize = 5;

        assertEquals(""Unexpected max encoded chunk size"", encodedPacketSize, CapitalisingDummySslEngine.MAX_ENCODED_CHUNK_SIZE);

        // Set the input to have a small buffer, but then return 0 from the 2nd capacity call onward.
        _underlyingInput.setInputBufferSize(underlyingInputBufferSize);
        _underlyingInput.setZeroCapacityAtCount(2);
        assertEquals(""Unexpected initial underlying input capacity"", underlyingInputBufferSize, _underlyingInput.capacity());
        assertEquals(""Unexpected underlying input capacity"", 0, _underlyingInput.capacity());

        // Now try decoding the input, should fail
        byte[] bytes = ""<-A->"".getBytes(StandardCharsets.UTF_8);
        ByteBuffer encodedByteSource = ByteBuffer.wrap(bytes);

        assertEquals(""Unexpected initial wrapper capacity"", encodedPacketSize, _sslWrapper.capacity());

        int numberPoured = pour(encodedByteSource, _sslWrapper.tail());
        assertEquals(""Unexpected number of bytes poured into the wrapper input buffer"", encodedPacketSize, numberPoured);
        assertEquals(""Unexpected position in encoded source byte buffer"", encodedPacketSize, encodedByteSource.position());
        assertEquals(""Unexpected wrapper capacity"", 0, _sslWrapper.capacity());

        try
        {
            _sslWrapper.process();
            fail(""Expected an exception"");
        }
        catch (TransportException te)
        {
            // expected.
        }

        //Check we got no chars of decoded output.
        assertEquals("""", _underlyingInput.getAcceptedInput());
        assertEquals(""Unexpected wrapper capacity"", -1, _sslWrapper.capacity());
        assertEquals(""unexpected underlying process count after wrapper process"", 0 , _underlyingInput.getProcessCount());
        assertEquals(""unexpected underlying capacity count after wrapper process"", 3, _underlyingInput.getCapacityCount());
        assertEquals(""unexpected underlying capacity after wrapper process"", 0 , _underlyingInput.capacity());
        assertEquals(1, _dummySslEngine.getUnwrapCount()); // 1 decode (then exception)
    }

    /**
     * Tests that an exception is thrown when the underlying input has no capacity (but isn't closed)
     * during the process of incrementally passing the decoded bytes to its smaller input buffer
     * for processing.
     */
    @Test (timeout = 5000)
    public void testUnderlyingInputHasZeroCapacityMidProcessing()
    {
        int underlyingInputBufferSize = 1;
        int encodedPacketSize = 5;

        assertEquals(""Unexpected max encoded chunk size"", encodedPacketSize, CapitalisingDummySslEngine.MAX_ENCODED_CHUNK_SIZE);

        // Set the input to have a small buffer, but then return 0 from the 3rd capacity call onward.
        _underlyingInput.setInputBufferSize(underlyingInputBufferSize);
        _underlyingInput.setZeroCapacityAtCount(3);
        assertEquals(""Unexpected initial underlying input capacity"", underlyingInputBufferSize, _underlyingInput.capacity());

        // Now try decoding the input, should fail
        byte[] bytes = ""<-A->"".getBytes(StandardCharsets.UTF_8);
        ByteBuffer encodedByteSource = ByteBuffer.wrap(bytes);

        assertEquals(""Unexpected initial wrapper capacity"", encodedPacketSize, _sslWrapper.capacity());

        int numberPoured = pour(encodedByteSource, _sslWrapper.tail());
        assertEquals(""Unexpected number of bytes poured into the wrapper input buffer"", encodedPacketSize, numberPoured);
        assertEquals(""Unexpected position in encoded source byte buffer"", encodedPacketSize, encodedByteSource.position());
        assertEquals(""Unexpected wrapper capacity"", 0, _sslWrapper.capacity());

        try
        {
            _sslWrapper.process();
            fail(""Expected an exception"");
        }
        catch (TransportException te)
        {
            // expected.
        }

        //Check we got the first char (a) of decoded output, but not the second (_).
        assertEquals(""a"", _underlyingInput.getAcceptedInput());
        assertEquals(""Unexpected wrapper capacity"", -1, _sslWrapper.capacity());
        assertEquals(""unexpected underlying process count after wrapper process"", 1 , _underlyingInput.getProcessCount());
        assertEquals(""unexpected underlying capacity count after wrapper process"", 3, _underlyingInput.getCapacityCount());
        assertEquals(""unexpected underlying capacity after wrapper process"", 0 , _underlyingInput.capacity());
        assertEquals(1, _dummySslEngine.getUnwrapCount()); // 1 decode (then exception)
    }

    @Test
    public void testSslUnwrapThrowsException_returnsErrorResultAndRefusesFurtherInput() throws Exception
    {
        String unwrapExceptionMessage = ""unwrap exception message"";
        SSLException sslException = new SSLException(unwrapExceptionMessage);
        _dummySslEngine.rejectNextEncodedPacket(sslException);

        _sslWrapper.tail().put(""<-A->"".getBytes(StandardCharsets.UTF_8));
        try {
            _sslWrapper.process();
            fail(""no exception"");
        } catch(TransportException e) {
            assertEquals(""javax.net.ssl.SSLException: "" + unwrapExceptionMessage, e.getMessage());
        }

        assertEquals(Transport.END_OF_STREAM, _sslWrapper.capacity());
    }

    @Test
    public void testUnderlyingInputReturnsErrorResult_returnsErrorResultAndRefusesFurtherInput() throws Exception
    {
        String underlyingErrorDescription = ""dummy underlying error"";
        _underlyingInput.rejectNextInput(underlyingErrorDescription);

        _sslWrapper.tail().put(""<-A->"".getBytes(StandardCharsets.UTF_8));

        try {
            _sslWrapper.process();
            fail(""no exception"");
        } catch (TransportException e) {
            assertEquals(underlyingErrorDescription, e.getMessage());
        }
    }

    @Test
    public void testHeadIsReadOnly()
    {
        _underlyingOutput.setOutput("""");
        assertTrue(_sslWrapper.head().isReadOnly());
    }

    @Test
    public void testOutputEncodesOnePacket()
    {
        _underlyingOutput.setOutput(""a_"");

        ByteBuffer outputBuffer = _sslWrapper.head();

        assertByteBufferContentEquals(""<-A->"".getBytes(StandardCharsets.UTF_8), outputBuffer);
    }

    @Test
    public void testOutputEncodesMultiplePackets()
    {
        _underlyingOutput.setOutput(""a_b_c_"");

        assertEquals(""<-A-><-B-><-C->"", getAllBytesFromTransport());
    }

    @Test
    public void testOutputEncodesMultiplePacketsOfVaryingSize()
    {
        _underlyingOutput.setOutput(""z_a_b_"");

        assertEquals(""<><-A-><-B->"", getAllBytesFromTransport());
    }

    @Test
    public void testClientConsumesEncodedOutputInMultipleChunks()
    {
        _underlyingOutput.setOutput(""a_b_"");

        {
            ByteBuffer buffer = _sslWrapper.head();
            String output = pourBufferToString(buffer, 2);
            assertEquals(""<-"", output);
            _sslWrapper.pop(buffer.position());
        }

        {
            ByteBuffer buffer = _sslWrapper.head();
            String output = pourBufferToString(buffer, 3);
            assertEquals(""A->"", output);
            _sslWrapper.pop(buffer.position());
        }

        assertEquals(""<-B->"", getAllBytesFromTransport());
    }

    @Test
    public void testNoOutputToEncode()
    {
        _underlyingOutput.setOutput("""");

        assertFalse(_sslWrapper.head().hasRemaining());
    }

    private void putBytesIntoTransport(String encodedBytes)
    {
        ByteBuffer byteBuffer = ByteBuffer.wrap(encodedBytes.getBytes(StandardCharsets.UTF_8));
        while(byteBuffer.hasRemaining())
        {
            int numberPoured = pour(byteBuffer, _sslWrapper.tail());
            assertTrue(""We should be able to pour some bytes into the input buffer"",
                    numberPoured > 0);
            _sslWrapper.process();
        }
    }

    private String getAllBytesFromTransport()
    {
        StringBuilder readBytes = new StringBuilder();
        while (true)
        {
            int pending = _sslWrapper.pending();
            if (pending > 0) {
                ByteBuffer buffer = _sslWrapper.head();
                readBytes.append(pourBufferToString(buffer));
                _sslWrapper.pop(pending);
                continue;
            } else {
                break;
            }
        }

        return readBytes.toString();
    }

}
"
"proton-j/src/test/java/org/apache/qpid/proton/engine/impl/ssl/SimpleSslTransportWrapperTest.java:[348,363]:testSslUnwrapThrowsException_returnsErrorResultAndRefusesFurtherInput","    public void testSslUnwrapThrowsException_returnsErrorResultAndRefusesFurtherInput() throws Exception
    {
        String unwrapExceptionMessage = ""unwrap exception message"";
        SSLException sslException = new SSLException(unwrapExceptionMessage);
        _dummySslEngine.rejectNextEncodedPacket(sslException);

        _sslWrapper.tail().put(""<-A->"".getBytes(StandardCharsets.UTF_8));
        try {
            _sslWrapper.process();
            fail(""no exception"");
        } catch(TransportException e) {
            assertEquals(""javax.net.ssl.SSLException: "" + unwrapExceptionMessage, e.getMessage());
        }

        assertEquals(Transport.END_OF_STREAM, _sslWrapper.capacity());
    }
"
"proton-j/src/main/java/org/apache/qpid/proton/engine/impl/ssl/SimpleSslTransportWrapper.java:[74,96]:SimpleSslTransportWrapper","    SimpleSslTransportWrapper(ProtonSslEngine sslEngine, TransportInput underlyingInput, TransportOutput underlyingOutput)
    {
        _underlyingInput = underlyingInput;
        _underlyingOutput = underlyingOutput;
        _sslEngine = sslEngine;

        int effectiveAppBufferMax = _sslEngine.getEffectiveApplicationBufferSize();
        int packetSize = _sslEngine.getPacketBufferSize();

        // Input and output buffers need to be large enough to contain one SSL packet,
        // as stated in SSLEngine JavaDoc.
        _inputBuffer = newWriteableBuffer(packetSize);
        _outputBuffer = newWriteableBuffer(packetSize);
        _head = _outputBuffer.asReadOnlyBuffer();
        _head.limit(0);

        _decodedInputBuffer = newWriteableBuffer(effectiveAppBufferMax);

        if(_logger.isLoggable(Level.FINE))
        {
            _logger.fine(""Constructed "" + this);
        }
    }
"
"proton-j/src/main/java/org/apache/qpid/proton/engine/impl/ssl/SimpleSslTransportWrapper.java:[354,375]:process","    public void process() throws TransportException
    {
        if (_tail_closed) throw new TransportException(""tail closed"");

        _inputBuffer.flip();

        try {
            unwrapInput();
        } catch (SSLException e) {
            if(_logger.isLoggable(Level.FINEST)){
                _logger.log(Level.FINEST, e.getMessage(), e);
            } else {
                _logger.log(Level.WARNING, e.getMessage());
            }
            _inputBuffer.position(_inputBuffer.limit());
            _tail_closed = true;

            throw new TransportException(e);
        } finally {
            _inputBuffer.compact();
        }
    }
"
"proton-j/src/main/java/org/apache/qpid/proton/engine/impl/ssl/SslImpl.java:[53,66]:SslImpl","    public SslImpl(SslDomain domain, SslPeerDetails peerDetails)
    {
        _domain = domain;
        _protonSslEngineProvider = (ProtonSslEngineProvider)domain;
        _peerDetails = peerDetails;

        if(_domain.getMode() == null) {
            throw new IllegalStateException(""Client/server mode must be configured, SslDomain must have init called."");
        }

        if(_peerDetails == null && _domain.getPeerAuthentication() == VerifyMode.VERIFY_PEER_NAME) {
            throw new IllegalArgumentException(""Peer hostname verification is enabled, but no peer details were provided"");
        }
    }
"
"proton-j/src/main/java/org/apache/qpid/proton/reactor/impl/IOHandler.java:[221,250]:Callback","    private static Callback connectionReadable = new Callback() {
        @Override
        public void run(Selectable selectable) {
            Reactor reactor = selectable.getReactor();
            Transport transport = ((SelectableImpl)selectable).getTransport();
            int capacity = transport.capacity();
            if (capacity > 0) {
                SocketChannel socketChannel = (SocketChannel)selectable.getChannel();
                try {
                    int n = socketChannel.read(transport.tail());
                    if (n == -1) {
                        transport.close_tail();
                    } else {
                        transport.process();
                    }
                } catch (IOException | TransportException e) {
                    ErrorCondition condition = new ErrorCondition();
                    condition.setCondition(Symbol.getSymbol(""proton:io""));
                    condition.setDescription(e.getMessage());
                    transport.setCondition(condition);
                    transport.close_tail();
                }
            }
            // (Comment from C code:) occasionally transport events aren't
            // generated when expected, so the following hack ensures we
            // always update the selector
            update(selectable);
            reactor.update(selectable);
        }
    };
"
"proton-j/src/main/java/org/apache/qpid/proton/engine/impl/ssl/SslEngineFacadeFactory.java:[65,629]:SslEngineFacadeFactory","public class SslEngineFacadeFactory
{
    private static final Logger _logger = Logger.getLogger(SslEngineFacadeFactory.class.getName());

    /**
     * The protocol name used to create an {@link SSLContext}, taken from Java's list of
     * standard names at http://docs.oracle.com/javase/6/docs/technotes/guides/security/StandardNames.html
     *
     * TODO allow the protocol name to be overridden somehow
     */
    private static final String TLS_PROTOCOL = ""TLS"";

    // BouncyCastle Reflection Helpers
    private static final Constructor<?> pemParserCons;
    private static final Method         pemReadMethod;

    private static final Constructor<?> JcaPEMKeyConverterCons;
    private static final Class<?>       PEMKeyPairClass;
    private static final Method         getKeyPairMethod;
    private static final Method         getPrivateKeyMethod;

    private static final Class<?>       PEMEncryptedKeyPairClass;
    private static final Method         decryptKeyPairMethod;

    private static final Constructor<?> JcePEMDecryptorProviderBuilderCons;
    private static final Method         builderMethod;

    private static final Class<?>       PrivateKeyInfoClass;
    private static final Exception      bouncyCastleSetupException;

    static
    {
        // Setup BouncyCastle Reflection artifacts
        Constructor<?> pemParserConsResult = null;
        Method         pemReadMethodResult = null;
        Constructor<?> JcaPEMKeyConverterConsResult = null;
        Class<?>       PEMKeyPairClassResult = null;
        Method         getKeyPairMethodResult = null;
        Method         getPrivateKeyMethodResult = null;
        Class<?>       PEMEncryptedKeyPairClassResult = null;
        Method         decryptKeyPairMethodResult = null;
        Constructor<?> JcePEMDecryptorProviderBuilderConsResult = null;
        Method         builderMethodResult = null;
        Class<?>       PrivateKeyInfoClassResult = null;
        Exception      bouncyCastleSetupExceptionResult = null;

        try
        {
            final Class<?> pemParserClass = Class.forName(""org.bouncycastle.openssl.PEMParser"");
            pemParserConsResult = pemParserClass.getConstructor(Reader.class);
            pemReadMethodResult = pemParserClass.getMethod(""readObject"");

            final Class<?> jcaPEMKeyConverterClass = Class.forName(""org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter"");
            JcaPEMKeyConverterConsResult = jcaPEMKeyConverterClass.getConstructor();
            PEMKeyPairClassResult = Class.forName(""org.bouncycastle.openssl.PEMKeyPair"");
            getKeyPairMethodResult = jcaPEMKeyConverterClass.getMethod(""getKeyPair"", PEMKeyPairClassResult);

            final Class<?> PEMDecrypterProvider = Class.forName(""org.bouncycastle.openssl.PEMDecryptorProvider"");

            PEMEncryptedKeyPairClassResult = Class.forName(""org.bouncycastle.openssl.PEMEncryptedKeyPair"");
            decryptKeyPairMethodResult = PEMEncryptedKeyPairClassResult.getMethod(""decryptKeyPair"", PEMDecrypterProvider);

            final Class<?> jcePEMDecryptorProviderBuilderClass = Class.forName(
                    ""org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder"");
            JcePEMDecryptorProviderBuilderConsResult = jcePEMDecryptorProviderBuilderClass.getConstructor();
            builderMethodResult = jcePEMDecryptorProviderBuilderClass.getMethod(""build"", char[].class);

            PrivateKeyInfoClassResult = Class.forName(""org.bouncycastle.asn1.pkcs.PrivateKeyInfo"");
            getPrivateKeyMethodResult = jcaPEMKeyConverterClass.getMethod(""getPrivateKey"", PrivateKeyInfoClassResult);

            registerBouncyCastleProvider();
        }
        catch (Exception e)
        {
            bouncyCastleSetupExceptionResult = e;
        }
        finally {
            pemParserCons = pemParserConsResult;
            pemReadMethod = pemReadMethodResult;
            JcaPEMKeyConverterCons = JcaPEMKeyConverterConsResult;
            PEMKeyPairClass = PEMKeyPairClassResult;
            getKeyPairMethod = getKeyPairMethodResult;
            getPrivateKeyMethod = getPrivateKeyMethodResult;
            PEMEncryptedKeyPairClass = PEMEncryptedKeyPairClassResult;
            decryptKeyPairMethod = decryptKeyPairMethodResult;
            JcePEMDecryptorProviderBuilderCons = JcePEMDecryptorProviderBuilderConsResult;
            builderMethod = builderMethodResult;
            PrivateKeyInfoClass = PrivateKeyInfoClassResult;
            bouncyCastleSetupException = bouncyCastleSetupExceptionResult;
        }
    }

    static void registerBouncyCastleProvider()
            throws ClassNotFoundException, InstantiationException, IllegalAccessException,
                   InvocationTargetException, NoSuchMethodException
    {
        // Try loading BC as a provider
        Class<?> klass = Class.forName(""org.bouncycastle.jce.provider.BouncyCastleProvider"");

        Provider bouncyCastleProvider = (Provider) klass.getConstructor().newInstance();
        synchronized (Security.class)
        {
            if(Security.getProvider(bouncyCastleProvider.getName()) == null)
            {
                Security.addProvider(bouncyCastleProvider);
            }
        }
    }

    SslEngineFacadeFactory()
    {
    }

    /**
     * This is a list of all anonymous cipher suites supported by Java 6, excluding those that
     * use MD5.  These are all supported by both Oracle's and IBM's Java 6 implementation.
     */
    private static final List<String> ANONYMOUS_CIPHER_SUITES = Arrays.asList(
            ""TLS_DH_anon_WITH_AES_128_CBC_SHA"",
            ""SSL_DH_anon_WITH_3DES_EDE_CBC_SHA"",
            ""SSL_DH_anon_WITH_DES_CBC_SHA"",
            ""SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA"");

    /** lazily initialized */
    private SSLContext _sslContext;


    /**
     * Returns a {@link ProtonSslEngine}. May cache the domain's settings so callers should invoke
     * {@link #resetCache()} if the domain changes.
     *
     * @param peerDetails may be used to return an engine that supports SSL resume.
     */
    public ProtonSslEngine createProtonSslEngine(SslDomain domain, SslPeerDetails peerDetails)
    {
        SSLEngine engine = createAndInitialiseSslEngine(domain, peerDetails);
        if(_logger.isLoggable(Level.FINE))
        {
            _logger.fine(""Created SSL engine: "" + engineToString(engine));
        }
        return new DefaultSslEngineFacade(engine);
    }


    /**
     * Guarantees that no cached settings are used in subsequent calls to
     * {@link #createProtonSslEngine(SslDomain, SslPeerDetails)}.
     */
    public void resetCache()
    {
        _sslContext = null;
    }


    private SSLEngine createAndInitialiseSslEngine(SslDomain domain, SslPeerDetails peerDetails)
    {
        SslDomain.Mode mode = domain.getMode();

        SSLContext sslContext = getOrCreateSslContext(domain);
        SSLEngine sslEngine = createSslEngine(sslContext, peerDetails);

        if (domain.getPeerAuthentication() == SslDomain.VerifyMode.ANONYMOUS_PEER)
        {
            addAnonymousCipherSuites(sslEngine);
        }
        else
        {
            if (mode == SslDomain.Mode.SERVER)
            {
                sslEngine.setNeedClientAuth(true);
            }

            if(domain.getPeerAuthentication() == SslDomain.VerifyMode.VERIFY_PEER_NAME)
            {
                SSLParameters sslParameters = sslEngine.getSSLParameters();
                sslParameters.setEndpointIdentificationAlgorithm(""HTTPS"");
                sslEngine.setSSLParameters(sslParameters);
            }
        }

        if(_logger.isLoggable(Level.FINE))
        {
            _logger.log(Level.FINE, mode + "" Enabled cipher suites "" + Arrays.asList(sslEngine.getEnabledCipherSuites()));
        }

        boolean useClientMode = mode == SslDomain.Mode.CLIENT;
        sslEngine.setUseClientMode(useClientMode);

        removeSSLv3Support(sslEngine);

        return sslEngine;
    }

    private static final String SSLV3_PROTOCOL = ""SSLv3"";

    private static void removeSSLv3Support(final SSLEngine engine)
    {
        List<String> enabledProtocols = Arrays.asList(engine.getEnabledProtocols());
        if(enabledProtocols.contains(SSLV3_PROTOCOL))
        {
            List<String> allowedProtocols = new ArrayList<String>(enabledProtocols);
            allowedProtocols.remove(SSLV3_PROTOCOL);
            engine.setEnabledProtocols(allowedProtocols.toArray(new String[allowedProtocols.size()]));
        }
    }

    /**
     * @param sslPeerDetails is allowed to be null. A non-null value is used to hint that SSL resumption
     * should be attempted
     */
    private SSLEngine createSslEngine(SSLContext sslContext, SslPeerDetails sslPeerDetails)
    {
        final SSLEngine sslEngine;
        if(sslPeerDetails == null)
        {
            sslEngine = sslContext.createSSLEngine();
        }
        else
        {
            sslEngine = sslContext.createSSLEngine(sslPeerDetails.getHostname(), sslPeerDetails.getPort());
        }
        return sslEngine;
    }

    private SSLContext getOrCreateSslContext(SslDomain sslDomain)
    {
        if(_sslContext == null && sslDomain.getSslContext() != null)
        {
            _sslContext = sslDomain.getSslContext();
        }
        else if(_sslContext == null)
        {
            if(_logger.isLoggable(Level.FINE))
            {
                _logger.fine(""lazily creating new SSLContext using domain "" + sslDomain);
            }

            final char[] dummyPassword = ""unused-passphrase"".toCharArray(); // Dummy password required by KeyStore and KeyManagerFactory, but never referred to again

            try
            {
                SSLContext sslContext = SSLContext.getInstance(TLS_PROTOCOL);
                KeyStore ksKeys = createKeyStoreFrom(sslDomain, dummyPassword);

                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
                kmf.init(ksKeys, dummyPassword);

                final TrustManager[] trustManagers;
                if (sslDomain.getPeerAuthentication() == SslDomain.VerifyMode.ANONYMOUS_PEER)
                {
                    trustManagers = new TrustManager[] { new AlwaysTrustingTrustManager() };
                }
                else
                {
                    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                    tmf.init(ksKeys);
                    trustManagers = tmf.getTrustManagers();
                }

                sslContext.init(kmf.getKeyManagers(), trustManagers, null);
                _sslContext = sslContext;
            }
            catch (NoSuchAlgorithmException e)
            {
                throw new TransportException(""Unexpected exception creating SSLContext"", e);
            }
            catch (KeyStoreException e)
            {
                throw new TransportException(""Unexpected exception creating SSLContext"", e);
            }
            catch (UnrecoverableKeyException e)
            {
                throw new TransportException(""Unexpected exception creating SSLContext"", e);
            }
            catch (KeyManagementException e)
            {
                throw new TransportException(""Unexpected exception creating SSLContext"", e);
            }
        }
        return _sslContext;
    }

    private KeyStore createKeyStoreFrom(SslDomain sslDomain, char[] dummyPassword)
    {
        try
        {
            KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());
            keystore.load(null, null);

            if (sslDomain.getTrustedCaDb() != null)
            {
                String caCertAlias = ""cacert"";

                if(_logger.isLoggable(Level.FINE))
                {
                    _logger.log(Level.FINE, ""_sslParams.getTrustedCaDb() : "" + sslDomain.getTrustedCaDb());
                }
                int i = 1;
                for(Certificate trustedCaCert : readCertificates(sslDomain.getTrustedCaDb()))
                {
                    keystore.setCertificateEntry(caCertAlias + (i++), trustedCaCert);
                }
            }

            if (sslDomain.getCertificateFile() != null
                    && sslDomain.getPrivateKeyFile() != null)
            {
                String clientPrivateKeyAlias = ""clientPrivateKey"";

                Certificate clientCertificate = (Certificate) readCertificate(sslDomain.getCertificateFile());
                PrivateKey clientPrivateKey = readPrivateKey(sslDomain.getPrivateKeyFile(), sslDomain.getPrivateKeyPassword());

                keystore.setKeyEntry(clientPrivateKeyAlias, clientPrivateKey,
                        dummyPassword, new Certificate[] { clientCertificate });
            }

            return keystore;
        }
        catch (KeyStoreException e)
        {
           throw new TransportException(""Unexpected exception creating keystore"", e);
        }
        catch (NoSuchAlgorithmException e)
        {
            throw new TransportException(""Unexpected exception creating keystore"", e);
        }
        catch (CertificateException e)
        {
            throw new TransportException(""Unexpected exception creating keystore"", e);
        }
        catch (IOException e)
        {
            throw new TransportException(""Unexpected exception creating keystore"", e);
        }
    }

    private void addAnonymousCipherSuites(SSLEngine sslEngine)
    {
        List<String> supportedSuites = Arrays.asList(sslEngine.getSupportedCipherSuites());
        List<String> currentEnabledSuites = Arrays.asList(sslEngine.getEnabledCipherSuites());

        List<String> enabledSuites = buildEnabledSuitesIncludingAnonymous(ANONYMOUS_CIPHER_SUITES, supportedSuites, currentEnabledSuites);
        sslEngine.setEnabledCipherSuites(enabledSuites.toArray(new String[0]));
    }

    private List<String> buildEnabledSuitesIncludingAnonymous(
            List<String> anonymousCipherSuites, List<String> supportedSuites, List<String> currentEnabled)
    {
        List<String> newEnabled = new ArrayList<String>(currentEnabled);

        int addedAnonymousCipherSuites = 0;
        for (String anonymousCipherSuiteName : anonymousCipherSuites)
        {
            if (supportedSuites.contains(anonymousCipherSuiteName))
            {
                newEnabled.add(anonymousCipherSuiteName);
                addedAnonymousCipherSuites++;
            }
        }

        if (addedAnonymousCipherSuites > 0 && _logger.isLoggable(Level.FINE))
        {
            _logger.fine(""There are now "" + newEnabled.size()
                    + "" cipher suites enabled (previously "" + currentEnabled.size()
                    + ""), including "" + addedAnonymousCipherSuites + "" out of the ""
                    + anonymousCipherSuites.size() + "" requested anonymous ones."" );
        }

        return newEnabled;
    }

    private String engineToString(SSLEngine engine)
    {
        return new StringBuilder(""[ "" )
            .append(engine)
            .append("", needClientAuth="").append(engine.getNeedClientAuth())
            .append("", useClientMode="").append(engine.getUseClientMode())
            .append("", peerHost="").append(engine.getPeerHost())
            .append("", peerPort="").append(engine.getPeerPort())
            .append("" ]"").toString();
    }

    Certificate readCertificate(String pemFile)
    {
        InputStream is = null;

        try
        {
            CertificateFactory cFactory = CertificateFactory.getInstance(""X.509"");
            is = new FileInputStream(pemFile);
            return cFactory.generateCertificate(is);
        }
        catch (CertificateException ce)
        {
            String msg = ""Failed to load certificate ["" + pemFile + ""]"";
            _logger.log(Level.SEVERE, msg, ce);
            throw new TransportException(msg, ce);
        }
        catch (FileNotFoundException e)
        {
            String msg = ""Certificate file not found ["" + pemFile + ""]"";
            _logger.log(Level.SEVERE, msg);
            throw new TransportException(msg, e);
        }
        finally
        {
            closeSafely(is);
        }
    }

    Collection<? extends Certificate> readCertificates(String pemFile)
    {
        InputStream is = null;

        try
        {
            CertificateFactory cFactory = CertificateFactory.getInstance(""X.509"");
            is = new FileInputStream(pemFile);
            return cFactory.generateCertificates(is);
        }
        catch (CertificateException ce)
        {
            String msg = ""Failed to load certificates ["" + pemFile + ""]"";
            _logger.log(Level.SEVERE, msg, ce);
            throw new TransportException(msg, ce);
        }
        catch (FileNotFoundException e)
        {
            String msg = ""Certificates file not found ["" + pemFile + ""]"";
            _logger.log(Level.SEVERE, msg);
            throw new TransportException(msg, e);
        }
        finally
        {
            closeSafely(is);
        }
    }


    PrivateKey readPrivateKey(String pemFile, String password)
    {
        if (bouncyCastleSetupException != null)
        {
            throw new TransportException(""BouncyCastle failed to load"", bouncyCastleSetupException);
        }

        final Object pemObject = readPemObject(pemFile);
        PrivateKey privateKey = null;

        try
        {
            Object keyConverter = JcaPEMKeyConverterCons.newInstance();
            setProvider(keyConverter, ""BC"");

            if (PEMEncryptedKeyPairClass.isInstance(pemObject))
            {
                Object decryptorBuilder = JcePEMDecryptorProviderBuilderCons.newInstance();

                // Build a PEMDecryptProvider
                Object decryptProvider = builderMethod.invoke(decryptorBuilder, password.toCharArray());

                Object decryptedKeyPair = decryptKeyPairMethod.invoke(pemObject, decryptProvider);
                KeyPair keyPair = (KeyPair) getKeyPairMethod.invoke(keyConverter, decryptedKeyPair);

                privateKey = keyPair.getPrivate();
            }
            else if (PEMKeyPairClass.isInstance(pemObject))
            {
                // It's a KeyPair but not encrypted.
                KeyPair keyPair = (KeyPair) getKeyPairMethod.invoke(keyConverter, pemObject);
                privateKey = keyPair.getPrivate();
            }
            else if (PrivateKeyInfoClass.isInstance(pemObject))
            {
                // It's an unencrypted private key
                privateKey = (PrivateKey) getPrivateKeyMethod.invoke(keyConverter, pemObject);
            }
            else
            {
                final String msg = ""Unable to load PrivateKey, Unpexected Object ["" + pemObject.getClass().getName()
                        + ""]"";
                _logger.log(Level.SEVERE, msg);
                throw new TransportException(msg);
            }
        }
        catch (InstantiationException | IllegalAccessException | IllegalArgumentException
                | InvocationTargetException | NoSuchMethodException | SecurityException e)
        {
            final String msg = ""Failed to process key file ["" + pemFile + ""] - "" + e.getMessage();
            throw new TransportException(msg, e);
        }

        return privateKey;
    }

    private Object readPemObject(String pemFile)
    {
        Reader reader = null;
        Object pemParser = null;
        Object pemObject = null;

        try
        {
            reader = new FileReader(pemFile);
            pemParser = pemParserCons.newInstance(reader); // = new PEMParser(reader);
            pemObject = pemReadMethod.invoke(pemParser); // = pemParser.readObject();
        }
        catch (IOException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | InstantiationException e)
        {
            _logger.log(Level.SEVERE, ""Unable to read PEM object. Perhaps you need the unlimited strength libraries in <java-home>/jre/lib/security/ ?"", e);
            throw new TransportException(""Unable to read PEM object from file "" + pemFile, e);
        }
        finally
        {
            closeSafely(reader);
        }

        return pemObject;
    }

    private void setProvider(Object obj, String provider) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException
    {
        final Class<?> aClz = obj.getClass();
        final Method setProvider = aClz.getMethod(""setProvider"", String.class);
        setProvider.invoke(obj, provider);
    }

    private void closeSafely(Closeable c)
    {
        if (c != null)
        {
            try
            {
                c.close();
            }
            catch (IOException e)
            {
               // Swallow
            }
        }
    }

    private static final class AlwaysTrustingTrustManager implements X509TrustManager
    {
        @Override
        public X509Certificate[] getAcceptedIssuers()
        {
            return null;
        }

        @Override
        public void checkServerTrusted(X509Certificate[] arg0, String arg1)
                throws CertificateException
        {
            // Do not check certificate
        }

        @Override
        public void checkClientTrusted(X509Certificate[] arg0, String arg1)
                throws CertificateException
        {
            // Do not check certificate
        }
    }
}
"
"proton-j/src/main/java/org/apache/qpid/proton/engine/impl/ssl/SslEngineFacadeFactory.java:[219,256]:createAndInitialiseSslEngine","    private SSLEngine createAndInitialiseSslEngine(SslDomain domain, SslPeerDetails peerDetails)
    {
        SslDomain.Mode mode = domain.getMode();

        SSLContext sslContext = getOrCreateSslContext(domain);
        SSLEngine sslEngine = createSslEngine(sslContext, peerDetails);

        if (domain.getPeerAuthentication() == SslDomain.VerifyMode.ANONYMOUS_PEER)
        {
            addAnonymousCipherSuites(sslEngine);
        }
        else
        {
            if (mode == SslDomain.Mode.SERVER)
            {
                sslEngine.setNeedClientAuth(true);
            }

            if(domain.getPeerAuthentication() == SslDomain.VerifyMode.VERIFY_PEER_NAME)
            {
                SSLParameters sslParameters = sslEngine.getSSLParameters();
                sslParameters.setEndpointIdentificationAlgorithm(""HTTPS"");
                sslEngine.setSSLParameters(sslParameters);
            }
        }

        if(_logger.isLoggable(Level.FINE))
        {
            _logger.log(Level.FINE, mode + "" Enabled cipher suites "" + Arrays.asList(sslEngine.getEnabledCipherSuites()));
        }

        boolean useClientMode = mode == SslDomain.Mode.CLIENT;
        sslEngine.setUseClientMode(useClientMode);

        removeSSLv3Support(sslEngine);

        return sslEngine;
    }
"
"proton-j/src/main/java/org/apache/qpid/proton/engine/Transport.java:[67,330]:Transport","public interface Transport extends Endpoint
{

    public static final class Factory
    {
        public static Transport create() {
            return new TransportImpl();
        }
    }

    public static final int TRACE_OFF = 0;
    public static final int TRACE_RAW = 1;
    public static final int TRACE_FRM = 2;
    public static final int TRACE_DRV = 4;

    public static final int DEFAULT_MAX_FRAME_SIZE = -1;

    /** the lower bound for the agreed maximum frame size (in bytes). */
    public int MIN_MAX_FRAME_SIZE = 512;
    public int SESSION_WINDOW = 16*1024;
    public int END_OF_STREAM = -1;

    public void trace(int levels);

    public void bind(Connection connection);
    public void unbind();

    public int capacity();
    public ByteBuffer tail();
    public void process() throws TransportException;
    public void close_tail();


    public int pending();
    public ByteBuffer head();
    public void pop(int bytes);
    public void close_head();

    public boolean isClosed();

    /**
     * Processes the provided input.
     *
     * @param bytes input bytes for consumption
     * @param offset the offset within bytes where input begins
     * @param size the number of bytes available for input
     *
     * @return the number of bytes consumed
     * @throws TransportException if the input is invalid, if the transport is already in an error state,
     * or if the input is empty (unless the remote connection is already closed)
     * @deprecated use {@link #getInputBuffer()} and {@link #processInput()} instead.
     */
    @Deprecated
    public int input(byte[] bytes, int offset, int size);

    /**
     * Get a buffer that can be used to write input data into the transport.
     * Once the client has finished putting into the input buffer, {@link #processInput()}
     * must be called.
     *
     * Successive calls to this method are not guaranteed to return the same object.
     * Once {@link #processInput()} is called the buffer must not be used.
     *
     * @throws TransportException if the transport is already in an invalid state
     */
    ByteBuffer getInputBuffer();

    /**
     * Tell the transport to process the data written to the input buffer.
     *
     * If the returned result indicates failure, the transport will not accept any more input.
     * Specifically, any subsequent {@link #processInput()} calls on this object will
     * throw an exception.
     *
     * @return the result of processing the data, which indicates success or failure.
     * @see #getInputBuffer()
     */
    TransportResult processInput();

    /**
     * Has the transport produce up to size bytes placing the result
     * into dest beginning at position offset.
     *
     * @param dest array for output bytes
     * @param offset the offset within bytes where output begins
     * @param size the maximum number of bytes to be output
     *
     * @return the number of bytes written
     * @deprecated use {@link #getOutputBuffer()} and {@link #outputConsumed()} instead
     */
    @Deprecated
    public int output(byte[] dest, int offset, int size);

    /**
     * Get a read-only byte buffer containing the transport's pending output.
     * Once the client has finished getting from the output buffer, {@link #outputConsumed()}
     * must be called.
     *
     * Successive calls to this method are not guaranteed to return the same object.
     * Once {@link #outputConsumed()} is called the buffer must not be used.
     *
     * If the transport's state changes AFTER calling this method, this will not be
     * reflected in the output buffer.
     */
    ByteBuffer getOutputBuffer();

    /**
     * Informs the transport that the output buffer returned by {@link #getOutputBuffer()}
     * is finished with, allowing implementation-dependent steps to be performed such as
     * reclaiming buffer space.
     */
    void outputConsumed();

    /**
     * Signal the transport to expect SASL frames used to establish a SASL layer prior to
     * performing the AMQP protocol version negotiation. This must first be performed before
     * the transport is used for processing. Subsequent invocations will return the same
     * {@link Sasl} object.
     *
     * @throws IllegalStateException if transport processing has already begun prior to initial invocation
     */
    Sasl sasl() throws IllegalStateException;

    /**
     * Wrap this transport's output and input to apply SSL encryption and decryption respectively.
     *
     * This method is expected to be called at most once. A subsequent invocation will return the same
     * {@link Ssl} object, regardless of the parameters supplied.
     *
     * @param sslDomain the SSL settings to use
     * @param sslPeerDetails peer details, used for SNI, hostname verification, etc when connecting. May be null.
     * @return an {@link Ssl} object representing the SSL session.
     * @throws IllegalArgumentException if the sslDomain requests hostname verification but sslPeerDetails are null.
     * @throws IllegalStateException if the sslDomain has not been initialised.
     */
    Ssl ssl(SslDomain sslDomain, SslPeerDetails sslPeerDetails) throws IllegalArgumentException;

    /**
     * Equivalent to {@link #ssl(SslDomain, SslPeerDetails)} but passing null for SslPeerDetails, meaning no SNI detail
     * is sent, hostname verification isn't supported etc when connecting.
     *
     * @throws IllegalArgumentException if the sslDomain requests hostname verification.
     * @throws IllegalStateException if the sslDomain has not been initialised.
     */
    Ssl ssl(SslDomain sslDomain) throws IllegalArgumentException;


    /**
     * Get the maximum frame size for the transport
     *
     * @return the maximum frame size
     */
    int getMaxFrameSize();

    void setMaxFrameSize(int size);

    int getRemoteMaxFrameSize();

    /**
     * Allows overriding the initial remote-max-frame-size to a value greater than the default 512bytes. The value set
     * will be used until such time as the Open frame arrives from the peer and populates the remote max frame size.
     *
     * This method must be called before before {@link #sasl()} in order to influence SASL behaviour.
     * @param size the remote frame size to use
     */
    void setInitialRemoteMaxFrameSize(int size);

    /**
     * Gets the local channel-max value to be advertised to the remote peer
     *
     * @return the local channel-max value
     * @see #setChannelMax(int)
     */
    int getChannelMax();

    /**
     * Set the local value of channel-max, to be advertised to the peer on the
     * <a href=""http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.html#type-open"">
     * Open frame</a> emitted by the transport.
     *
     * The remote peers advertised channel-max can be observed using {@link #getRemoteChannelMax()}.
     *
     * @param channelMax the local channel-max to advertise to the peer, in range [0 - 2^16).
     * @throws IllegalArgumentException if the value supplied is outside range [0 - 2^16).
     */
    void setChannelMax(int channelMax);

    /**
     * Gets the remote value of channel-max, as advertised by the peer on its
     * <a href=""http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.html#type-open"">
     * Open frame</a>.
     *
     * The local peers advertised channel-max can be observed using {@link #getChannelMax()}.
     *
     * @return the remote channel-max value
     */
    int getRemoteChannelMax();

    ErrorCondition getCondition();

    /**
     *
     * @param timeout local idle timeout in milliseconds
     */
    void setIdleTimeout(int timeout);
    /**
     *
     * @return local idle timeout in milliseconds
     */
    int getIdleTimeout();
    /**
     *
     * @return remote idle timeout in milliseconds
     */
    int getRemoteIdleTimeout();

    /**
     * Prompt the transport to perform work such as idle-timeout/heartbeat handling, and return an
     * absolute deadline in milliseconds that tick must again be called by/at, based on the provided
     * current time in milliseconds, to ensure the periodic work is carried out as necessary.
     *
     * A returned deadline of 0 indicates there is no periodic work necessitating tick be called, e.g.
     * because neither peer has defined an idle-timeout value.
     *
     * The provided milliseconds time values can be from {@link System#currentTimeMillis()} or derived
     * from {@link System#nanoTime()}, noting that for the later in particular that the returned
     * deadline could be a different sign than the given time, and (if non-zero) the returned
     * deadline should have the current time originally provided subtracted from it in order to
     * establish a relative time delay to the next deadline.
     *
     * @param nowMillis the current time in milliseconds
     * @return the absolute deadline in milliseconds to next call tick by/at, or 0 if there is none.
     */
    long tick(long nowMillis);

    long getFramesInput();

    long getFramesOutput();

    /**
     * Configure whether a synthetic Flow event should be emitted when messages are sent,
     * reflecting a change in the credit level on the link that may prompt other action.
     *
     * Defaults to true.
     *
     * @param emitFlowEventOnSend true if a flow event should be emitted, false otherwise
     */
    void setEmitFlowEventOnSend(boolean emitFlowEventOnSend);

    boolean isEmitFlowEventOnSend();

    /**
     * Set an upper limit on the size of outgoing frames that will be sent
     * to the peer. Allows constraining the transport not to emit Transfer
     * frames over a given size even when the peers max frame size allows it.
     *
     * Must be set before receiving the peers Open frame to have effect.
     *
     * @param size the size limit to apply
     */
    void setOutboundFrameSizeLimit(int size);

    int getOutboundFrameSizeLimit();
}
"
"proton-j/src/main/java/org/apache/qpid/proton/engine/Transport.java:[202,202]:ssl","    Ssl ssl(SslDomain sslDomain, SslPeerDetails sslPeerDetails) throws IllegalArgumentException;
"
"proton-j/src/main/java/org/apache/qpid/proton/engine/SslDomain.java:[27,170]:SslDomain","public interface SslDomain
{

    public static final class Factory
    {
        public static SslDomain create() {
            return new SslDomainImpl();
        }
    }

    /**
     * Determines whether the endpoint acts as a client or server.
     */
    public enum Mode
    {
        /** Local connection endpoint is an SSL client */
        CLIENT,

        /** Local connection endpoint is an SSL server */
        SERVER
    }

    /**
     * Determines the level of peer validation.
     *
     * {@link #VERIFY_PEER_NAME} is used by default in {@link Mode#CLIENT client}
     * mode if not configured otherwise, with {@link #ANONYMOUS_PEER} used for
     * {@link Mode#SERVER server} mode if not configured otherwise.
     */
    public enum VerifyMode
    {
        /**
         * Requires peers provide a valid identifying certificate signed by
         * a trusted certificate. Does not verify hostname details of the
         * peer certificate, use {@link #VERIFY_PEER_NAME} for this instead.
         */
        VERIFY_PEER,
        /**
         * Requires peers provide a valid identifying certificate signed
         * by a trusted certificate, including verifying hostname details
         * of the certificate using peer details provided when configuring
         * TLS via {@link Transport#ssl(SslDomain, SslPeerDetails)}.
         */
        VERIFY_PEER_NAME,
        /**
         * does not require a valid certificate, and permits use of ciphers that
         * do not provide authentication
         */
        ANONYMOUS_PEER,
    }

    /**
     * Initialize the ssl domain object.
     *
     * An SSL object be either an SSL server or an SSL client. It cannot be both. Those
     * transports that will be used to accept incoming connection requests must be configured
     * as an SSL server. Those transports that will be used to initiate outbound connections
     * must be configured as an SSL client.
     *
     */
    void init(Mode mode);

    Mode getMode();

    /**
     * Set the certificate that identifies the local node to the remote.
     *
     * This certificate establishes the identity for the local node. It will be sent to the
     * remote if the remote needs to verify the identity of this node. This may be used for
     * both SSL servers and SSL clients (if client authentication is required by the server).
     *
     * @param certificateFile path to file/database containing the identifying
     * certificate.
     * @param privateKeyFile path to file/database containing the private key used to
     * sign the certificate
     * @param password the password used to sign the key, else null if key is not
     * protected.
     */
    void setCredentials(String certificateFile, String privateKeyFile, String password);

    String getPrivateKeyFile();

    String getPrivateKeyPassword();

    String getCertificateFile();

    /**
     * Configure the set of trusted CA certificates used by this node to verify peers.
     *
     * If the local SSL client/server needs to verify the identity of the remote, it must
     * validate the signature of the remote's certificate. This function sets the database of
     * trusted CAs that will be used to verify the signature of the remote's certificate.
     *
     * @param certificateDb database of trusted CAs, used to authenticate the peer.
     */
    void setTrustedCaDb(String certificateDb);

    String getTrustedCaDb();

    /**
     * Configure the level of verification used on the peer certificate.
     *
     * This method controls how the peer's certificate is validated, if at all. By default,
     * neither servers nor clients attempt to verify their peers ({@link VerifyMode#ANONYMOUS_PEER}).
     * Once certificates and trusted CAs are configured, peer verification can be enabled.
     *
     * In order to verify a peer, a trusted CA must be configured. See
     * {@link #setTrustedCaDb(String)}.
     *
     * NOTE: Servers must provide their own certificate when verifying a peer. See
     * {@link #setCredentials(String, String, String)}).
     *
     * @param mode the level of validation to apply to the peer
     */
    void setPeerAuthentication(VerifyMode mode);

    VerifyMode getPeerAuthentication();

    /**
     * Permit a server to accept connection requests from non-SSL clients.
     *
     * This configures the server to ""sniff"" the incoming client data stream, and dynamically
     * determine whether SSL/TLS is being used. This option is disabled by default: only
     * clients using SSL/TLS are accepted.
     */
    void allowUnsecuredClient(boolean allowUnsecured);

    boolean allowUnsecuredClient();

    /**
     * Sets an SSLContext for use when establishing SSL transport. Setting a context this way overrides alternate
     * configuration that might otherwise have been used to create a context, such as key and trust store paths.
     *
     *@param sslContext the context to use
     */
    void setSslContext(SSLContext sslContext);

    /**
     * Returns the SSLContext set by {@link #setSslContext(SSLContext)}.
     *
     * @return the SSLContext, or null if none was set.
     */
    SSLContext getSslContext();
}
"
"proton-j/src/main/java/org/apache/qpid/proton/engine/SslDomain.java:[56,76]:VerifyMode","    public enum VerifyMode
    {
        /**
         * Requires peers provide a valid identifying certificate signed by
         * a trusted certificate. Does not verify hostname details of the
         * peer certificate, use {@link #VERIFY_PEER_NAME} for this instead.
         */
        VERIFY_PEER,
        /**
         * Requires peers provide a valid identifying certificate signed
         * by a trusted certificate, including verifying hostname details
         * of the certificate using peer details provided when configuring
         * TLS via {@link Transport#ssl(SslDomain, SslPeerDetails)}.
         */
        VERIFY_PEER_NAME,
        /**
         * does not require a valid certificate, and permits use of ciphers that
         * do not provide authentication
         */
        ANONYMOUS_PEER,
    }
"
"proton-j/src/main/java/org/apache/qpid/proton/engine/impl/ssl/SslDomainImpl.java:[94,98]:setPeerAuthentication","    public void setPeerAuthentication(VerifyMode verifyMode)
    {
        _verifyMode = verifyMode;
        _sslEngineFacadeFactory.resetCache();
    }
"
"proton-j/src/main/java/org/apache/qpid/proton/engine/impl/ssl/SslDomainImpl.java:[101,109]:getPeerAuthentication","    public VerifyMode getPeerAuthentication()
    {
        if(_verifyMode == null)
        {
           return _mode == Mode.SERVER ? VerifyMode.ANONYMOUS_PEER : VerifyMode.VERIFY_PEER_NAME;
        }

        return _verifyMode;
    }
"
