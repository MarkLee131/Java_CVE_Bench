Vul_Path,Vul_Src
"src/main/java/org/owasp/esapi/crypto/CipherText.java:[432,449]:validateMAC","	public boolean validateMAC(SecretKey authKey) {
	    boolean usesMAC = ESAPI.securityConfiguration().useMACforCipherText();

	    if (  usesMAC && macComputed() ) {  // Uses MAC and it was computed
	        // Calculate MAC from HMAC-SHA1(nonce, IV + plaintext) and
	        // compare to stored value (separate_mac_). If same, then return true,
	        // else return false.
	        byte[] mac = computeMAC(authKey);
	        assert mac.length == separate_mac_.length : ""MACs are of differnt lengths. Should both be the same."";
	        return CryptoHelper.arrayCompare(mac, separate_mac_); // Safe compare!!!
	    } else if ( ! usesMAC ) {           // Doesn't use MAC
	        return true;
	    } else {                            // Uses MAC but it has not been computed / stored.
	        logger.warning(Logger.SECURITY_FAILURE, ""Cannot validate MAC as it was never computed and stored. "" +
	        ""Decryption result may be garbage even when decryption succeeds."");
	        return true;    // Need to return 'true' here because of encrypt() / decrypt() methods don't support this.
	    }
	}
"
"src/main/java/org/owasp/esapi/Encryptor.java:[44,450]:Encryptor","public interface Encryptor {

	/**
	 * Returns a string representation of the hash of the provided plaintext and
	 * salt. The salt helps to protect against a rainbow table attack by mixing
	 * in some extra data with the plaintext. Some good choices for a salt might
	 * be an account name or some other string that is known to the application
	 * but not to an attacker. 
	 * See <a href=""http://www.matasano.com/log/958/enough-with-the-rainbow-tables-what-you-need-to-know-about-secure-password-schemes/"">
	 * this article</a> for more information about hashing as it pertains to password schemes.
	 * 
	 * @param plaintext
	 * 		the plaintext String to encrypt
	 * @param salt
	 *      the salt to add to the plaintext String before hashing
	 * 
	 * @return 
	 * 		the encrypted hash of 'plaintext' stored as a String
	 * 
	 * @throws EncryptionException
	 *      if the specified hash algorithm could not be found or another problem exists with 
	 *      the hashing of 'plaintext'
	 */
	String hash(String plaintext, String salt) throws EncryptionException;

	/**
	 * Returns a string representation of the hash of the provided plaintext and
	 * salt. The salt helps to protect against a rainbow table attack by mixing
	 * in some extra data with the plaintext. Some good choices for a salt might
	 * be an account name or some other string that is known to the application
	 * but not to an attacker. 
	 * See <a href=""http://www.matasano.com/log/958/enough-with-the-rainbow-tables-what-you-need-to-know-about-secure-password-schemes/"">
	 * this article</a> for more information about hashing as it pertains to password schemes.
	 * 
	 * @param plaintext
	 * 		the plaintext String to encrypt
	 * @param salt
	 *      the salt to add to the plaintext String before hashing
	 * @param iterations
	 *      the number of times to iterate the hash
	 * 
	 * @return 
	 * 		the encrypted hash of 'plaintext' stored as a String
	 * 
	 * @throws EncryptionException
	 *      if the specified hash algorithm could not be found or another problem exists with 
	 *      the hashing of 'plaintext'
	 */
	String hash(String plaintext, String salt, int iterations) throws EncryptionException;
	
	/**
	 * Encrypts the provided plaintext and returns a ciphertext string using the
	 * master secret key and default cipher transformation.
	 * </p><p>
	 * <b>Compatibility with earlier ESAPI versions:</b> Unlike ESAPI 1.4 version
	 * of this method which used the Electronic Code Book (ECB)
	 * cipher mode to encrypt, this method uses the default cipher transformation
	 * and IV type (which by default is AES/CBC/PKCS5Padding and a random IV). ECB mode
	 * is not secure for general use and usually should be avoided. If you <b>must</b>
	 * use ECB mode for backward compatibility, you should do so by specifying
	 * <pre>
	 * 		ESAPI.Encryptor=org.owasp.esapi.reference.LegacyJavaEncryptor
	 * </pre>
	 * in your <b>ESAPI.properties</b> file rather than changing the default
	 * cipher transformation. That will make this method and the
	 * {@link #decrypt(String)} method use ECB mode in a manner that is compatible
	 * with ESAPI 1.4 and earlier but not affect the newer encryption / decryption
	 * methods. However, this should only be used for backward compatibility. You
	 * should use it to decrypt data that was previous encrypted using ESAPI 1.4 or
	 * earlier use a newer method that uses the stronger CBC cipher mode
	 * to re-encrypt it. Once all the previously encrypted data has been re-encrypted
	 * using this legacy class, you should stop using this legacy class and start
	 * using the default reference class, as per:
	 * <pre>
	 * 		ESAPI.Encryptor=org.owasp.esapi.reference.LegacyJavaEncryptor
	 * </pre>
	 * in your <b>ESAPI.properties</b> file. 
	 * </p><p>
	 * <b>Why this method is deprecated:</b> Most cryptographers strongly suggest
	 * that if you are creating crypto functionality for general-purpose use,
	 * at a minimum you should ensure that it provides authenticity, integrity,
	 * and confidentiality. This method only provides confidentiality, but not
	 * authenticity or integrity. Therefore, you are encouraged to use
	 * one of the other encryption methods referenced below. Because this
	 * method provides neither authenticity nor integrity, it may be
	 * removed in some future ESAPI Java release. Note: there are some cases
	 * where authenticity / integrity are not that important. For instance, consider
	 * a case where the encrypted data is never out of your application's control. For
	 * example, if you receive data that your application is encrypting itself and then
	 * storing the encrypted data in its own database for later use (and no other
	 * applications can query or update that column of the database), providing
	 * confidentiality alone might be sufficient. However, if there are cases
	 * where your application will be sending or receiving already encrypted data
	 * over an insecure, unauthenticated channel, in such cases authenticity and
	 * integrity of the encrypted data likely is important and this method should
	 * be avoided in favor of one of the other two.
	 * 
	 * @param plaintext
	 *      the plaintext {@code String} to encrypt. Note that if you are encrypting
	 *      general bytes, you should encypt that byte array to a String using
	 *      ""UTF-8"" encoding.
	 * 
	 * @return 
	 * 		the encrypted, base64-encoded String representation of 'plaintext' plus
	 * 		the random IV used.
	 * 
	 * @throws EncryptionException
	 *      if the specified encryption algorithm could not be found or another problem exists with 
	 *      the encryption of 'plaintext'
	 * 
	 * @see #encrypt(PlainText)
	 * @see #encrypt(SecretKey, PlainText)
	 * 
	 * @deprecated As of 1.4.2; use {@link #encrypt(PlainText)} instead, which
	 *			   also ensures message authenticity. This method will be
	 *             completely removed as of the next major release or point
	 *             release (3.0 or 2.1, whichever comes first) as per OWASP
	 *             deprecation policy.
	 */
	@Deprecated String encrypt(String plaintext) throws EncryptionException;

	/**
	 * Encrypts the provided plaintext bytes using the cipher transformation
	 * specified by the property <code>Encryptor.CipherTransformation</code>
	 * and the <i>master encryption key</i> as specified by the property
	 * {@code Encryptor.MasterKey} as defined in the <code>ESAPI.properties</code> file.
	 * </p><p>
	 * This method is preferred over {@link #encrypt(String)} because it also
	 * allows encrypting of general byte streams rather than simply strings and
	 * also because it returns a {@code CipherText} object and thus supports
	 * cipher modes that require an Initialization Vector (IV), such as
	 * Cipher Block Chaining (CBC).
	 * 
	 * @param plaintext	The {@code PlainText} to be encrypted.
	 * @return the {@code CipherText} object from which the raw ciphertext, the
	 * 				IV, the cipher transformation, and many other aspects about
	 * 				the encryption detail may be extracted.
	 * @throws EncryptionException Thrown if something should go wrong such as
	 * 				the JCE provider cannot be found, the cipher algorithm,
	 * 				cipher mode, or padding scheme not being supported, specifying
	 * 				an unsupported key size, specifying an IV of incorrect length,
	 * 				etc.
	 * @see #encrypt(SecretKey, PlainText)
	 * @since 2.0
	 */
	 CipherText encrypt(PlainText plaintext) throws EncryptionException;


	 /**
	  * Encrypts the provided plaintext bytes using the cipher transformation
	  * specified by the property <code>Encryptor.CipherTransformation</code>
	  * as defined in the <code>ESAPI.properties</code> file and the
	  * <i>specified secret key</i>.
	  * </p><p>
	  * This method is similar to {@link #encrypt(PlainText)} except that it
	  * permits a specific {@code SecretKey} to be used for encryption.
	  *
	  * @param key		The {@code SecretKey} to use for encrypting the plaintext.
	  * @param plaintext	The byte stream to be encrypted. Note if a Java
	  * 				{@code String} is to be encrypted, it should be converted
	  * 				using {@code ""some string"".getBytes(""UTF-8"")}.
	  * @return the {@code CipherText} object from which the raw ciphertext, the
	  * 				IV, the cipher transformation, and many other aspects about
	  * 				the encryption detail may be extracted.
	  * @throws EncryptionException Thrown if something should go wrong such as
	  * 				the JCE provider cannot be found, the cipher algorithm,
	  * 				cipher mode, or padding scheme not being supported, specifying
	  * 				an unsupported key size, specifying an IV of incorrect length,
	  * 				etc.
	  * @see #encrypt(PlainText)
	  * @since 2.0
	  */
	 CipherText encrypt(SecretKey key, PlainText plaintext)
	 		throws EncryptionException;

	/**
	 * Decrypts the provided ciphertext and returns a plaintext string using the
	 * master secret key and default cipher transformation.
	 * </p><p>
	 * <b>Compatibility with earlier ESAPI versions:</b> Unlike ESAPI 1.4 version
	 * of this method which used the Electronic Code Book (ECB)
	 * cipher mode to encrypt, this method uses the default cipher transformation
	 * and IV type (which by default is AES/CBC/PKCS5Padding and a random IV). ECB mode
	 * is not secure for general use and usually should be avoided. If you <b>must</b>
	 * use ECB mode for backward compatibility, you should do so by specifying
	 * <pre>
	 * 		ESAPI.Encryptor=org.owasp.esapi.reference.LegacyJavaEncryptor
	 * </pre>
	 * in your <b>ESAPI.properties</b> file rather than changing the default
	 * cipher transformation. That will make this method and the
	 * {@link #decrypt(String)} method use ECB mode in a manner that is compatible
	 * with ESAPI 1.4 and earlier but not affect the newer encryption / decryption
	 * methods. However, this should only be used for backward compatibility. You
	 * should use it to decrypt data that was previous encrypted using ESAPI 1.4 or
	 * earlier use a newer method that uses the stronger CBC cipher mode
	 * to re-encrypt it. Once all the previously encrypted data has been re-encrypted
	 * using this legacy class, you should stop using this legacy class and start
	 * using the default reference class, as per:
	 * <pre>
	 * 		ESAPI.Encryptor=org.owasp.esapi.reference.LegacyJavaEncryptor
	 * </pre>
	 * in your <b>ESAPI.properties</b> file. 
	 * </p><p>
	 * <b>Why this method is deprecated:</b> Most cryptographers strongly suggest
	 * that if you are creating crypto functionality for general-purpose use,
	 * at a minimum you should ensure that it provides authenticity, integrity,
	 * and confidentiality. This method only provides confidentiality, but not
	 * authenticity or integrity. Therefore, you are encouraged to use
	 * one of the other encryption methods referenced below. Because this
	 * method provides neither authenticity nor integrity, it may be
	 * removed in some future ESAPI Java release. Note: there are some cases
	 * where authenticity / integrity are not that important. For instance, consider
	 * a case where the encrypted data is never out of your application's control. For
	 * example, if you receive data that your application is encrypting itself and then
	 * storing the encrypted data in its own database for later use (and no other
	 * applications can query or update that column of the database), providing
	 * confidentiality alone might be sufficient. However, if there are cases
	 * where your application will be sending or receiving already encrypted data
	 * over an insecure, unauthenticated channel, in such cases authenticity and
	 * integrity of the encrypted data likely is important and this method should
	 * be avoided in favor of one of the other two.
	 *
	 * @param ciphertext
	 *      the ciphertext (the encrypted plaintext) that resulted from
	 *      encrypting using the method {@link #encrypt(String)}.
	 * 
	 * @return 
	 * 		the decrypted ciphertext (i.e., the corresponding plaintext).
	 * 
	 * @throws EncryptionException
	 *      if the specified encryption algorithm could not be found or another problem exists with 
	 *      the decryption of 'plaintext'
	 *
	 * @deprecated As of 1.4.2; use {@link #decrypt(CipherText)} instead, which
     *             also ensures message authenticity. This method will be
     *             completely removed as of the next major release or point
     *             release (3.0 or 2.1, whichever comes first) as per OWASP
     *             deprecation policy.
	 */
	 @Deprecated String decrypt(String ciphertext) throws EncryptionException;

	/**
	 * Decrypts the provided {@link CipherText} using the information from it
	 * and the <i>master encryption key</i> as specified by the property
	 * {@code Encryptor.MasterKey} as defined in the {@code ESAPI.properties}
	 * file.
	 * </p><p>
	 * This decrypt method is to be preferred over the deprecated
	 * {@link #decrypt(String)} method because this method can handle plaintext
	 * bytes that were encrypted with cipher modes requiring IVs, such as CBC.
	 * </p>
	 * @param ciphertext The {@code CipherText} object to be decrypted.
	 * @return The {@code PlainText} object resulting from decrypting the specified
	 * 		   ciphertext. Note that it it is desired to convert the returned
	 * 		   plaintext byte array to a Java String is should be done using
	 * 		   {@code new String(byte[], ""UTF-8"");} rather than simply using
	 * 		   {@code new String(byte[]);} which uses native encoding and may
	 * 		   not be portable across hardware and/or OS platforms.
	 * @throws EncryptionException  Thrown if something should go wrong such as
	 * 				the JCE provider cannot be found, the cipher algorithm,
	 * 				cipher mode, or padding scheme not being supported, specifying
	 * 				an unsupported key size, or incorrect encryption key was
	 * 				specified or a {@code PaddingException} occurs.
	 * @see #decrypt(SecretKey, CipherText)
	 */
	PlainText decrypt(CipherText ciphertext) throws EncryptionException;
	
	/**
	 * Decrypts the provided {@link CipherText} using the information from it
	 * and the <i>specified secret key</i>.
	 * </p><p>
	 * This decrypt method is similar to {@link #decrypt(CipherText)} except that
	 * it allows decrypting with a secret key other than the <i>master secret key</i>.
	 * </p>
	 * @param key		The {@code SecretKey} to use for encrypting the plaintext.
	 * @param ciphertext The {@code CipherText} object to be decrypted.
	 * @return The {@code PlainText} object resulting from decrypting the specified
	 * 		   ciphertext. Note that it it is desired to convert the returned
	 * 		   plaintext byte array to a Java String is should be done using
	 * 		   {@code new String(byte[], ""UTF-8"");} rather than simply using
	 * 		   {@code new String(byte[]);} which uses native encoding and may
	 * 		   not be portable across hardware and/or OS platforms.
	 * @throws EncryptionException  Thrown if something should go wrong such as
	 * 				the JCE provider cannot be found, the cipher algorithm,
	 * 				cipher mode, or padding scheme not being supported, specifying
	 * 				an unsupported key size, or incorrect encryption key was
	 * 				specified or a {@code PaddingException} occurs.
	 * @see #decrypt(CipherText)
	 */
	PlainText decrypt(SecretKey key, CipherText ciphertext) throws EncryptionException;
	
	/**
	 * Create a digital signature for the provided data and return it in a
	 * string.
	 * <p>
	 * <b>Limitations:</b> A new public/private key pair used for ESAPI 2.0 digital
	 * signatures with this method and {@link #verifySignature(String, String)}
	 * are dynamically created when the default reference implementation class,
	 * {@link org.owasp.esapi.reference.crypto.JavaEncryptor} is first created.
	 * Because this key pair is not persisted nor is the public key shared,
	 * this method and the corresponding {@link #verifySignature(String, String)}
	 * can not be used with expected results across JVM instances. This limitation
	 * will be addressed in ESAPI 2.1.
	 * </p>
	 * 
	 * @param data
	 *      the data to sign
	 * 
	 * @return 
	 * 		the digital signature stored as a String
	 * 
	 * @throws EncryptionException
	 * 		if the specified signature algorithm cannot be found
	 */
	String sign(String data) throws EncryptionException;

	/**
	 * Verifies a digital signature (created with the sign method) and returns
	 * the boolean result.
     * <p>
     * <b>Limitations:</b> A new public/private key pair used for ESAPI 2.0 digital
     * signatures with this method and {@link #sign(String)}
     * are dynamically created when the default reference implementation class,
     * {@link org.owasp.esapi.reference.crypto.JavaEncryptor} is first created.
     * Because this key pair is not persisted nor is the public key shared,
     * this method and the corresponding {@link #sign(String)}
     * can not be used with expected results across JVM instances. This limitation
     * will be addressed in ESAPI 2.1.
     * </p>
	 * @param signature
	 *      the signature to verify against 'data'
	 * @param data
	 *      the data to verify against 'signature'
	 * 
	 * @return 
	 * 		true, if the signature is verified, false otherwise
	 * 
	 */
	boolean verifySignature(String signature, String data);

	/**
	 * Creates a seal that binds a set of data and includes an expiration timestamp.
	 * 
	 * @param data
	 *      the data to seal
	 * @param timestamp
	 *      the absolute expiration date of the data, expressed as seconds since the epoch
	 * 
	 * @return 
     * 		the seal
     * @throws IntegrityException
	 * 
	 */
	String seal(String data, long timestamp) throws IntegrityException;

	/**
	 * Unseals data (created with the seal method) and throws an exception
	 * describing any of the various problems that could exist with a seal, such
	 * as an invalid seal format, expired timestamp, or decryption error.
	 * 
	 * @param seal
	 *      the sealed data
	 * 
	 * @return 
	 * 		the original (unsealed) data
	 * 
	 * @throws EncryptionException 
	 * 		if the unsealed data cannot be retrieved for any reason
	 */
	String unseal( String seal ) throws EncryptionException;
	
	/**
	 * Verifies a seal (created with the seal method) and throws an exception
	 * describing any of the various problems that could exist with a seal, such
	 * as an invalid seal format, expired timestamp, or data mismatch.
	 * 
	 * @param seal
	 *      the seal to verify
	 * 
	 * @return 
	 * 		true, if the seal is valid.  False otherwise
	 */
	boolean verifySeal(String seal);
	
	/**
	 * Gets an absolute timestamp representing an offset from the current time to be used by
	 * other functions in the library.
	 * 
	 * @param offset 
	 * 		the offset to add to the current time
	 * 
	 * @return 
	 * 		the absolute timestamp
	 */
	public long getRelativeTimeStamp( long offset );
	
	
	/**
	 * Gets a timestamp representing the current date and time to be used by
	 * other functions in the library.
	 * 
	 * @return 
	 * 		a timestamp representing the current time
	 */
	long getTimeStamp();

}"
"src/main/java/org/owasp/esapi/Encryptor.java:[163,163]:encrypt","	@Deprecated String encrypt(String plaintext) throws EncryptionException;
"
"src/main/java/org/owasp/esapi/Encryptor.java:[283,283]:decrypt","	 @Deprecated String decrypt(String ciphertext) throws EncryptionException;
"
"src/main/java/org/owasp/esapi/reference/crypto/JavaEncryptor.java:[76,1048]:JavaEncryptor","public final class JavaEncryptor implements Encryptor {
    private static volatile Encryptor singletonInstance;

    // Note: This double-check pattern only works because singletonInstance
    //       is declared to be volatile.  Usually this method is called
    //       via ESAPI.encryptor() rather than directly.
    public static Encryptor getInstance() throws EncryptionException {
        if ( singletonInstance == null ) {
            synchronized ( JavaEncryptor.class ) {
                if ( singletonInstance == null ) {
                    singletonInstance = new JavaEncryptor();
                }
            }
        }
        return singletonInstance;
    }

    private static boolean initialized = false;
    
    // encryption
    private static SecretKeySpec secretKeySpec = null; // DISCUSS: Why static? Implies one key?!?
    private static String encryptAlgorithm = ""AES"";
    private static String encoding = ""UTF-8""; 
    private static int encryptionKeyLength = 128;
    
    // digital signatures
    private static PrivateKey privateKey = null;
	private static PublicKey publicKey = null;
	private static String signatureAlgorithm = ""SHA1withDSA"";
    private static String randomAlgorithm = ""SHA1PRNG"";
	private static int signatureKeyLength = 1024;
	
	// hashing
	private static String hashAlgorithm = ""SHA-512"";
	private static int hashIterations = 1024;
	
	// Logging - DISCUSS: This ""sticks"" us with a specific logger to whatever it was when
	//					  this class is first loaded. Is this a big limitation? Since there
	//                    is no method to reset it, we may has well make it 'final' also.
	private static Logger logger = ESAPI.getLogger(""JavaEncryptor"");
	    // Used to print out warnings about deprecated methods.
	private static int encryptCounter = 0;
	private static int decryptCounter = 0;
        // DISCUSS: OK to not have a property for this to set the frequency?
        //          The desire is to persuade people to move away from these
	    //          two deprecated encrypt(String) / decrypt(String) methods,
        //          so perhaps the annoyance factor of not being able to
        //          change it will help. For now, it is just hard-coded here.
        //          We could be mean and just print a warning *every* time.
	private static final int logEveryNthUse = 25;
	
    // *Only* use this string for user messages for EncryptionException when
    // decryption fails. This is to prevent information leakage that may be
    // valuable in various forms of ciphertext attacks, such as the
	// Padded Oracle attack described by Rizzo and Duong.
    private static final String DECRYPTION_FAILED =
        ""Decryption failed; see logs for details."";

    // # of seconds that all failed decryption attempts will take. Used to
    // help prevent side-channel timing attacks.
    private static int N_SECS = 2;

	// Load the preferred JCE provider if one has been specified.
	static {
	    try {
            SecurityProviderLoader.loadESAPIPreferredJCEProvider();
        } catch (NoSuchProviderException ex) {
            logger.fatal(Logger.SECURITY_FAILURE,
                         ""JavaEncryptor failed to load JCE provider."", ex);
            throw new ExceptionInInitializerError(ex);
        }
        setupAlgorithms();
	}
	
    /**
     * Generates a new strongly random secret key and salt that can be
     * copy and pasted in the <b>ESAPI.properties</b> file.
     * 
     * @param args Set first argument to ""-print"" to display available algorithms on standard output.
     * @throws java.lang.Exception	To cover a multitude of sins, mostly in configuring ESAPI.properties.
     */
    public static void main( String[] args ) throws Exception {
		System.out.println( ""Generating a new secret master key"" );
		
		// print out available ciphers
		if ( args.length == 1 && args[0].equalsIgnoreCase(""-print"" ) ) {
			System.out.println( ""AVAILABLE ALGORITHMS"" );

			Provider[] providers = Security.getProviders();
			TreeMap<String, String> tm = new TreeMap<String, String>();
			// DISCUSS: Note: We go through multiple providers, yet nowhere do I
			//			see where we print out the PROVIDER NAME. Not all providers
			//			will implement the same algorithms and some ""partner"" with
			//			whom we are exchanging different cryptographic messages may
			//			have _different_ providers in their java.security file. So
			//			it would be useful to know the provider name where each
			//			algorithm is implemented. Might be good to prepend the provider
			//			name to the 'key' with something like ""providerName: "". Thoughts?
			for (int i = 0; i != providers.length; i++) {
				// DISCUSS: Print security provider name here???
					// Note: For some odd reason, Provider.keySet() returns
					//		 Set<Object> of the property keys (which are Strings)
					//		 contained in this provider, but Set<String> seems
					//		 more appropriate. But that's why we need the cast below.
	            System.out.println(""===== Provider "" + i + "":"" + providers[i].getName() + "" ======"");
				Iterator<Object> it = providers[i].keySet().iterator();
				while (it.hasNext()) {
					String key = (String)it.next();
		            String value = providers[i].getProperty( key );
		            tm.put(key, value);
	                System.out.println(""\t\t   "" + key + "" -> ""+ value );
				}
			}

			Set< Entry<String,String> > keyValueSet = tm.entrySet();
			Iterator<Entry<String, String>> it = keyValueSet.iterator();
			while( it.hasNext() ) {
				Map.Entry<String,String> entry = it.next();
				String key = entry.getKey();
				String value = entry.getValue();
	        	System.out.println( ""   "" + key + "" -> ""+ value );
			}
		} else {
				// Used to print a similar line to use '-print' even when it was specified.
			System.out.println( ""\tuse '-print' to also show available crypto algorithms from all the security providers"" );
		}
		
        // setup algorithms -- Each of these have defaults if not set, although
		//					   someone could set them to something invalid. If
		//					   so a suitable exception will be thrown and displayed.
        encryptAlgorithm = ESAPI.securityConfiguration().getEncryptionAlgorithm();
		encryptionKeyLength = ESAPI.securityConfiguration().getEncryptionKeyLength();
		randomAlgorithm = ESAPI.securityConfiguration().getRandomAlgorithm();

		SecureRandom random = SecureRandom.getInstance(randomAlgorithm);
		SecretKey secretKey = CryptoHelper.generateSecretKey(encryptAlgorithm, encryptionKeyLength);
        byte[] raw = secretKey.getEncoded();
        byte[] salt = new byte[20];	// Or 160-bits; big enough for SHA1, but not SHA-256 or SHA-512.
        random.nextBytes( salt );
        String eol = System.getProperty(""line.separator"", ""\n""); // So it works on Windows too.
        System.out.println( eol + ""Copy and paste these lines into ESAPI.properties"" + eol);
        System.out.println( ""#=============================================================="");
        System.out.println( ""Encryptor.MasterKey="" + ESAPI.encoder().encodeForBase64(raw, false) );
        System.out.println( ""Encryptor.MasterSalt="" + ESAPI.encoder().encodeForBase64(salt, false) );
        System.out.println( ""#=============================================================="" + eol);
    }
	
    
    /**
     * Private CTOR for {@code JavaEncryptor}, called by {@code getInstance()}.
     * @throws EncryptionException if can't construct this object for some reason.
     * 					Original exception will be attached as the 'cause'.
     */
    private JavaEncryptor() throws EncryptionException {
        byte[] salt = ESAPI.securityConfiguration().getMasterSalt();
        byte[] skey = ESAPI.securityConfiguration().getMasterKey();

        assert salt != null : ""Can't obtain master salt, Encryptor.MasterSalt"";
        assert salt.length >= 16 : ""Encryptor.MasterSalt must be at least 16 bytes. "" +
                                   ""Length is: "" + salt.length + "" bytes."";
        assert skey != null : ""Can't obtain master key, Encryptor.MasterKey"";
        assert skey.length >= 7 : ""Encryptor.MasterKey must be at least 7 bytes. "" +
                                  ""Length is: "" + skey.length + "" bytes."";
        
        // Set up secretKeySpec for use for symmetric encryption and decryption,
        // and set up the public/private keys for asymmetric encryption /
        // decryption.
        // TODO: Note: If we dump ESAPI 1.4 crypto backward compatibility,
        //       then we probably will ditch the Encryptor.EncryptionAlgorithm
        //       property. If so, encryptAlgorithm should probably use
        //       Encryptor.CipherTransformation and just pull off the cipher
        //       algorithm name so we can use it here.
        synchronized(JavaEncryptor.class) {
            if ( ! initialized ) {
                //
                // For symmetric encryption
                //
                //      NOTE: FindBugs complains about this
                //            (ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD) but
                //            it should be OK since it is synchronized and only
                //            done once. While we could separate this out and
                //            handle in a static initializer, it just seems to
                //            fit better here.
                secretKeySpec = new SecretKeySpec(skey, encryptAlgorithm );
                
                //
                // For asymmetric encryption (i.e., public/private key)
                //
                try {
                    SecureRandom prng = SecureRandom.getInstance(randomAlgorithm);

                    // Because hash() is not static (but it could be were in not
                    // for the interface method specification in Encryptor), we
                    // cannot do this initialization in a static method or static
                    // initializer.
                    byte[] seed = hash(new String(skey, encoding),new String(salt, encoding)).getBytes(encoding);
                    prng.setSeed(seed);
                    initKeyPair(prng);
                } catch (Exception e) {
                    throw new EncryptionException(""Encryption failure"", ""Error creating Encryptor"", e);
                }             
                
                // Mark everything as initialized.
                initialized = true;
            }
        }
    }
     


	/**
     * {@inheritDoc}
     * 
	 * Hashes the data with the supplied salt and the number of iterations specified in
	 * the ESAPI SecurityConfiguration.
	 */
	public String hash(String plaintext, String salt) throws EncryptionException {
		return hash( plaintext, salt, hashIterations );
	}
	
	/**
     * {@inheritDoc}
     * 
	 * Hashes the data using the specified algorithm and the Java MessageDigest class. This method
	 * first adds the salt, a separator ("":""), and the data, and then rehashes the specified number of iterations
	 * in order to help strengthen weak passwords.
	 */
	public String hash(String plaintext, String salt, int iterations) throws EncryptionException {
		byte[] bytes = null;
		try {
			MessageDigest digest = MessageDigest.getInstance(hashAlgorithm);
			digest.reset();
			digest.update(ESAPI.securityConfiguration().getMasterSalt());
			digest.update(salt.getBytes(encoding));
			digest.update(plaintext.getBytes(encoding));

			// rehash a number of times to help strengthen weak passwords
			bytes = digest.digest();
			for (int i = 0; i < iterations; i++) {
				digest.reset();
				bytes = digest.digest(bytes);
			}
			String encoded = ESAPI.encoder().encodeForBase64(bytes,false);
			return encoded;
		} catch (NoSuchAlgorithmException e) {
			throw new EncryptionException(""Internal error"", ""Can't find hash algorithm "" + hashAlgorithm, e);
		} catch (UnsupportedEncodingException ex) {
			throw new EncryptionException(""Internal error"", ""Can't find encoding for "" + encoding, ex);
		}
	}
	
	/**
	 * Convenience method that encrypts plaintext strings the new way (default
	 * is CBC mode and PKCS5 padding). This encryption method uses the master
	 * encryption key specified by the {@code Encryptor.MasterKey} property
	 * in {@code ESAPI.properties}.
	 * 
	 * @param plaintext	A String to be encrypted
	 * @return	A base64-encoded combination of IV + raw ciphertext
	 * @throws EncryptionException	Thrown when something goes wrong with the
	 * 								encryption.
	 * 
	 * @see org.owasp.esapi.Encryptor#encrypt(PlainText)
	 */
	@Deprecated public String encrypt(String plaintext) throws EncryptionException
	{
        logWarning(""encrypt"", ""Calling deprecated encrypt() method."");
		CipherText ct = null;
		ct = encrypt(new PlainText(plaintext) );
		return ct.getEncodedIVCipherText();
	}


	/**
	* {@inheritDoc}
	*/
	 public CipherText encrypt(PlainText plaintext) throws EncryptionException {
		 // Now more of a convenience function for using the master key.
		 return encrypt(secretKeySpec, plaintext);
	 }
	 
	 /**
	  * {@inheritDoc}
	  */
	 public CipherText encrypt(SecretKey key, PlainText plain)
	 			throws EncryptionException
	 {
		 byte[] plaintext = plain.asBytes();
		 boolean overwritePlaintext = ESAPI.securityConfiguration().overwritePlainText();
		 assert key != null : ""(Master) encryption key may not be null"";
		 
		 boolean success = false;	// Used in 'finally' clause.
		 String xform = null;
		 int keySize = key.getEncoded().length * 8;	// Convert to # bits

		try {
			 xform = ESAPI.securityConfiguration().getCipherTransformation();
             String[] parts = xform.split(""/"");
             assert parts.length == 3 : ""Malformed cipher transformation: "" + xform;
             String cipherMode = parts[1];
             
             // This way we can prevent modes like OFB and CFB where the IV should never
             // be repeated with the same encryption key (at least until we support
             // Encryptor.ChooseIVMethod=specified and allow us to specify some mechanism
             // to ensure the IV will never be repeated (such as a time stamp or other
             // monotonically increasing function).
             // DISCUSS: Should we include the permitted cipher modes in the exception msg?
             if ( ! CryptoHelper.isAllowedCipherMode(cipherMode) ) {
                 throw new EncryptionException(""Encryption failure: invalid cipher mode ( "" + cipherMode + "") for encryption"",
                             ""Encryption failure: Cipher transformation "" + xform + "" specifies invalid "" +
                             ""cipher mode "" + cipherMode);
             }
             
			 // Note - Cipher is not thread-safe so we create one locally
			 //        Also, we need to change this eventually so other algorithms can
			 //        be supported. Eventually, there will be an encrypt() method that
			 //        takes a (new class) CryptoControls, as something like this:
			 //          public CipherText encrypt(CryptoControls ctrl, SecretKey skey, PlainText plaintext)
			 //        and this method will just call that one.
			 Cipher encrypter = Cipher.getInstance(xform);
			 String cipherAlg = encrypter.getAlgorithm();
			 int keyLen = ESAPI.securityConfiguration().getEncryptionKeyLength();

			 // DISCUSS: OK, what do we want to do here if keyLen != keySize? If use keyLen, encryption
			 //		     could fail with an exception, but perhaps that's what we want. Or we may just be
			 //			 OK with silently using keySize as long as keySize >= keyLen, which then interprets
			 //			 ESAPI.EncryptionKeyLength as the *minimum* key size, but as long as we have something
			 //			 stronger it's OK to use it. For now, I am just going to log warning if different, but use
			 //			 keySize unless keySize is SMALLER than ESAPI.EncryptionKeyLength, in which case I'm going
			 //			 to log an error.
			 //
			 //			 IMPORTANT NOTE:	When we generate key sizes for both DES and DESede the result of
			 //								SecretKey.getEncoding().length includes the TRUE key size (i.e.,
			 //								*with* the even parity bits) rather than the EFFECTIVE key size
			 //								(which incidentally is what KeyGenerator.init() expects for DES
			 //								and DESede; duh! Nothing like being consistent). This leads to
			 //								the following dilemma:
			 //
			 //													EFFECTIVE Key Size		TRUE Key Size
			 //													(KeyGenerator.init())	(SecretKey.getEncoding().length)
			 //									========================================================================
			 //									For DES:			56 bits					64 bits
			 //									For DESede:			112 bits / 168 bits		192 bits (always)
			 //
			 //								We are trying to automatically determine the key size from SecretKey
			 //								based on 8 * SecretKey.getEncoding().length, but as you can see, the
			 //								2 key 3DES and the 3 key 3DES both use the same key size (192 bits)
			 //								regardless of what is passed to KeyGenerator.init(). There are no advertised
			 //								methods to get the key size specified by the init() method so I'm not sure how
			 //								this is actually working internally. However, it does present a problem if we
			 //								wish to communicate the 3DES key size to a recipient for later decryption as
			 //								they would not be able to distinguish 2 key 3DES from 3 key 3DES.
			 //
			 //								The only workaround I know is to pass the explicit key size down. However, if
			 //								we are going to do that, I'd propose passing in a CipherSpec object so we could
			 //								tell what cipher transformation to use as well instead of just the key size. Then
			 //								we would extract keySize from the CipherSpec object of from the SecretKey object.
			 //
			 if ( keySize != keyLen ) {
				 // DISCUSS: Technically this is not a security ""failure"" per se, but not really a ""success"" either.
				 logger.warning(Logger.SECURITY_FAILURE, ""Encryption key length mismatch. ESAPI.EncryptionKeyLength is "" +
						 keyLen + "" bits, but length of actual encryption key is "" + keySize +
				 		"" bits.  Did you remember to regenerate your master key (if that is what you are using)???"");
			 }
			 // DISCUSS: Reconsider these warnings. If thousands of encryptions are done in tight loop, no one needs
			 //          more than 1 warning. Should we do something more intelligent here?
			 if ( keySize < keyLen ) {
				 // ESAPI.EncryptionKeyLength defaults to 128, but that means that we could not use DES (as weak as it
				 // is), even for legacy code. Therefore, this has been changed to simple log a warning rather than
				 //	throw the following exception.
				 //				 throw new ConfigurationException(""Actual key size of "" + keySize + "" bits smaller than specified "" +
				 //						  ""encryption key length (ESAPI.EncryptionKeyLength) of "" + keyLen + "" bits."");
				 logger.warning(Logger.SECURITY_FAILURE, ""Actual key size of "" + keySize + "" bits SMALLER THAN specified "" +
						 ""encryption key length (ESAPI.EncryptionKeyLength) of "" + keyLen + "" bits with cipher algorithm "" + cipherAlg);
			 }
			 if ( keySize < 112 ) {		// NIST Special Pub 800-57 considers 112-bits to be the minimally safe key size from 2010-2030.
				 logger.warning(Logger.SECURITY_FAILURE, ""Potentially unsecure encryption. Key size of "" + keySize + ""bits "" +
				                ""not sufficiently long for "" + cipherAlg + "". Should use appropriate algorithm with key size "" +
				                ""of *at least* 112 bits except when required by legacy apps. See NIST Special Pub 800-57."");
			 }
			 // Check if algorithm mentioned in SecretKey is same as that being used for Cipher object.
			 // They should be the same. If they are different, things could fail. (E.g., DES and DESede
			 // require keys with even parity. Even if key was sufficient size, if it didn't have the correct
			 // parity it could fail.)
			 //
			 String skeyAlg = key.getAlgorithm();
			 if ( !( cipherAlg.startsWith( skeyAlg + ""/"" ) || cipherAlg.equals( skeyAlg ) ) ) {
				 // DISCUSS: Should we thrown a ConfigurationException here or just log a warning??? I'm game for
				 //			 either, but personally I'd prefer the squeaky wheel to the annoying throwing of
				 //			 a ConfigurationException (which is a RuntimeException). Less likely to upset
				 //			 the development community.
				 logger.warning(Logger.SECURITY_FAILURE, ""Encryption mismatch between cipher algorithm ("" +
						 cipherAlg + "") and SecretKey algorithm ("" + skeyAlg + ""). Cipher will use algorithm "" + cipherAlg);
			 }

			 byte[] ivBytes = null;
			 CipherSpec cipherSpec = new CipherSpec(encrypter, keySize);	// Could pass the ACTUAL (intended) key size
			 
             // Using cipher mode that supports *both* confidentiality *and* authenticity? If so, then
             // use the specified SecretKey as-is rather than computing a derived key from it. We also
             // don't expect a separate MAC in the specified CipherText object so therefore don't try
             // to validate it.
             boolean preferredCipherMode = CryptoHelper.isCombinedCipherMode( cipherMode );
             SecretKey encKey = null;
			 if ( preferredCipherMode ) {
			     encKey = key;
			 } else {
			     encKey = CryptoHelper.computeDerivedKey( key, keySize, ""encryption"");	// Recommended by David A. Wagner
			 }
			 
			 if ( cipherSpec.requiresIV() ) {
				 String ivType = ESAPI.securityConfiguration().getIVType();
				 IvParameterSpec ivSpec = null;
				 if ( ivType.equalsIgnoreCase(""random"") ) {
					 ivBytes = ESAPI.randomizer().getRandomBytes(encrypter.getBlockSize());
				 } else if ( ivType.equalsIgnoreCase(""fixed"") ) {
					 String fixedIVAsHex = ESAPI.securityConfiguration().getFixedIV();
					 ivBytes = Hex.decode(fixedIVAsHex);
					 /* FUTURE		 } else if ( ivType.equalsIgnoreCase(""specified"")) {
					 		// FUTURE - TODO  - Create instance of specified class to use for IV generation and
					 		//					 use it to create the ivBytes. (The intent is to make sure that
					 		//				     1) IVs are never repeated for cipher modes like OFB and CFB, and
					 		//					 2) to screen for weak IVs for the particular cipher algorithm.
					 		//		In meantime, use 'random' for block cipher in feedback mode. Unlikely they will
					 		//		be repeated unless you are salting SecureRandom with same value each time. Anything
					 		//		monotonically increasing should be suitable, like a counter, but need to remember
					 		//		it across JVM restarts. Was thinking of using System.currentTimeMillis(). While
					 		//		it's not perfect it probably is good enough. Could even all (advanced) developers
					 		//      to define their own class to create a unique IV to allow them some choice, but
					 		//      definitely need to provide a safe, default implementation.
					  */
				 } else {
					 // TODO: Update to add 'specified' once that is supported and added above.
					 throw new ConfigurationException(""Property Encryptor.ChooseIVMethod must be set to 'random' or 'fixed'"");
				 }
				 ivSpec = new IvParameterSpec(ivBytes);
				 cipherSpec.setIV(ivBytes);
				 encrypter.init(Cipher.ENCRYPT_MODE, encKey, ivSpec);
			 } else {
				 encrypter.init(Cipher.ENCRYPT_MODE, encKey);
			 }
			 logger.debug(Logger.EVENT_SUCCESS, ""Encrypting with "" + cipherSpec);
			 byte[] raw = encrypter.doFinal(plaintext);
                 // Convert to CipherText.
             CipherText ciphertext = new CipherText(cipherSpec, raw);
			 
			 // If we are using a ""preferred"" cipher mode--i.e., one that supports *both* confidentiality and
			 // authenticity, there is no point to store a separate MAC in the CipherText object. Thus we only
             // do this when we are not using such a cipher mode.
			 if ( !preferredCipherMode ) {
			     // Compute derived key, and then use it to compute and store separate MAC in CipherText object.
			     SecretKey authKey = CryptoHelper.computeDerivedKey( key, keySize, ""authenticity"");
			     ciphertext.computeAndStoreMAC(  authKey );
			 }
			 logger.debug(Logger.EVENT_SUCCESS, ""JavaEncryptor.encrypt(SecretKey,byte[],boolean,boolean) -- success!"");
			 success = true;	// W00t!!!
			 return ciphertext;
		} catch (InvalidKeyException ike) {
			 throw new EncryptionException(""Encryption failure: Invalid key exception."",
					 ""Requested key size: "" + keySize + ""bits greater than 128 bits. Must install unlimited strength crypto extension from Sun: "" +
					 ike.getMessage(), ike);
		 } catch (ConfigurationException cex) {
			 throw new EncryptionException(""Encryption failure: Configuration error. Details in log."", ""Key size mismatch or unsupported IV method. "" +
					 ""Check encryption key size vs. ESAPI.EncryptionKeyLength or Encryptor.ChooseIVMethod property."", cex);
		 } catch (InvalidAlgorithmParameterException e) {
			 throw new EncryptionException(""Encryption failure (invalid IV)"",
					 ""Encryption problem: Invalid IV spec: "" + e.getMessage(), e);
		 } catch (IllegalBlockSizeException e) {
			 throw new EncryptionException(""Encryption failure (no padding used; invalid input size)"",
					 ""Encryption problem: Invalid input size without padding ("" + xform + ""). "" + e.getMessage(), e);
		 } catch (BadPaddingException e) {
			 throw new EncryptionException(""Encryption failure"",
					 ""[Note: Should NEVER happen in encryption mode.] Encryption problem: "" + e.getMessage(), e);
		 } catch (NoSuchAlgorithmException e) {
			 throw new EncryptionException(""Encryption failure (unavailable cipher requested)"",
					 ""Encryption problem: specified algorithm in cipher xform "" + xform + "" not available: "" + e.getMessage(), e);
		 } catch (NoSuchPaddingException e) {
			 throw new EncryptionException(""Encryption failure (unavailable padding scheme requested)"",
					 ""Encryption problem: specified padding scheme in cipher xform "" + xform + "" not available: "" + e.getMessage(), e);
		 } finally {
			 // Don't overwrite anything in the case of exceptions because they may wish to retry.
			 if ( success && overwritePlaintext ) {
				 plain.overwrite();		// Note: Same as overwriting 'plaintext' byte array.
		}
	}
	 }

	/**
	  * Convenience method that decrypts previously encrypted plaintext strings
	  * that were encrypted using the new encryption mechanism (with CBC mode and
	  * PKCS5 padding by default).  This decryption method uses the master
	  * encryption key specified by the {@code Encryptor.MasterKey} property
	  * in {@code ESAPI.properties}.
	  * 
	  * @param b64IVCiphertext	A base64-encoded representation of the
	  * 							IV + raw ciphertext string to be decrypted with
	  * 							the default master key.
	  * @return	The plaintext string prior to encryption.
	  * @throws EncryptionException When something fails with the decryption.
	  * 
	  * @see org.owasp.esapi.Encryptor#decrypt(CipherText)
	  */
	 @Deprecated public String decrypt(String b64IVCiphertext) throws EncryptionException
	 {
	     logWarning(""decrypt"", ""Calling deprecated decrypt() method."");
		 CipherText ct = null;
		 try {
			 // We assume that the default cipher transform was used to encrypt this.
			 ct = new CipherText();

			 // Need to base64 decode the IV+ciphertext and extract the IV to set it in CipherText object.
			 byte[] ivPlusRawCipherText = ESAPI.encoder().decodeFromBase64(b64IVCiphertext);
			 int blockSize = ct.getBlockSize();	// Size in bytes.
			 byte[] iv = new byte[ blockSize ];
			 CryptoHelper.copyByteArray(ivPlusRawCipherText, iv, blockSize);	// Copy the first blockSize bytes into iv array
			 int cipherTextSize = ivPlusRawCipherText.length - blockSize;
			 byte[] rawCipherText = new byte[ cipherTextSize ];
			 System.arraycopy(ivPlusRawCipherText, blockSize, rawCipherText, 0, cipherTextSize);
			 ct.setIVandCiphertext(iv, rawCipherText);

			 // Now the CipherText object should be prepared to use it to decrypt.
			 PlainText plaintext = decrypt(ct);
			 return plaintext.toString();	// Convert back to a Java String
		 } catch (UnsupportedEncodingException e) {
			 // Should never happen; UTF-8 should be in rt.jar.
			 logger.error(Logger.SECURITY_FAILURE, ""UTF-8 encoding not available! Decryption failed."", e);
			 return null;	// CHECKME: Or re-throw or what? Could also use native encoding, but that's
			 // likely to cause unexpected and undesired effects far downstream.
		 } catch (IOException e) {
			 logger.error(Logger.SECURITY_FAILURE, ""Base64 decoding of IV+ciphertext failed. Decryption failed."", e);
			 return null;
		 }
	 }

	/**
	* {@inheritDoc}
	*/
	public PlainText decrypt(CipherText ciphertext) throws EncryptionException {
		 // Now more of a convenience function for using the master key.
		 return decrypt(secretKeySpec, ciphertext);
	}

	/**
	 * {@inheritDoc}
	 */
	public PlainText decrypt(SecretKey key, CipherText ciphertext)
	    throws EncryptionException, IllegalArgumentException
	{
	    long start = System.nanoTime();  // Current time in nanosecs; used to prevent timing attacks
	    if ( key == null ) {
	        throw new IllegalArgumentException(""SecretKey arg may not be null"");
	    }
	    if ( ciphertext == null ) {
	        throw new IllegalArgumentException(""Ciphertext may arg not be null"");
	    }

	    if ( ! CryptoHelper.isAllowedCipherMode(ciphertext.getCipherMode()) ) {
	        // This really should be an illegal argument exception, but it could
	        // mean that a partner encrypted something using a cipher mode that
	        // you do not accept, so it's a bit more complex than that. Also
	        // throwing an IllegalArgumentException doesn't allow us to provide
	        // the two separate error messages or automatically log it.
	        throw new EncryptionException(DECRYPTION_FAILED,
	                ""Invalid cipher mode "" + ciphertext.getCipherMode() +
	        "" not permitted for decryption or encryption operations."");
	    }
	    logger.debug(Logger.EVENT_SUCCESS,
	            ""Args valid for JavaEncryptor.decrypt(SecretKey,CipherText): "" +
	            ciphertext);

	    PlainText plaintext = null;
	    boolean caughtException = false;
	    int progressMark = 0;
	    try {
	        // First we validate the MAC.
	        boolean valid = CryptoHelper.isCipherTextMACvalid(key, ciphertext);
	        if ( !valid ) {
	            try {
	                // This is going to fail, but we want the same processing
	                // to occur as much as possible so as to prevent timing
	                // attacks. We _could_ just be satisfied by the additional
	                // sleep in the 'finally' clause, but an attacker on the
	                // same server who can run something like 'ps' can tell
	                // CPU time versus when the process is sleeping. Hence we
	                // try to make this as close as possible. Since we know
	                // it is going to fail, we ignore the result and ignore
	                // the (expected) exception.
	                handleDecryption(key, ciphertext); // Ignore return (should fail).
	            } catch(Exception ex) {
	                ;   // Ignore
	            }
	            throw new EncryptionException(DECRYPTION_FAILED,
	                    ""Decryption failed because MAC invalid for "" +
	                    ciphertext);
	        }
	        progressMark++;
	        // The decryption only counts if the MAC was valid.
	        plaintext = handleDecryption(key, ciphertext);
	        progressMark++;
	    } catch(EncryptionException ex) {
	        caughtException = true;
	        String logMsg = null;
	        switch( progressMark ) {
	        case 1:
	            logMsg = ""Decryption failed because MAC invalid. See logged exception for details."";
	            break;
	        case 2:
	            logMsg = ""Decryption failed because handleDecryption() failed. See logged exception for details."";
	            break;
	        default:
	            logMsg = ""Programming error: unexpected progress mark == "" + progressMark;
	        break;
	        }
	        logger.error(Logger.SECURITY_FAILURE, logMsg);
	        throw ex;           // Re-throw
	    }
	    finally {
	        if ( caughtException ) {
	            // The rest of this code is to try to account for any minute differences
	            // in the time it might take for the various reasons that decryption fails
	            // in order to prevent any other possible timing attacks. Perhaps it is
	            // going overboard. If nothing else, if N_SECS is large enough, it might
	            // deter attempted repeated attacks by making them take much longer.
	            long now = System.nanoTime();
	            long elapsed = now - start;
	            final long NANOSECS_IN_SEC = 1000000000L; // nanosec is 10**-9 sec
	            long nSecs = N_SECS * NANOSECS_IN_SEC;  // N seconds in nano seconds
	            if ( elapsed < nSecs ) {
	                // Want to sleep so total time taken is N seconds.
	                long extraSleep = nSecs - elapsed;

	                // 'extraSleep' is in nanoseconds. Need to convert to a millisec
	                // part and nanosec part. Nanosec is 10**-9, millsec is
	                // 10**-3, so divide by (10**-9 / 10**-3), or 10**6 to
	                // convert to from nanoseconds to milliseconds.
	                long millis = extraSleep / 1000000L;
	                long nanos  = (extraSleep - (millis * 1000000L));
	                assert nanos >= 0 && nanos <= Integer.MAX_VALUE :
                            ""Nanosecs out of bounds; nanos = "" + nanos;
	                try {
	                    Thread.sleep(millis, (int)nanos);
	                } catch(InterruptedException ex) {
	                    ;   // Ignore
	                }
	            } // Else ... time already exceeds N_SECS sec, so do not sleep.
	        }
	    }
	    return plaintext;
	}

    // Handle the actual decryption portion. At this point it is assumed that
    // any MAC has already been validated. (But see ""DISCUSS"" issue, below.)
    private PlainText handleDecryption(SecretKey key, CipherText ciphertext)
        throws EncryptionException
    {
        int keySize = 0;
        try {
            Cipher decrypter = Cipher.getInstance(ciphertext.getCipherTransformation());
            keySize = key.getEncoded().length * 8;  // Convert to # bits

            // Using cipher mode that supports *both* confidentiality *and* authenticity? If so, then
            // use the specified SecretKey as-is rather than computing a derived key from it. We also
            // don't expect a separate MAC in the specified CipherText object so therefore don't try
            // to validate it.
            boolean preferredCipherMode = CryptoHelper.isCombinedCipherMode( ciphertext.getCipherMode() );
            SecretKey encKey = null;
            if ( preferredCipherMode ) {
                encKey = key;
            } else {   
                // TODO: PERFORMANCE: Calculate avg time this takes and consider caching for very short interval
                //       (e.g., 2 to 5 sec tops). Otherwise doing lots of encryptions in a loop could take a LOT longer.
                //       But remember Jon Bentley's ""Rule #1 on performance: First make it right, then make it fast.""
                encKey = CryptoHelper.computeDerivedKey( key, keySize, ""encryption"");   // Recommended by David A. Wagner
            }
            if ( ciphertext.requiresIV() ) {
                decrypter.init(Cipher.DECRYPT_MODE, encKey, new IvParameterSpec(ciphertext.getIV()));
            } else {
                decrypter.init(Cipher.DECRYPT_MODE, encKey);
            }
            byte[] output = decrypter.doFinal(ciphertext.getRawCipherText());
            return new PlainText(output);

        } catch (InvalidKeyException ike) {
            throw new EncryptionException(DECRYPTION_FAILED, ""Must install JCE Unlimited Strength Jurisdiction Policy Files from Sun"", ike);
        } catch (NoSuchAlgorithmException e) {
            throw new EncryptionException(DECRYPTION_FAILED, ""Invalid algorithm for available JCE providers - "" +
                    ciphertext.getCipherTransformation() + "": "" + e.getMessage(), e);
        } catch (NoSuchPaddingException e) {
            throw new EncryptionException(DECRYPTION_FAILED, ""Invalid padding scheme ("" +
                    ciphertext.getPaddingScheme() + "") for cipher transformation "" + ciphertext.getCipherTransformation() +
                    "": "" + e.getMessage(), e);
        } catch (InvalidAlgorithmParameterException e) {
            throw new EncryptionException(DECRYPTION_FAILED, ""Decryption problem: "" + e.getMessage(), e);
        } catch (IllegalBlockSizeException e) {
            throw new EncryptionException(DECRYPTION_FAILED, ""Decryption problem: "" + e.getMessage(), e);
        } catch (BadPaddingException e) {
            //DISCUSS: This needs fixed. Already validated MAC in CryptoHelper.isCipherTextMACvalid() above.
            //So only way we could get a padding exception is if invalid padding were used originally by
            //the party doing the encryption. (This might happen with a buggy padding scheme for instance.)
            //It *seems* harmless though, so will leave it for now, and technically, we need to either catch it
            //or declare it in a throws class. Clearly we don't want to do the later. This should be discussed
            //during a code inspection.
            SecretKey authKey;
            try {
                authKey = CryptoHelper.computeDerivedKey( key, keySize, ""authenticity"");
            } catch (Exception e1) {
                throw new EncryptionException(DECRYPTION_FAILED,
                        ""Decryption problem -- failed to compute derived key for authenticity: "" + e1.getMessage(), e1);
            }
            boolean success = ciphertext.validateMAC( authKey );
            if ( success ) {
                throw new EncryptionException(DECRYPTION_FAILED, ""Decryption problem: "" + e.getMessage(), e);
            } else {
                throw new EncryptionException(DECRYPTION_FAILED,
                        ""Decryption problem: WARNING: Adversary may have tampered with "" +
                        ""CipherText object orCipherText object mangled in transit: "" + e.getMessage(), e);
            }
        }
    }
	
	/**
	* {@inheritDoc}
	*/
	public String sign(String data) throws EncryptionException {
		try {
			Signature signer = Signature.getInstance(signatureAlgorithm);
			signer.initSign(privateKey);
			signer.update(data.getBytes(encoding));
			byte[] bytes = signer.sign();
			return ESAPI.encoder().encodeForBase64(bytes, false);
		} catch (InvalidKeyException ike) {
			throw new EncryptionException(""Encryption failure"", ""Must install unlimited strength crypto extension from Sun"", ike);
		} catch (Exception e) {
			throw new EncryptionException(""Signature failure"", ""Can't find signature algorithm "" + signatureAlgorithm, e);
		}
	}
		
	/**
	* {@inheritDoc}
	*/
	public boolean verifySignature(String signature, String data) {
		try {
			byte[] bytes = ESAPI.encoder().decodeFromBase64(signature);
			Signature signer = Signature.getInstance(signatureAlgorithm);
			signer.initVerify(publicKey);
			signer.update(data.getBytes(encoding));
			return signer.verify(bytes);
		} catch (Exception e) {
		    // NOTE: EncryptionException constructed *only* for side-effect of causing logging.
		    // FindBugs complains about this and since it examines byte-code, there's no way to
		    // shut it up.
			new EncryptionException(""Invalid signature"", ""Problem verifying signature: "" + e.getMessage(), e);
			return false;
		}
	}

	/**
	* {@inheritDoc}
     *
     * @param expiration
     * @throws IntegrityException
     */
	public String seal(String data, long expiration) throws IntegrityException {
	    if ( data == null ) {
	        throw new IllegalArgumentException(""Data to be sealed may not be null."");
	    }
	    
		try {
		    String b64data = null;
            try {
                b64data = ESAPI.encoder().encodeForBase64(data.getBytes(""UTF-8""), false);
            } catch (UnsupportedEncodingException e) {
                ; // Ignore; should never happen since UTF-8 built into rt.jar
            }
			// mix in some random data so even identical data and timestamp produces different seals
			String nonce = ESAPI.randomizer().getRandomString(10, EncoderConstants.CHAR_ALPHANUMERICS);
			String plaintext = expiration + "":"" + nonce + "":"" + b64data;
			// add integrity check; signature is already base64 encoded.
			String sig = this.sign( plaintext );
			CipherText ciphertext = this.encrypt( new PlainText(plaintext + "":"" + sig) );
			String sealedData = ESAPI.encoder().encodeForBase64(ciphertext.asPortableSerializedByteArray(), false);
			return sealedData;
		} catch( EncryptionException e ) {
			throw new IntegrityException( e.getUserMessage(), e.getLogMessage(), e );
		}
	}

	/**
	* {@inheritDoc}
	*/
	public String unseal(String seal) throws EncryptionException {
		PlainText plaintext = null;
		try {
		    byte[] encryptedBytes = ESAPI.encoder().decodeFromBase64(seal);
		    CipherText cipherText = null;
		    try {
		        cipherText = CipherText.fromPortableSerializedBytes(encryptedBytes);
		    } catch( AssertionError e) {
	            // Some of the tests in EncryptorTest.testVerifySeal() are examples of
		        // this if assertions are enabled.
		        throw new EncryptionException(""Invalid seal"",
	                                          ""Seal passed garbarge data resulting in AssertionError: "" + e);
	        }
			plaintext = this.decrypt(cipherText);

			String[] parts = plaintext.toString().split("":"");
			if (parts.length != 4) {
				throw new EncryptionException(""Invalid seal"", ""Seal was not formatted properly."");
			}
	
			String timestring = parts[0];
			long now = new Date().getTime();
			long expiration = Long.parseLong(timestring);
			if (now > expiration) {
				throw new EncryptionException(""Invalid seal"", ""Seal expiration date of "" + new Date(expiration) + "" has past."");
			}
			String nonce = parts[1];
			String b64data = parts[2];
			String sig = parts[3];
			if (!this.verifySignature(sig, timestring + "":"" + nonce + "":"" + b64data ) ) {
				throw new EncryptionException(""Invalid seal"", ""Seal integrity check failed"");
			}	
			return new String(ESAPI.encoder().decodeFromBase64(b64data), ""UTF-8"");
		} catch (EncryptionException e) {
			throw e;
		} catch (Exception e) {
			throw new EncryptionException(""Invalid seal"", ""Invalid seal:"" + e.getMessage(), e);
		}
	}

	
	/**
	* {@inheritDoc}
	*/
	public boolean verifySeal( String seal ) {
		try {
			unseal( seal );
			return true;
		} catch( EncryptionException e ) {
			return false;
		}
	}
	
	/**
	* {@inheritDoc}
	*/
	public long getTimeStamp() {
		return new Date().getTime();
	}

	/**
	* {@inheritDoc}
	*/
	public long getRelativeTimeStamp( long offset ) {
		return new Date().getTime() + offset;
	}

	// DISCUSS: Why experimental? Would have to be added to Encryptor interface
	//			but only 3 things I saw wrong with this was 1) it used HMacMD5 instead
	//			of HMacSHA1 (see discussion below), 2) that the HMac key is the
	//			same one used for encryption (also see comments), and 3) it caught
	//			overly broad exceptions. Here it is with these specific areas
	//			addressed, but no unit testing has been done at this point. -kww
   /**
    * Compute an HMAC for a String.  Experimental.
    * @param input	The input for which to compute the HMac.
    */
/********************
	public String computeHMAC( String input ) throws EncryptionException {
		try {
			Mac hmac = Mac.getInstance(""HMacSHA1""); // DISCUSS: Changed to HMacSHA1. MD5 *badly* broken
												   //          SHA1 should really be avoided, but using
												   //		   for HMAC-SHA1 is acceptable for now. Plan
												   //		   to migrate to SHA-256 or NIST replacement for
												   //		   SHA1 in not too distant future.
			// DISCUSS: Also not recommended that the HMac key is the same as the one
			//			used for encryption (namely, Encryptor.MasterKey). If anything it
			//			would be better to use Encryptor.MasterSalt for the HMac key, or
			//			perhaps a derived key based on the master salt. (One could use
			//			CryptoHelper.computeDerivedKey().)
			//
			byte[] salt = ESAPI.securityConfiguration().getMasterSalt();
			hmac.init( new SecretKeySpec(salt, ""HMacSHA1"") );	// Was:	hmac.init(secretKeySpec)	
			byte[] inBytes;
			try {
				inBytes = input.getBytes(""UTF-8"");
			} catch (UnsupportedEncodingException e) {
				logger.warning(Logger.SECURITY_FAILURE, ""computeHMAC(): Can't find UTF-8 encoding; using default encoding"", e);
				inBytes = input.getBytes();
			}
			byte[] bytes = hmac.doFinal( inBytes );
			return ESAPI.encoder().encodeForBase64(bytes, false);
		} catch (InvalidKeyException ike) {
			throw new EncryptionException(""Encryption failure"", ""Must install unlimited strength crypto extension from Sun"", ike);
	    } catch (NoSuchAlgorithmException e) {
	    	throw new EncryptionException(""Could not compute HMAC"", ""Can't find HMacSHA1 algorithm. "" +
	    															""Problem computing HMAC for "" + input, e );
	    }
	}
********************/

    /**
     * Log a security warning every Nth time one of the deprecated encrypt or
     * decrypt methods are called. ('N' is hard-coded to be 25 by default, but
     * may be changed via the system property
     * {@code ESAPI.Encryptor.warnEveryNthUse}.) In other words, we nag
     * them until the give in and change it. ;-)
     * 
     * @param where The string ""encrypt"" or ""decrypt"", corresponding to the
     *              method that is being logged.
     * @param msg   The message to log.
     */
    private void logWarning(String where, String msg) {
        int counter = 0;
        if ( where.equals(""encrypt"") ) {
            counter = encryptCounter++;
            where = ""JavaEncryptor.encrypt(): [count="" + counter +""]"";
        } else if ( where.equals(""decrypt"") ) {
            counter = decryptCounter++;
            where = ""JavaEncryptor.decrypt(): [count="" + counter +""]"";
        } else {
            where = ""JavaEncryptor: Unknown method: "";
        }
        // We log the very first time (note the use of post-increment on the
        // counters) and then every Nth time thereafter. Logging every single
        // time is likely to be way too much logging.
        if ( (counter % logEveryNthUse) == 0 ) {
            logger.warning(Logger.SECURITY_FAILURE, where + msg);
        }
    }
    
    // Get all the algorithms we will be using from ESAPI.properties.
    private static void setupAlgorithms() {
        // setup algorithms
        encryptAlgorithm = ESAPI.securityConfiguration().getEncryptionAlgorithm();
        signatureAlgorithm = ESAPI.securityConfiguration().getDigitalSignatureAlgorithm();
        randomAlgorithm = ESAPI.securityConfiguration().getRandomAlgorithm();
        hashAlgorithm = ESAPI.securityConfiguration().getHashAlgorithm();
        hashIterations = ESAPI.securityConfiguration().getHashIterations();
        encoding = ESAPI.securityConfiguration().getCharacterEncoding();
        encryptionKeyLength = ESAPI.securityConfiguration().getEncryptionKeyLength();
        signatureKeyLength = ESAPI.securityConfiguration().getDigitalSignatureKeyLength();
    }
    
    // Set up signing key pair using the master password and salt. Called (once)
    // from the JavaEncryptor CTOR.
    private static void initKeyPair(SecureRandom prng) throws NoSuchAlgorithmException {
        String sigAlg = signatureAlgorithm.toLowerCase();
        if ( sigAlg.endsWith(""withdsa"") ) {
            //
            // Admittedly, this is a kludge. However for Sun JCE, even though
            // ""SHA1withDSA"" is a valid signature algorithm name, if one calls
            //      KeyPairGenerator kpg = KeyPairGenerator.getInstance(""SHA1withDSA"");
            // that will throw a NoSuchAlgorithmException with an exception
            // message of ""SHA1withDSA KeyPairGenerator not available"". Since
            // SHA1withDSA and DSA keys should be identical, we use ""DSA""
            // in the case that SHA1withDSA or SHAwithDSA was specified. This is
            // all just to make these 2 work as expected. Sigh. (Note:
            // this was tested with JDK 1.6.0_21, but likely fails with earlier
            // versions of the JDK as well.)
            //
            sigAlg = ""DSA"";
        } else if ( sigAlg.endsWith(""withrsa"") ) {
            // Ditto for RSA.
            sigAlg = ""RSA"";
        }
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(sigAlg);
        keyGen.initialize(signatureKeyLength, prng);
        KeyPair pair = keyGen.generateKeyPair();
        privateKey = pair.getPrivate();
        publicKey = pair.getPublic();
    }
}
"
"src/main/java/org/owasp/esapi/reference/crypto/JavaEncryptor.java:[340,346]:encrypt","	@Deprecated public String encrypt(String plaintext) throws EncryptionException
	{
        logWarning(""encrypt"", ""Calling deprecated encrypt() method."");
		CipherText ct = null;
		ct = encrypt(new PlainText(plaintext) );
		return ct.getEncodedIVCipherText();
	}
"
"src/main/java/org/owasp/esapi/reference/crypto/JavaEncryptor.java:[578,608]:decrypt","	 @Deprecated public String decrypt(String b64IVCiphertext) throws EncryptionException
	 {
	     logWarning(""decrypt"", ""Calling deprecated decrypt() method."");
		 CipherText ct = null;
		 try {
			 // We assume that the default cipher transform was used to encrypt this.
			 ct = new CipherText();

			 // Need to base64 decode the IV+ciphertext and extract the IV to set it in CipherText object.
			 byte[] ivPlusRawCipherText = ESAPI.encoder().decodeFromBase64(b64IVCiphertext);
			 int blockSize = ct.getBlockSize();	// Size in bytes.
			 byte[] iv = new byte[ blockSize ];
			 CryptoHelper.copyByteArray(ivPlusRawCipherText, iv, blockSize);	// Copy the first blockSize bytes into iv array
			 int cipherTextSize = ivPlusRawCipherText.length - blockSize;
			 byte[] rawCipherText = new byte[ cipherTextSize ];
			 System.arraycopy(ivPlusRawCipherText, blockSize, rawCipherText, 0, cipherTextSize);
			 ct.setIVandCiphertext(iv, rawCipherText);

			 // Now the CipherText object should be prepared to use it to decrypt.
			 PlainText plaintext = decrypt(ct);
			 return plaintext.toString();	// Convert back to a Java String
		 } catch (UnsupportedEncodingException e) {
			 // Should never happen; UTF-8 should be in rt.jar.
			 logger.error(Logger.SECURITY_FAILURE, ""UTF-8 encoding not available! Decryption failed."", e);
			 return null;	// CHECKME: Or re-throw or what? Could also use native encoding, but that's
			 // likely to cause unexpected and undesired effects far downstream.
		 } catch (IOException e) {
			 logger.error(Logger.SECURITY_FAILURE, ""Base64 decoding of IV+ciphertext failed. Decryption failed."", e);
			 return null;
		 }
	 }
"
"src/main/java/org/owasp/esapi/crypto/CipherTextSerializer.java:[23,291]:CipherTextSerializer","public class CipherTextSerializer {
    // This should be *same* version as in CipherText. If one changes, the
    // other should as well to accommodate any differences.
    private static final long serialVersionUID = 20100122; // Format: YYYYMMDD

    private static final Logger logger = ESAPI.getLogger(""CipherTextSerializer"");
    
    private CipherText cipherText_ = null;
    
    public CipherTextSerializer(CipherText cipherTextObj) {
        assert cipherTextObj != null : ""CipherText object must not be null."";
        assert serialVersionUID == CipherText.getSerialVersionUID() :
            ""Version of CipherText and CipherTextSerializer not compatible."";
        cipherText_ = cipherTextObj;
    }
    
    /**
     * Given byte array in network byte order (i.e., big-endian order), convert
     * it so that a {@code CipherText} can be constructed from it.
     * @param cipherTextSerializedBytes A serialized {@code CipherText} object
     *          with the bytes in network byte order.
     * @throws EncryptionException Thrown if a valid {@code CipherText} object
     *          cannot be reconstructed from the byte array.
     */
    public CipherTextSerializer(byte[] cipherTextSerializedBytes)
        throws EncryptionException /* DISCUSS: Change exception type?? */
    {
        assert serialVersionUID == CipherText.getSerialVersionUID() :
            ""Version of CipherText and CipherTextSerializer not compatible."";
        cipherText_ = convertToCipherText(cipherTextSerializedBytes);
    }

    /** Return this {@code CipherText} object as a specialized, portable
     *  serialized byte array.
     * @return A serialization of this object. Note that this is <i>not</i> the
     * Java serialization.
     */
    @SuppressWarnings(""static-access"")
    public byte[] asSerializedByteArray() {
        long vers = cipherText_.getSerialVersionUID(); // static method
        long timestamp = cipherText_.getEncryptionTimestamp();
        String cipherXform = cipherText_.getCipherTransformation();
        assert cipherText_.getKeySize() < Short.MAX_VALUE :
                            ""Key size too large. Max is "" + Short.MAX_VALUE;
        short keySize = (short) cipherText_.getKeySize();
        assert cipherText_.getBlockSize() < Short.MAX_VALUE :
                            ""Block size too large. Max is "" + Short.MAX_VALUE;
        short blockSize = (short) cipherText_.getBlockSize();
        byte[] iv = cipherText_.getIV();
        assert iv.length < Short.MAX_VALUE :
                            ""IV size too large. Max is "" + Short.MAX_VALUE;
        short ivLen = (short) iv.length;
        byte[] rawCiphertext = cipherText_.getRawCipherText();
        int ciphertextLen = rawCiphertext.length;
        assert ciphertextLen >= 1 : ""Raw ciphertext length must be >= 1 byte."";
        byte[] mac = cipherText_.getSeparateMAC();
        assert mac.length < Short.MAX_VALUE :
                            ""MAC length too large. Max is "" + Short.MAX_VALUE;
        short macLen = (short) mac.length;
        
        byte[] serializedObj = computeSerialization(vers,
                                                    timestamp,
                                                    cipherXform,
                                                    keySize,
                                                    blockSize,
                                                    ivLen,
                                                    iv,
                                                    ciphertextLen,
                                                    rawCiphertext,
                                                    macLen,
                                                    mac
                                                   );
        
        return serializedObj;
    }
    
    public CipherText asCipherText() {
        return cipherText_;
    }
      
    private byte[] computeSerialization(long vers, long timestamp,
                                        String cipherXform, short keySize,
                                        short blockSize,
                                        short ivLen, byte[] iv,
                                        int ciphertextLen, byte[] rawCiphertext,
                                        short macLen, byte[] mac
                                       )
    {
        debug(""computeSerialization: vers = "" + vers);
        debug(""computeSerialization: timestamp = "" + new Date(timestamp));
        debug(""computeSerialization: cipherXform = "" + cipherXform);
        debug(""computeSerialization: keySize = "" + keySize);
        debug(""computeSerialization: blockSize = "" + blockSize);
        debug(""computeSerialization: ivLen = "" + ivLen);
        debug(""computeSerialization: ciphertextLen = "" + ciphertextLen);
        debug(""computeSerialization: macLen = "" + macLen);

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        writeLong(baos, vers);
        writeLong(baos, timestamp);
        String[] parts = cipherXform.split(""/"");
        assert parts.length == 3 : ""Malformed cipher transformation"";
        writeString(baos, cipherXform); // Size of string is prepended to string
        writeShort(baos, keySize);
        writeShort(baos, blockSize);
        writeShort(baos, ivLen);
        if ( ivLen > 0 ) baos.write(iv, 0, iv.length);
        writeInt(baos, ciphertextLen);
        baos.write(rawCiphertext, 0, rawCiphertext.length);
        writeShort(baos, macLen);
        if ( macLen > 0 ) baos.write(mac, 0, mac.length);
        return baos.toByteArray();
    }
    
    // All strings are written as UTF-8 encoded byte streams with the
    // length prepended before it as a short.
    private void writeString(ByteArrayOutputStream baos, String str) {
        byte[] bytes;
        try {
            assert str != null && str.length() > 0;
            bytes = str.getBytes(""UTF8"");
            assert bytes.length < Short.MAX_VALUE : ""writeString: String exceeds max length"";
            writeShort(baos, (short)bytes.length);
            baos.write(bytes, 0, bytes.length);
        } catch (UnsupportedEncodingException e) {
            // Should never happen. UTF8 is built into the rt.jar. We don't use native encoding as
            // a fall-back because that simply is not guaranteed to be portable across Java
            // platforms and could cause really bizarre errors way downstream.
            logger.error(Logger.EVENT_FAILURE, ""Ignoring caught UnsupportedEncodingException "" +
                           ""converting string to UTF8 encoding. Results suspect. Corrupt rt.jar????"");
        }
    }
    
    private String readString(ByteArrayInputStream bais, short sz)
        throws NullPointerException, IOException
    {
        byte[] bytes = new byte[sz];
        int ret = bais.read(bytes, 0, sz);
        assert ret == sz : ""readString: Failed to read "" + sz + "" bytes."";
        return new String(bytes, ""UTF8"");
    }
    
    private void writeShort(ByteArrayOutputStream baos, short s) {
        byte[] shortAsByteArray = ByteConversionUtil.fromShort(s);
        assert shortAsByteArray.length == 2;
        baos.write(shortAsByteArray, 0, 2);
    }
    
    private short readShort(ByteArrayInputStream bais)
        throws NullPointerException, IndexOutOfBoundsException
    {
        byte[] shortAsByteArray = new byte[2];
        int ret = bais.read(shortAsByteArray, 0, 2);
        assert ret == 2 : ""readShort: Failed to read 2 bytes."";
        return ByteConversionUtil.toShort(shortAsByteArray);
    }
    
    private void writeInt(ByteArrayOutputStream baos, int i) {
        byte[] intAsByteArray = ByteConversionUtil.fromInt(i);
        baos.write(intAsByteArray, 0, 4);
    }
    
    private int readInt(ByteArrayInputStream bais)
        throws NullPointerException, IndexOutOfBoundsException
    {
        byte[] intAsByteArray = new byte[4];
        int ret = bais.read(intAsByteArray, 0, 4);
        assert ret == 4 : ""readInt: Failed to read 4 bytes."";
        return ByteConversionUtil.toInt(intAsByteArray);
    }
    
    private void writeLong(ByteArrayOutputStream baos, long l) {
        byte[] longAsByteArray = ByteConversionUtil.fromLong(l);
        assert longAsByteArray.length == 8;
        baos.write(longAsByteArray, 0, 8);
    }
    
    private long readLong(ByteArrayInputStream bais)
        throws NullPointerException, IndexOutOfBoundsException
    {
        byte[] longAsByteArray = new byte[8];
        int ret = bais.read(longAsByteArray, 0, 8);
        assert ret == 8 : ""readLong: Failed to read 8 bytes."";
        return ByteConversionUtil.toLong(longAsByteArray);
    }
    
    private CipherText convertToCipherText(byte[] cipherTextSerializedBytes)
        throws EncryptionException
    {
        try {
            ByteArrayInputStream bais = new ByteArrayInputStream(cipherTextSerializedBytes);
            long vers = readLong(bais);
            debug(""convertToCipherText: vers = "" + vers);
            if ( vers != CipherText.getSerialVersionUID() ) {
                // NOTE: In future, support backward compatibility via this mechanism. As of now,
                //       this is first version so nothing to be backward compatible with. So any
                //       mismatch at this point is an error.
                throw new InvalidClassException(""This serialized byte stream not compatible "" +
                            ""with loaded CipherText class. Version read = "" + vers +
                            ""; version from loaded CipherText class = "" + CipherText.getSerialVersionUID());
            }
            long timestamp = readLong(bais);
            debug(""convertToCipherText: timestamp = "" + new Date(timestamp));
            short strSize = readShort(bais);
            debug(""convertToCipherText: length of cipherXform = "" + strSize);
            String cipherXform = readString(bais, strSize);
            debug(""convertToCipherText: cipherXform = "" + cipherXform);
            String[] parts = cipherXform.split(""/"");
            assert parts.length == 3 : ""Malformed cipher transformation"";
            String cipherMode = parts[1];
            if ( ! CryptoHelper.isAllowedCipherMode(cipherMode) ) {
                String msg = ""Cipher mode "" + cipherMode + "" is not an allowed cipher mode"";
                throw new EncryptionException(msg, msg);
            }
            short keySize = readShort(bais);
            debug(""convertToCipherText: keySize = "" + keySize);
            short blockSize = readShort(bais);
            debug(""convertToCipherText: blockSize = "" + blockSize);
            short ivLen = readShort(bais);
            debug(""convertToCipherText: ivLen = "" + ivLen);
            byte[] iv = null;
            if ( ivLen > 0 ) {
                iv = new byte[ivLen];
                bais.read(iv, 0, iv.length);
            }
            int ciphertextLen = readInt(bais);
            debug(""convertToCipherText: ciphertextLen = "" + ciphertextLen);
            assert ciphertextLen > 0 : ""convertToCipherText: Invalid cipher text length"";
            byte[] rawCiphertext = new byte[ciphertextLen];
            bais.read(rawCiphertext, 0, rawCiphertext.length);
            short macLen = readShort(bais);
            debug(""convertToCipherText: macLen = "" + macLen);
            byte[] mac = null;
            if ( macLen > 0 ) {
                mac = new byte[macLen];
                bais.read(mac, 0, mac.length);
            }

            CipherSpec cipherSpec = new CipherSpec(cipherXform, keySize);
            cipherSpec.setBlockSize(blockSize);
            cipherSpec.setIV(iv);
            debug(""convertToCipherText: CipherSpec: "" + cipherSpec);
            CipherText ct = new CipherText(cipherSpec);
            assert (ivLen > 0 && ct.requiresIV()) :
                    ""convertToCipherText: Mismatch between IV length and cipher mode."";
            ct.setCiphertext(rawCiphertext);
              // Set this *AFTER* setting raw ciphertext because setCiphertext()
              // method also sets encryption time.
            ct.setEncryptionTimestamp(timestamp);
            if ( macLen > 0 ) {
                ct.storeSeparateMAC(mac);
            }
            return ct;
        } catch(EncryptionException ex) {
            throw new EncryptionException(""Cannot deserialize byte array into CipherText object"",
                                          ""Cannot deserialize byte array into CipherText object"",
                                          ex);
        } catch (IOException e) {
            throw new EncryptionException(""Cannot deserialize byte array into CipherText object"",
                    ""Cannot deserialize byte array into CipherText object"", e);
        }
    }
    
    private void debug(String msg) {
        if ( logger.isDebugEnabled() ) {
            logger.debug(Logger.EVENT_SUCCESS, msg);
        }
    }
}
"
"src/main/java/org/owasp/esapi/crypto/CipherTextSerializer.java:[209,284]:convertToCipherText","    private CipherText convertToCipherText(byte[] cipherTextSerializedBytes)
        throws EncryptionException
    {
        try {
            ByteArrayInputStream bais = new ByteArrayInputStream(cipherTextSerializedBytes);
            long vers = readLong(bais);
            debug(""convertToCipherText: vers = "" + vers);
            if ( vers != CipherText.getSerialVersionUID() ) {
                // NOTE: In future, support backward compatibility via this mechanism. As of now,
                //       this is first version so nothing to be backward compatible with. So any
                //       mismatch at this point is an error.
                throw new InvalidClassException(""This serialized byte stream not compatible "" +
                            ""with loaded CipherText class. Version read = "" + vers +
                            ""; version from loaded CipherText class = "" + CipherText.getSerialVersionUID());
            }
            long timestamp = readLong(bais);
            debug(""convertToCipherText: timestamp = "" + new Date(timestamp));
            short strSize = readShort(bais);
            debug(""convertToCipherText: length of cipherXform = "" + strSize);
            String cipherXform = readString(bais, strSize);
            debug(""convertToCipherText: cipherXform = "" + cipherXform);
            String[] parts = cipherXform.split(""/"");
            assert parts.length == 3 : ""Malformed cipher transformation"";
            String cipherMode = parts[1];
            if ( ! CryptoHelper.isAllowedCipherMode(cipherMode) ) {
                String msg = ""Cipher mode "" + cipherMode + "" is not an allowed cipher mode"";
                throw new EncryptionException(msg, msg);
            }
            short keySize = readShort(bais);
            debug(""convertToCipherText: keySize = "" + keySize);
            short blockSize = readShort(bais);
            debug(""convertToCipherText: blockSize = "" + blockSize);
            short ivLen = readShort(bais);
            debug(""convertToCipherText: ivLen = "" + ivLen);
            byte[] iv = null;
            if ( ivLen > 0 ) {
                iv = new byte[ivLen];
                bais.read(iv, 0, iv.length);
            }
            int ciphertextLen = readInt(bais);
            debug(""convertToCipherText: ciphertextLen = "" + ciphertextLen);
            assert ciphertextLen > 0 : ""convertToCipherText: Invalid cipher text length"";
            byte[] rawCiphertext = new byte[ciphertextLen];
            bais.read(rawCiphertext, 0, rawCiphertext.length);
            short macLen = readShort(bais);
            debug(""convertToCipherText: macLen = "" + macLen);
            byte[] mac = null;
            if ( macLen > 0 ) {
                mac = new byte[macLen];
                bais.read(mac, 0, mac.length);
            }

            CipherSpec cipherSpec = new CipherSpec(cipherXform, keySize);
            cipherSpec.setBlockSize(blockSize);
            cipherSpec.setIV(iv);
            debug(""convertToCipherText: CipherSpec: "" + cipherSpec);
            CipherText ct = new CipherText(cipherSpec);
            assert (ivLen > 0 && ct.requiresIV()) :
                    ""convertToCipherText: Mismatch between IV length and cipher mode."";
            ct.setCiphertext(rawCiphertext);
              // Set this *AFTER* setting raw ciphertext because setCiphertext()
              // method also sets encryption time.
            ct.setEncryptionTimestamp(timestamp);
            if ( macLen > 0 ) {
                ct.storeSeparateMAC(mac);
            }
            return ct;
        } catch(EncryptionException ex) {
            throw new EncryptionException(""Cannot deserialize byte array into CipherText object"",
                                          ""Cannot deserialize byte array into CipherText object"",
                                          ex);
        } catch (IOException e) {
            throw new EncryptionException(""Cannot deserialize byte array into CipherText object"",
                    ""Cannot deserialize byte array into CipherText object"", e);
        }
    }
"
