Vul_Path,Vul_Src
"src/main/java/spark/resource/ClassPathResourceHandler.java:[42,44]:ClassPathResourceHandler","    public ClassPathResourceHandler(String baseResource) {
        this(baseResource, null);
    }
"
"src/main/java/spark/resource/ClassPathResourceHandler.java:[60,88]:getResource","    protected AbstractFileResolvingResource getResource(String path) throws MalformedURLException {
        if (path == null || !path.startsWith(""/"")) {
            throw new MalformedURLException(path);
        }

        try {
            path = UriPath.canonical(path);

            final String addedPath = addPaths(baseResource, path);

            ClassPathResource resource = new ClassPathResource(addedPath);

            if (resource.exists() && resource.getFile().isDirectory()) {
                if (welcomeFile != null) {
                    resource = new ClassPathResource(addPaths(resource.getPath(), welcomeFile));
                } else {
                    //  No welcome file configured, serve nothing since it's a directory
                    resource = null;
                }
            }

            return (resource != null && resource.exists()) ? resource : null;
        } catch (Exception e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(e.getClass().getSimpleName() + "" when trying to get resource. "" + e.getMessage());
            }
        }
        return null;
    }
"
"src/main/java/spark/staticfiles/StaticFilesConfiguration.java:[49,246]:StaticFilesConfiguration","public class StaticFilesConfiguration {
    private final Logger LOG = LoggerFactory.getLogger(StaticFilesConfiguration.class);

    private List<AbstractResourceHandler> staticResourceHandlers = null;
    private List<JarResourceHandler> jarResourceHandlers = null;

    private boolean staticResourcesSet = false;
    private boolean externalStaticResourcesSet = false;

    public static StaticFilesConfiguration servletInstance = new StaticFilesConfiguration();

    private Map<String, String> customHeaders = new HashMap<>();

    /**
     * @return true if consumed, false otherwise.
     */
    public boolean consume(HttpServletRequest httpRequest,
                           HttpServletResponse httpResponse) throws IOException {

        if (consumeWithFileResourceHandlers(httpRequest, httpResponse)) {
            return true;
        }

        if (consumeWithJarResourceHandler(httpRequest, httpResponse)) {
            return true;
        }

        return false;
    }


    private boolean consumeWithFileResourceHandlers(HttpServletRequest httpRequest,
                                                    HttpServletResponse httpResponse) throws IOException {
        if (staticResourceHandlers != null) {

            for (AbstractResourceHandler staticResourceHandler : staticResourceHandlers) {

                AbstractFileResolvingResource resource = staticResourceHandler.getResource(httpRequest);

                if (resource != null && resource.isReadable()) {
                    OutputStream wrappedOutputStream = GzipUtils.checkAndWrap(httpRequest, httpResponse, false);
                    customHeaders.forEach(httpResponse::setHeader); //add all user-defined headers to response
                    IOUtils.copy(resource.getInputStream(), wrappedOutputStream);
                    wrappedOutputStream.flush();
                    wrappedOutputStream.close();
                    return true;
                }
            }

        }
        return false;
    }

    private boolean consumeWithJarResourceHandler(HttpServletRequest httpRequest,
                                                  HttpServletResponse httpResponse) throws IOException {
        if (jarResourceHandlers != null) {

            for (JarResourceHandler jarResourceHandler : jarResourceHandlers) {
                InputStream stream = jarResourceHandler.getResource(httpRequest);

                if (stream != null) {
                    OutputStream wrappedOutputStream = GzipUtils.checkAndWrap(httpRequest, httpResponse, false);
                    customHeaders.forEach(httpResponse::setHeader); //add all user-defined headers to response

                    IOUtils.copy(stream, wrappedOutputStream);

                    wrappedOutputStream.flush();
                    wrappedOutputStream.close();

                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Clears all static file configuration
     */
    public void clear() {

        if (staticResourceHandlers != null) {
            staticResourceHandlers.clear();
            staticResourceHandlers = null;
        }

        if (jarResourceHandlers != null) {
            jarResourceHandlers.clear();
            jarResourceHandlers = null;
        }

        staticResourcesSet = false;
        externalStaticResourcesSet = false;
    }

    /**
     * Configures location for static resources
     *
     * @param folder the location
     */
    public synchronized void configure(String folder) {
        Assert.notNull(folder, ""'folder' must not be null"");

        if (!staticResourcesSet) {
            try {
                ClassPathResource resource = new ClassPathResource(folder);

                if (configureJarCase(folder, resource)) {
                    return;
                }

                if (!resource.getFile().isDirectory()) {
                    LOG.error(""Static resource location must be a folder"");
                    return;
                }

                if (staticResourceHandlers == null) {
                    staticResourceHandlers = new ArrayList<>();
                }

                staticResourceHandlers.add(new ClassPathResourceHandler(folder, ""index.html""));
                LOG.info(""StaticResourceHandler configured with folder = "" + folder);
            } catch (IOException e) {
                LOG.error(""Error when creating StaticResourceHandler"", e);
            }
            staticResourcesSet = true;
        }

    }

    private boolean configureJarCase(String folder, ClassPathResource resource) throws IOException {
        if (resource.getURL().getProtocol().equals(""jar"")) {

            InputStream stream = StaticFilesConfiguration.class.getResourceAsStream(folder);

            if (stream != null) {
                if (jarResourceHandlers == null) {
                    jarResourceHandlers = new ArrayList<>();
                }

                // Add jar file resource handler
                jarResourceHandlers.add(new JarResourceHandler(folder, ""index.html""));
                staticResourcesSet = true;
                return true;
            } else {
                LOG.error(""Static file configuration failed."");
            }

        }
        return false;
    }

    /**
     * Configures location for static resources
     *
     * @param folder the location
     */
    public synchronized void configureExternal(String folder) {
        Assert.notNull(folder, ""'folder' must not be null"");

        if (!externalStaticResourcesSet) {
            try {
                ExternalResource resource = new ExternalResource(folder);
                if (!resource.getFile().isDirectory()) {
                    LOG.error(""External Static resource location must be a folder"");
                    return;
                }

                if (staticResourceHandlers == null) {
                    staticResourceHandlers = new ArrayList<>();
                }
                staticResourceHandlers.add(new ExternalResourceHandler(folder, ""index.html""));
                LOG.info(""External StaticResourceHandler configured with folder = "" + folder);
            } catch (IOException e) {
                LOG.error(""Error when creating external StaticResourceHandler"", e);
            }
            externalStaticResourcesSet = true;
        }

    }

    public static StaticFilesConfiguration create() {
        return new StaticFilesConfiguration();
    }

    public void setExpireTimeSeconds(long expireTimeSeconds) {
        customHeaders.put(""Cache-Control"", ""private, max-age="" + expireTimeSeconds);
        customHeaders.put(""Expires"", new Date(System.currentTimeMillis() + (expireTimeSeconds * 1000)).toString());
    }

    public void putCustomHeaders(Map<String, String> headers) {
        customHeaders.putAll(headers);
    }

    public void putCustomHeader(String key, String value) {
        customHeaders.put(key, value);
    }
}
"
"src/main/java/spark/staticfiles/StaticFilesConfiguration.java:[65,77]:consume","    public boolean consume(HttpServletRequest httpRequest,
                           HttpServletResponse httpResponse) throws IOException {

        if (consumeWithFileResourceHandlers(httpRequest, httpResponse)) {
            return true;
        }

        if (consumeWithJarResourceHandler(httpRequest, httpResponse)) {
            return true;
        }

        return false;
    }
"
"src/main/java/spark/staticfiles/StaticFilesConfiguration.java:[80,100]:consumeWithFileResourceHandlers","    private boolean consumeWithFileResourceHandlers(HttpServletRequest httpRequest,
                                                    HttpServletResponse httpResponse) throws IOException {
        if (staticResourceHandlers != null) {

            for (AbstractResourceHandler staticResourceHandler : staticResourceHandlers) {

                AbstractFileResolvingResource resource = staticResourceHandler.getResource(httpRequest);

                if (resource != null && resource.isReadable()) {
                    OutputStream wrappedOutputStream = GzipUtils.checkAndWrap(httpRequest, httpResponse, false);
                    customHeaders.forEach(httpResponse::setHeader); //add all user-defined headers to response
                    IOUtils.copy(resource.getInputStream(), wrappedOutputStream);
                    wrappedOutputStream.flush();
                    wrappedOutputStream.close();
                    return true;
                }
            }

        }
        return false;
    }
"
"src/main/java/spark/staticfiles/StaticFilesConfiguration.java:[149,177]:configure","    public synchronized void configure(String folder) {
        Assert.notNull(folder, ""'folder' must not be null"");

        if (!staticResourcesSet) {
            try {
                ClassPathResource resource = new ClassPathResource(folder);

                if (configureJarCase(folder, resource)) {
                    return;
                }

                if (!resource.getFile().isDirectory()) {
                    LOG.error(""Static resource location must be a folder"");
                    return;
                }

                if (staticResourceHandlers == null) {
                    staticResourceHandlers = new ArrayList<>();
                }

                staticResourceHandlers.add(new ClassPathResourceHandler(folder, ""index.html""));
                LOG.info(""StaticResourceHandler configured with folder = "" + folder);
            } catch (IOException e) {
                LOG.error(""Error when creating StaticResourceHandler"", e);
            }
            staticResourcesSet = true;
        }

    }
"
"src/main/java/spark/staticfiles/StaticFilesConfiguration.java:[179,199]:configureJarCase","    private boolean configureJarCase(String folder, ClassPathResource resource) throws IOException {
        if (resource.getURL().getProtocol().equals(""jar"")) {

            InputStream stream = StaticFilesConfiguration.class.getResourceAsStream(folder);

            if (stream != null) {
                if (jarResourceHandlers == null) {
                    jarResourceHandlers = new ArrayList<>();
                }

                // Add jar file resource handler
                jarResourceHandlers.add(new JarResourceHandler(folder, ""index.html""));
                staticResourcesSet = true;
                return true;
            } else {
                LOG.error(""Static file configuration failed."");
            }

        }
        return false;
    }
"
"src/main/java/spark/staticfiles/StaticFilesConfiguration.java:[206,228]:configureExternal","    public synchronized void configureExternal(String folder) {
        Assert.notNull(folder, ""'folder' must not be null"");

        if (!externalStaticResourcesSet) {
            try {
                ExternalResource resource = new ExternalResource(folder);
                if (!resource.getFile().isDirectory()) {
                    LOG.error(""External Static resource location must be a folder"");
                    return;
                }

                if (staticResourceHandlers == null) {
                    staticResourceHandlers = new ArrayList<>();
                }
                staticResourceHandlers.add(new ExternalResourceHandler(folder, ""index.html""));
                LOG.info(""External StaticResourceHandler configured with folder = "" + folder);
            } catch (IOException e) {
                LOG.error(""Error when creating external StaticResourceHandler"", e);
            }
            externalStaticResourcesSet = true;
        }

    }
"
"src/main/java/spark/resource/ExternalResourceHandler.java:[42,44]:ExternalResourceHandler","    public ExternalResourceHandler(String baseResource) {
        this(baseResource, null);
    }
"
"src/main/java/spark/resource/ExternalResourceHandler.java:[59,87]:getResource","    protected AbstractFileResolvingResource getResource(String path) throws MalformedURLException {
        if (path == null || !path.startsWith(""/"")) {
            throw new MalformedURLException(path);
        }

        try {
            path = UriPath.canonical(path);

            final String addedPath = addPaths(baseResource, path);

            ExternalResource resource = new ExternalResource(addedPath);

            if (resource.exists() && resource.isDirectory()) {
                if (welcomeFile != null) {
                    resource = new ExternalResource(addPaths(resource.getPath(), welcomeFile));
                } else {
                    //  No welcome file configured, serve nothing since it's a directory
                    resource = null;
                }
            }

            return (resource != null && resource.exists()) ? resource : null;
        } catch (Exception e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(e.getClass().getSimpleName() + "" when trying to get resource. "" + e.getMessage());
            }
        }
        return null;
    }
"
"src/test/java/spark/StaticFilesTest.java:[41,147]:StaticFilesTest","public class StaticFilesTest {

    private static final Logger LOGGER = LoggerFactory.getLogger(StaticFilesTest.class);

    private static final String FO_SHIZZY = ""Fo shizzy"";
    private static final String NOT_FOUND_BRO = ""Not found bro"";

    private static final String EXTERNAL_FILE_NAME_HTML = ""externalFile.html"";

    private static final String CONTENT_OF_EXTERNAL_FILE = ""Content of external file"";

    private static SparkTestUtil testUtil;

    private static File tmpExternalFile;

    @AfterClass
    public static void tearDown() {
        Spark.stop();
        if (tmpExternalFile != null) {
            LOGGER.debug(""tearDown().deleting: "" + tmpExternalFile);
            tmpExternalFile.delete();
        }
    }

    @BeforeClass
    public static void setup() throws IOException {
        testUtil = new SparkTestUtil(4567);

        tmpExternalFile = new File(System.getProperty(""java.io.tmpdir""), EXTERNAL_FILE_NAME_HTML);

        FileWriter writer = new FileWriter(tmpExternalFile);
        writer.write(CONTENT_OF_EXTERNAL_FILE);
        writer.flush();
        writer.close();

        staticFileLocation(""/public"");
        externalStaticFileLocation(System.getProperty(""java.io.tmpdir""));

        get(""/hello"", (q, a) -> FO_SHIZZY);

        get(""/*"", (q, a) -> {
            throw new NotFoundException();
        });

        exception(NotFoundException.class, (e, request, response) -> {
            response.status(404);
            response.body(NOT_FOUND_BRO);
        });

        Spark.awaitInitialization();
    }

    @Test
    public void testStaticFileCssStyleCss() throws Exception {
        SparkTestUtil.UrlResponse response = testUtil.doMethod(""GET"", ""/css/style.css"", null);
        Assert.assertEquals(200, response.status);
        Assert.assertEquals(""Content of css file"", response.body);

        testGet();
    }

    @Test
    public void testStaticFilePagesIndexHtml() throws Exception {
        SparkTestUtil.UrlResponse response = testUtil.doMethod(""GET"", ""/pages/index.html"", null);
        Assert.assertEquals(200, response.status);
        Assert.assertEquals(""<html><body>Hello Static World!</body></html>"", response.body);

        testGet();
    }

    @Test
    public void testStaticFilePageHtml() throws Exception {
        SparkTestUtil.UrlResponse response = testUtil.doMethod(""GET"", ""/page.html"", null);
        Assert.assertEquals(200, response.status);
        Assert.assertEquals(""<html><body>Hello Static Files World!</body></html>"", response.body);

        testGet();
    }

    @Test
    public void testExternalStaticFile() throws Exception {
        SparkTestUtil.UrlResponse response = testUtil.doMethod(""GET"", ""/externalFile.html"", null);
        Assert.assertEquals(200, response.status);
        Assert.assertEquals(""Content of external file"", response.body);

        testGet();
    }

    /**
     * Used to verify that ""normal"" functionality works after static files mapping
     */
    private static void testGet() throws Exception {
        SparkTestUtil.UrlResponse response = testUtil.doMethod(""GET"", ""/hello"", """");

        Assert.assertEquals(200, response.status);
        Assert.assertTrue(response.body.contains(FO_SHIZZY));
    }

    @Test
    public void testExceptionMapping404() throws Exception {
        SparkTestUtil.UrlResponse response = testUtil.doMethod(""GET"", ""/filethatdoesntexist.html"", null);

        Assert.assertEquals(404, response.status);
        Assert.assertEquals(NOT_FOUND_BRO, response.body);
    }

}
"
"src/test/java/spark/StaticFilesTest.java:[66,91]:setup","    public static void setup() throws IOException {
        testUtil = new SparkTestUtil(4567);

        tmpExternalFile = new File(System.getProperty(""java.io.tmpdir""), EXTERNAL_FILE_NAME_HTML);

        FileWriter writer = new FileWriter(tmpExternalFile);
        writer.write(CONTENT_OF_EXTERNAL_FILE);
        writer.flush();
        writer.close();

        staticFileLocation(""/public"");
        externalStaticFileLocation(System.getProperty(""java.io.tmpdir""));

        get(""/hello"", (q, a) -> FO_SHIZZY);

        get(""/*"", (q, a) -> {
            throw new NotFoundException();
        });

        exception(NotFoundException.class, (e, request, response) -> {
            response.status(404);
            response.body(NOT_FOUND_BRO);
        });

        Spark.awaitInitialization();
    }
"
"src/test/java/spark/StaticFilesTest.java:[121,127]:testExternalStaticFile","    public void testExternalStaticFile() throws Exception {
        SparkTestUtil.UrlResponse response = testUtil.doMethod(""GET"", ""/externalFile.html"", null);
        Assert.assertEquals(200, response.status);
        Assert.assertEquals(""Content of external file"", response.body);

        testGet();
    }
"
"src/main/java/spark/utils/StringUtils.java:[45,376]:StringUtils","public abstract class StringUtils {

    private static final String FOLDER_SEPARATOR = ""/"";
    private static final String WINDOWS_FOLDER_SEPARATOR = ""\\"";
    private static final String TOP_PATH = "".."";
    private static final String CURRENT_PATH = ""."";

    //---------------------------------------------------------------------
    // General convenience methods for working with Strings
    //---------------------------------------------------------------------

    /**
     * Check whether the given String is empty.
     * <p>This method accepts any Object as an argument, comparing it to
     * {@code null} and the empty String. As a consequence, this method
     * will never return {@code true} for a non-null non-String object.
     * <p>The Object signature is useful for general attribute handling code
     * that commonly deals with Strings but generally has to iterate over
     * Objects since attributes may e.g. be primitive value objects as well.
     *
     * @param str the candidate String
     * @return if the String is empty
     * @since 3.2.1
     */
    public static boolean isEmpty(Object str) {
        return (str == null || """".equals(str));
    }

    /**
     * Checks if the given String is not empty
     *
     * @param str the candidate String
     * @return if the String is not empty
     */
    public static boolean isNotEmpty(String str) {
        return !isEmpty(str);
    }

    /**
     * Check that the given CharSequence is neither {@code null} nor of length 0.
     *
     * @param str the CharSequence to check (may be {@code null})
     * @return {@code true} if the CharSequence is not null and has length
     */
    public static boolean hasLength(CharSequence str) {
        return (str != null && str.length() > 0);
    }

    /**
     * Check that the given String is neither {@code null} nor of length 0.
     * Note: Will return {@code true} for a String that purely consists of whitespace.
     *
     * @param str the String to check (may be {@code null})
     * @return {@code true} if the String is not null and has length
     * @see #hasLength(CharSequence)
     */
    public static boolean hasLength(String str) {
        return hasLength((CharSequence) str);
    }

    /**
     * Replace all occurrences of a substring within a string with
     * another string.
     *
     * @param inString   String to examine
     * @param oldPattern String to replace
     * @param newPattern String to insert
     * @return a String with the replacements
     */
    public static String replace(String inString, String oldPattern, String newPattern) {
        if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {
            return inString;
        }
        StringBuilder sb = new StringBuilder();
        int pos = 0; // our position in the old string
        int index = inString.indexOf(oldPattern);
        // the index of an occurrence we've found, or -1
        int patLen = oldPattern.length();
        while (index >= 0) {
            sb.append(inString.substring(pos, index));
            sb.append(newPattern);
            pos = index + patLen;
            index = inString.indexOf(oldPattern, pos);
        }
        sb.append(inString.substring(pos));
        // remember to append any characters to the right of a match
        return sb.toString();
    }

    /**
     * Delete any character in a given String.
     *
     * @param inString      the original String
     * @param charsToDelete a set of characters to delete.
     *                      E.g. ""az\n"" will delete 'a's, 'z's and new lines.
     * @return the resulting String
     */
    public static String deleteAny(String inString, String charsToDelete) {
        if (!hasLength(inString) || !hasLength(charsToDelete)) {
            return inString;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < inString.length(); i++) {
            char c = inString.charAt(i);
            if (charsToDelete.indexOf(c) == -1) {
                sb.append(c);
            }
        }
        return sb.toString();
    }

    /**
     * Extract the filename from the given path.
     *
     * @param path the file path (may be {@code null})
     * @return the extracted filename, or {@code null} if none
     */
    public static String getFilename(String path) {
        if (path == null) {
            return null;
        }
        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);
        return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);
    }

    /**
     * Apply the given relative path to the given path,
     * assuming standard Java folder separation (i.e. ""/"" separators).
     *
     * @param path         the path to start from (usually a full file path)
     * @param relativePath the relative path to apply
     *                     (relative to the full file path above)
     * @return the full file path that results from applying the relative path
     */
    public static String applyRelativePath(String path, String relativePath) {
        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);
        if (separatorIndex != -1) {
            String newPath = path.substring(0, separatorIndex);
            if (!relativePath.startsWith(FOLDER_SEPARATOR)) {
                newPath += FOLDER_SEPARATOR;
            }
            return newPath + relativePath;
        } else {
            return relativePath;
        }
    }

    /**
     * Normalize the path by suppressing sequences like ""path/.."" and
     * inner simple dots.
     * <p>The result is convenient for path comparison. For other uses,
     * notice that Windows separators (""\"") are replaced by simple slashes.
     *
     * @param path the original path
     * @return the normalized path
     */
    public static String cleanPath(String path) {
        if (path == null) {
            return null;
        }
        String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);

        // Strip prefix from path to analyze, to not treat it as part of the
        // first path element. This is necessary to correctly parse paths like
        // ""file:core/../core/io/Resource.class"", where the "".."" should just
        // strip the first ""core"" directory while keeping the ""file:"" prefix.
        int prefixIndex = pathToUse.indexOf("":"");
        String prefix = """";
        if (prefixIndex != -1) {
            prefix = pathToUse.substring(0, prefixIndex + 1);
            pathToUse = pathToUse.substring(prefixIndex + 1);
        }
        if (pathToUse.startsWith(FOLDER_SEPARATOR)) {
            prefix = prefix + FOLDER_SEPARATOR;
            pathToUse = pathToUse.substring(1);
        }

        String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);
        List<String> pathElements = new LinkedList<>();
        int tops = 0;

        for (int i = pathArray.length - 1; i >= 0; i--) {
            String element = pathArray[i];
            if (CURRENT_PATH.equals(element)) {
                // Points to current directory - drop it.
            } else if (TOP_PATH.equals(element)) {
                // Registering top path found.
                tops++;
            } else {
                if (tops > 0) {
                    // Merging path element with element corresponding to top path.
                    tops--;
                } else {
                    // Normal path element found.
                    pathElements.add(0, element);
                }
            }
        }

        // Remaining top paths need to be retained.
        for (int i = 0; i < tops; i++) {
            pathElements.add(0, TOP_PATH);
        }

        return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);
    }

    /**
     * Copy the given Collection into a String array.
     * The Collection must contain String elements only.
     *
     * @param collection the Collection to copy
     * @return the String array ({@code null} if the passed-in
     * Collection was {@code null})
     */
    public static String[] toStringArray(Collection<String> collection) {
        if (collection == null) {
            return null;
        }
        return collection.toArray(new String[collection.size()]);
    }

    /**
     * Take a String which is a delimited list and convert it to a String array.
     * <p>A single delimiter can consists of more than one character: It will still
     * be considered as single delimiter string, rather than as bunch of potential
     * delimiter characters - in contrast to {@code tokenizeToStringArray}.
     *
     * @param str       the input String
     * @param delimiter the delimiter between elements (this is a single delimiter,
     *                  rather than a bunch individual delimiter characters)
     * @return an array of the tokens in the list
     */
    public static String[] delimitedListToStringArray(String str, String delimiter) {
        return delimitedListToStringArray(str, delimiter, null);
    }

    /**
     * Take a String which is a delimited list and convert it to a String array.
     * <p>A single delimiter can consists of more than one character: It will still
     * be considered as single delimiter string, rather than as bunch of potential
     * delimiter characters - in contrast to {@code tokenizeToStringArray}.
     *
     * @param str           the input String
     * @param delimiter     the delimiter between elements (this is a single delimiter,
     *                      rather than a bunch individual delimiter characters)
     * @param charsToDelete a set of characters to delete. Useful for deleting unwanted
     *                      line breaks: e.g. ""\r\n\f"" will delete all new lines and line feeds in a String.
     * @return an array of the tokens in the list
     */
    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {
        if (str == null) {
            return new String[0];
        }
        if (delimiter == null) {
            return new String[] {str};
        }
        List<String> result = new ArrayList<>();
        if ("""".equals(delimiter)) {
            for (int i = 0; i < str.length(); i++) {
                result.add(deleteAny(str.substring(i, i + 1), charsToDelete));
            }
        } else {
            int pos = 0;
            int delPos;
            while ((delPos = str.indexOf(delimiter, pos)) != -1) {
                result.add(deleteAny(str.substring(pos, delPos), charsToDelete));
                pos = delPos + delimiter.length();
            }
            if (str.length() > 0 && pos <= str.length()) {
                // Add rest of String, but not in case of empty input.
                result.add(deleteAny(str.substring(pos), charsToDelete));
            }
        }
        return toStringArray(result);
    }

    /**
     * Convenience method to return a Collection as a delimited (e.g. CSV)
     * String. E.g. useful for {@code toString()} implementations.
     *
     * @param coll   the Collection to display
     * @param delim  the delimiter to use (probably a "","")
     * @param prefix the String to start each element with
     * @param suffix the String to end each element with
     * @return the delimited String
     */
    public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {
        if (CollectionUtils.isEmpty(coll)) {
            return """";
        }
        StringBuilder sb = new StringBuilder();
        Iterator<?> it = coll.iterator();
        while (it.hasNext()) {
            sb.append(prefix).append(it.next()).append(suffix);
            if (it.hasNext()) {
                sb.append(delim);
            }
        }
        return sb.toString();
    }

    /**
     * Convenience method to return a Collection as a delimited (e.g. CSV)
     * String. E.g. useful for {@code toString()} implementations.
     *
     * @param coll  the Collection to display
     * @param delim the delimiter to use (probably a "","")
     * @return the delimited String
     */
    public static String collectionToDelimitedString(Collection<?> coll, String delim) {
        return collectionToDelimitedString(coll, delim, """", """");
    }

    public static String toString(byte[] bytes, String encoding) {
        String str;

        if (encoding != null && Charset.isSupported(encoding)) {
            try {
                str = new String(bytes, encoding);
            } catch (UnsupportedEncodingException e) {
                // Uses same func as Charset.isSupported (cannot happen)
                str = new String(bytes);
            }
        } else {
            str = new String(bytes);
        }

        return str;
    }

}
"
"src/test/java/spark/StaticFilesTest.java:[41,147]:StaticFilesTest","public class StaticFilesTest {

    private static final Logger LOGGER = LoggerFactory.getLogger(StaticFilesTest.class);

    private static final String FO_SHIZZY = ""Fo shizzy"";
    private static final String NOT_FOUND_BRO = ""Not found bro"";

    private static final String EXTERNAL_FILE_NAME_HTML = ""externalFile.html"";

    private static final String CONTENT_OF_EXTERNAL_FILE = ""Content of external file"";

    private static SparkTestUtil testUtil;

    private static File tmpExternalFile;

    @AfterClass
    public static void tearDown() {
        Spark.stop();
        if (tmpExternalFile != null) {
            LOGGER.debug(""tearDown().deleting: "" + tmpExternalFile);
            tmpExternalFile.delete();
        }
    }

    @BeforeClass
    public static void setup() throws IOException {
        testUtil = new SparkTestUtil(4567);

        tmpExternalFile = new File(System.getProperty(""java.io.tmpdir""), EXTERNAL_FILE_NAME_HTML);

        FileWriter writer = new FileWriter(tmpExternalFile);
        writer.write(CONTENT_OF_EXTERNAL_FILE);
        writer.flush();
        writer.close();

        staticFileLocation(""/public"");
        externalStaticFileLocation(System.getProperty(""java.io.tmpdir""));

        get(""/hello"", (q, a) -> FO_SHIZZY);

        get(""/*"", (q, a) -> {
            throw new NotFoundException();
        });

        exception(NotFoundException.class, (e, request, response) -> {
            response.status(404);
            response.body(NOT_FOUND_BRO);
        });

        Spark.awaitInitialization();
    }

    @Test
    public void testStaticFileCssStyleCss() throws Exception {
        SparkTestUtil.UrlResponse response = testUtil.doMethod(""GET"", ""/css/style.css"", null);
        Assert.assertEquals(200, response.status);
        Assert.assertEquals(""Content of css file"", response.body);

        testGet();
    }

    @Test
    public void testStaticFilePagesIndexHtml() throws Exception {
        SparkTestUtil.UrlResponse response = testUtil.doMethod(""GET"", ""/pages/index.html"", null);
        Assert.assertEquals(200, response.status);
        Assert.assertEquals(""<html><body>Hello Static World!</body></html>"", response.body);

        testGet();
    }

    @Test
    public void testStaticFilePageHtml() throws Exception {
        SparkTestUtil.UrlResponse response = testUtil.doMethod(""GET"", ""/page.html"", null);
        Assert.assertEquals(200, response.status);
        Assert.assertEquals(""<html><body>Hello Static Files World!</body></html>"", response.body);

        testGet();
    }

    @Test
    public void testExternalStaticFile() throws Exception {
        SparkTestUtil.UrlResponse response = testUtil.doMethod(""GET"", ""/externalFile.html"", null);
        Assert.assertEquals(200, response.status);
        Assert.assertEquals(""Content of external file"", response.body);

        testGet();
    }

    /**
     * Used to verify that ""normal"" functionality works after static files mapping
     */
    private static void testGet() throws Exception {
        SparkTestUtil.UrlResponse response = testUtil.doMethod(""GET"", ""/hello"", """");

        Assert.assertEquals(200, response.status);
        Assert.assertTrue(response.body.contains(FO_SHIZZY));
    }

    @Test
    public void testExceptionMapping404() throws Exception {
        SparkTestUtil.UrlResponse response = testUtil.doMethod(""GET"", ""/filethatdoesntexist.html"", null);

        Assert.assertEquals(404, response.status);
        Assert.assertEquals(NOT_FOUND_BRO, response.body);
    }

}
"
"src/test/java/spark/StaticFilesTest.java:[121,127]:testExternalStaticFile","    public void testExternalStaticFile() throws Exception {
        SparkTestUtil.UrlResponse response = testUtil.doMethod(""GET"", ""/externalFile.html"", null);
        Assert.assertEquals(200, response.status);
        Assert.assertEquals(""Content of external file"", response.body);

        testGet();
    }
"
"src/main/java/spark/resource/ClassPathResourceHandler.java:[42,44]:ClassPathResourceHandler","    public ClassPathResourceHandler(String baseResource) {
        this(baseResource, null);
    }
"
"src/main/java/spark/resource/ClassPathResourceHandler.java:[60,88]:getResource","    protected AbstractFileResolvingResource getResource(String path) throws MalformedURLException {
        if (path == null || !path.startsWith(""/"")) {
            throw new MalformedURLException(path);
        }

        try {
            path = UriPath.canonical(path);

            final String addedPath = addPaths(baseResource, path);

            ClassPathResource resource = new ClassPathResource(addedPath);

            if (resource.exists() && resource.getFile().isDirectory()) {
                if (welcomeFile != null) {
                    resource = new ClassPathResource(addPaths(resource.getPath(), welcomeFile));
                } else {
                    //  No welcome file configured, serve nothing since it's a directory
                    resource = null;
                }
            }

            return (resource != null && resource.exists()) ? resource : null;
        } catch (Exception e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(e.getClass().getSimpleName() + "" when trying to get resource. "" + e.getMessage());
            }
        }
        return null;
    }
"
"src/main/java/spark/staticfiles/StaticFilesConfiguration.java:[49,246]:StaticFilesConfiguration","public class StaticFilesConfiguration {
    private final Logger LOG = LoggerFactory.getLogger(StaticFilesConfiguration.class);

    private List<AbstractResourceHandler> staticResourceHandlers = null;
    private List<JarResourceHandler> jarResourceHandlers = null;

    private boolean staticResourcesSet = false;
    private boolean externalStaticResourcesSet = false;

    public static StaticFilesConfiguration servletInstance = new StaticFilesConfiguration();

    private Map<String, String> customHeaders = new HashMap<>();

    /**
     * @return true if consumed, false otherwise.
     */
    public boolean consume(HttpServletRequest httpRequest,
                           HttpServletResponse httpResponse) throws IOException {

        if (consumeWithFileResourceHandlers(httpRequest, httpResponse)) {
            return true;
        }

        if (consumeWithJarResourceHandler(httpRequest, httpResponse)) {
            return true;
        }

        return false;
    }


    private boolean consumeWithFileResourceHandlers(HttpServletRequest httpRequest,
                                                    HttpServletResponse httpResponse) throws IOException {
        if (staticResourceHandlers != null) {

            for (AbstractResourceHandler staticResourceHandler : staticResourceHandlers) {

                AbstractFileResolvingResource resource = staticResourceHandler.getResource(httpRequest);

                if (resource != null && resource.isReadable()) {
                    OutputStream wrappedOutputStream = GzipUtils.checkAndWrap(httpRequest, httpResponse, false);
                    customHeaders.forEach(httpResponse::setHeader); //add all user-defined headers to response
                    IOUtils.copy(resource.getInputStream(), wrappedOutputStream);
                    wrappedOutputStream.flush();
                    wrappedOutputStream.close();
                    return true;
                }
            }

        }
        return false;
    }

    private boolean consumeWithJarResourceHandler(HttpServletRequest httpRequest,
                                                  HttpServletResponse httpResponse) throws IOException {
        if (jarResourceHandlers != null) {

            for (JarResourceHandler jarResourceHandler : jarResourceHandlers) {
                InputStream stream = jarResourceHandler.getResource(httpRequest);

                if (stream != null) {
                    OutputStream wrappedOutputStream = GzipUtils.checkAndWrap(httpRequest, httpResponse, false);
                    customHeaders.forEach(httpResponse::setHeader); //add all user-defined headers to response

                    IOUtils.copy(stream, wrappedOutputStream);

                    wrappedOutputStream.flush();
                    wrappedOutputStream.close();

                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Clears all static file configuration
     */
    public void clear() {

        if (staticResourceHandlers != null) {
            staticResourceHandlers.clear();
            staticResourceHandlers = null;
        }

        if (jarResourceHandlers != null) {
            jarResourceHandlers.clear();
            jarResourceHandlers = null;
        }

        staticResourcesSet = false;
        externalStaticResourcesSet = false;
    }

    /**
     * Configures location for static resources
     *
     * @param folder the location
     */
    public synchronized void configure(String folder) {
        Assert.notNull(folder, ""'folder' must not be null"");

        if (!staticResourcesSet) {
            try {
                ClassPathResource resource = new ClassPathResource(folder);

                if (configureJarCase(folder, resource)) {
                    return;
                }

                if (!resource.getFile().isDirectory()) {
                    LOG.error(""Static resource location must be a folder"");
                    return;
                }

                if (staticResourceHandlers == null) {
                    staticResourceHandlers = new ArrayList<>();
                }

                staticResourceHandlers.add(new ClassPathResourceHandler(folder, ""index.html""));
                LOG.info(""StaticResourceHandler configured with folder = "" + folder);
            } catch (IOException e) {
                LOG.error(""Error when creating StaticResourceHandler"", e);
            }
            staticResourcesSet = true;
        }

    }

    private boolean configureJarCase(String folder, ClassPathResource resource) throws IOException {
        if (resource.getURL().getProtocol().equals(""jar"")) {

            InputStream stream = StaticFilesConfiguration.class.getResourceAsStream(folder);

            if (stream != null) {
                if (jarResourceHandlers == null) {
                    jarResourceHandlers = new ArrayList<>();
                }

                // Add jar file resource handler
                jarResourceHandlers.add(new JarResourceHandler(folder, ""index.html""));
                staticResourcesSet = true;
                return true;
            } else {
                LOG.error(""Static file configuration failed."");
            }

        }
        return false;
    }

    /**
     * Configures location for static resources
     *
     * @param folder the location
     */
    public synchronized void configureExternal(String folder) {
        Assert.notNull(folder, ""'folder' must not be null"");

        if (!externalStaticResourcesSet) {
            try {
                ExternalResource resource = new ExternalResource(folder);
                if (!resource.getFile().isDirectory()) {
                    LOG.error(""External Static resource location must be a folder"");
                    return;
                }

                if (staticResourceHandlers == null) {
                    staticResourceHandlers = new ArrayList<>();
                }
                staticResourceHandlers.add(new ExternalResourceHandler(folder, ""index.html""));
                LOG.info(""External StaticResourceHandler configured with folder = "" + folder);
            } catch (IOException e) {
                LOG.error(""Error when creating external StaticResourceHandler"", e);
            }
            externalStaticResourcesSet = true;
        }

    }

    public static StaticFilesConfiguration create() {
        return new StaticFilesConfiguration();
    }

    public void setExpireTimeSeconds(long expireTimeSeconds) {
        customHeaders.put(""Cache-Control"", ""private, max-age="" + expireTimeSeconds);
        customHeaders.put(""Expires"", new Date(System.currentTimeMillis() + (expireTimeSeconds * 1000)).toString());
    }

    public void putCustomHeaders(Map<String, String> headers) {
        customHeaders.putAll(headers);
    }

    public void putCustomHeader(String key, String value) {
        customHeaders.put(key, value);
    }
}
"
"src/main/java/spark/staticfiles/StaticFilesConfiguration.java:[65,77]:consume","    public boolean consume(HttpServletRequest httpRequest,
                           HttpServletResponse httpResponse) throws IOException {

        if (consumeWithFileResourceHandlers(httpRequest, httpResponse)) {
            return true;
        }

        if (consumeWithJarResourceHandler(httpRequest, httpResponse)) {
            return true;
        }

        return false;
    }
"
"src/main/java/spark/staticfiles/StaticFilesConfiguration.java:[80,100]:consumeWithFileResourceHandlers","    private boolean consumeWithFileResourceHandlers(HttpServletRequest httpRequest,
                                                    HttpServletResponse httpResponse) throws IOException {
        if (staticResourceHandlers != null) {

            for (AbstractResourceHandler staticResourceHandler : staticResourceHandlers) {

                AbstractFileResolvingResource resource = staticResourceHandler.getResource(httpRequest);

                if (resource != null && resource.isReadable()) {
                    OutputStream wrappedOutputStream = GzipUtils.checkAndWrap(httpRequest, httpResponse, false);
                    customHeaders.forEach(httpResponse::setHeader); //add all user-defined headers to response
                    IOUtils.copy(resource.getInputStream(), wrappedOutputStream);
                    wrappedOutputStream.flush();
                    wrappedOutputStream.close();
                    return true;
                }
            }

        }
        return false;
    }
"
"src/main/java/spark/staticfiles/StaticFilesConfiguration.java:[149,177]:configure","    public synchronized void configure(String folder) {
        Assert.notNull(folder, ""'folder' must not be null"");

        if (!staticResourcesSet) {
            try {
                ClassPathResource resource = new ClassPathResource(folder);

                if (configureJarCase(folder, resource)) {
                    return;
                }

                if (!resource.getFile().isDirectory()) {
                    LOG.error(""Static resource location must be a folder"");
                    return;
                }

                if (staticResourceHandlers == null) {
                    staticResourceHandlers = new ArrayList<>();
                }

                staticResourceHandlers.add(new ClassPathResourceHandler(folder, ""index.html""));
                LOG.info(""StaticResourceHandler configured with folder = "" + folder);
            } catch (IOException e) {
                LOG.error(""Error when creating StaticResourceHandler"", e);
            }
            staticResourcesSet = true;
        }

    }
"
"src/main/java/spark/staticfiles/StaticFilesConfiguration.java:[179,199]:configureJarCase","    private boolean configureJarCase(String folder, ClassPathResource resource) throws IOException {
        if (resource.getURL().getProtocol().equals(""jar"")) {

            InputStream stream = StaticFilesConfiguration.class.getResourceAsStream(folder);

            if (stream != null) {
                if (jarResourceHandlers == null) {
                    jarResourceHandlers = new ArrayList<>();
                }

                // Add jar file resource handler
                jarResourceHandlers.add(new JarResourceHandler(folder, ""index.html""));
                staticResourcesSet = true;
                return true;
            } else {
                LOG.error(""Static file configuration failed."");
            }

        }
        return false;
    }
"
"src/main/java/spark/staticfiles/StaticFilesConfiguration.java:[206,228]:configureExternal","    public synchronized void configureExternal(String folder) {
        Assert.notNull(folder, ""'folder' must not be null"");

        if (!externalStaticResourcesSet) {
            try {
                ExternalResource resource = new ExternalResource(folder);
                if (!resource.getFile().isDirectory()) {
                    LOG.error(""External Static resource location must be a folder"");
                    return;
                }

                if (staticResourceHandlers == null) {
                    staticResourceHandlers = new ArrayList<>();
                }
                staticResourceHandlers.add(new ExternalResourceHandler(folder, ""index.html""));
                LOG.info(""External StaticResourceHandler configured with folder = "" + folder);
            } catch (IOException e) {
                LOG.error(""Error when creating external StaticResourceHandler"", e);
            }
            externalStaticResourcesSet = true;
        }

    }
"
"src/main/java/spark/resource/ExternalResourceHandler.java:[42,44]:ExternalResourceHandler","    public ExternalResourceHandler(String baseResource) {
        this(baseResource, null);
    }
"
"src/main/java/spark/resource/ExternalResourceHandler.java:[59,87]:getResource","    protected AbstractFileResolvingResource getResource(String path) throws MalformedURLException {
        if (path == null || !path.startsWith(""/"")) {
            throw new MalformedURLException(path);
        }

        try {
            path = UriPath.canonical(path);

            final String addedPath = addPaths(baseResource, path);

            ExternalResource resource = new ExternalResource(addedPath);

            if (resource.exists() && resource.isDirectory()) {
                if (welcomeFile != null) {
                    resource = new ExternalResource(addPaths(resource.getPath(), welcomeFile));
                } else {
                    //  No welcome file configured, serve nothing since it's a directory
                    resource = null;
                }
            }

            return (resource != null && resource.exists()) ? resource : null;
        } catch (Exception e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(e.getClass().getSimpleName() + "" when trying to get resource. "" + e.getMessage());
            }
        }
        return null;
    }
"
