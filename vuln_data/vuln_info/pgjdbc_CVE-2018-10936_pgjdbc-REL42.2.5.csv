Vul_Path,Vul_Src
"pgjdbc/src/main/java/org/postgresql/core/PGStream.java:[35,568]:PGStream","public class PGStream implements Closeable, Flushable {
  private final SocketFactory socketFactory;
  private final HostSpec hostSpec;

  private final byte[] _int4buf;
  private final byte[] _int2buf;

  private Socket connection;
  private VisibleBufferedInputStream pg_input;
  private OutputStream pg_output;
  private byte[] streamBuffer;

  private Encoding encoding;
  private Writer encodingWriter;

  /**
   * Constructor: Connect to the PostgreSQL back end and return a stream connection.
   *
   * @param socketFactory socket factory to use when creating sockets
   * @param hostSpec the host and port to connect to
   * @param timeout timeout in milliseconds, or 0 if no timeout set
   * @throws IOException if an IOException occurs below it.
   */
  public PGStream(SocketFactory socketFactory, HostSpec hostSpec, int timeout) throws IOException {
    this.socketFactory = socketFactory;
    this.hostSpec = hostSpec;

    Socket socket = socketFactory.createSocket();
    if (!socket.isConnected()) {
      // When using a SOCKS proxy, the host might not be resolvable locally,
      // thus we defer resolution until the traffic reaches the proxy. If there
      // is no proxy, we must resolve the host to an IP to connect the socket.
      InetSocketAddress address = hostSpec.shouldResolve()
          ? new InetSocketAddress(hostSpec.getHost(), hostSpec.getPort())
          : InetSocketAddress.createUnresolved(hostSpec.getHost(), hostSpec.getPort());
      socket.connect(address, timeout);
    }
    changeSocket(socket);
    setEncoding(Encoding.getJVMEncoding(""UTF-8""));

    _int2buf = new byte[2];
    _int4buf = new byte[4];
  }

  /**
   * Constructor: Connect to the PostgreSQL back end and return a stream connection.
   *
   * @param socketFactory socket factory
   * @param hostSpec the host and port to connect to
   * @throws IOException if an IOException occurs below it.
   * @deprecated use {@link #PGStream(SocketFactory, org.postgresql.util.HostSpec, int)}
   */
  @Deprecated
  public PGStream(SocketFactory socketFactory, HostSpec hostSpec) throws IOException {
    this(socketFactory, hostSpec, 0);
  }

  public HostSpec getHostSpec() {
    return hostSpec;
  }

  public Socket getSocket() {
    return connection;
  }

  public SocketFactory getSocketFactory() {
    return socketFactory;
  }

  /**
   * Check for pending backend messages without blocking. Might return false when there actually are
   * messages waiting, depending on the characteristics of the underlying socket. This is used to
   * detect asynchronous notifies from the backend, when available.
   *
   * @return true if there is a pending backend message
   * @throws IOException if something wrong happens
   */
  public boolean hasMessagePending() throws IOException {
    if (pg_input.available() > 0) {
      return true;
    }
    // In certain cases, available returns 0, yet there are bytes
    int soTimeout = getNetworkTimeout();
    setNetworkTimeout(1);
    try {
      return pg_input.peek() != -1;
    } catch (SocketTimeoutException e) {
      return false;
    } finally {
      setNetworkTimeout(soTimeout);
    }
  }

  /**
   * Switch this stream to using a new socket. Any existing socket is <em>not</em> closed; it's
   * assumed that we are changing to a new socket that delegates to the original socket (e.g. SSL).
   *
   * @param socket the new socket to change to
   * @throws IOException if something goes wrong
   */
  public void changeSocket(Socket socket) throws IOException {
    this.connection = socket;

    // Submitted by Jason Venner <jason@idiom.com>. Disable Nagle
    // as we are selective about flushing output only when we
    // really need to.
    connection.setTcpNoDelay(true);

    // Buffer sizes submitted by Sverre H Huseby <sverrehu@online.no>
    pg_input = new VisibleBufferedInputStream(connection.getInputStream(), 8192);
    pg_output = new BufferedOutputStream(connection.getOutputStream(), 8192);

    if (encoding != null) {
      setEncoding(encoding);
    }
  }

  public Encoding getEncoding() {
    return encoding;
  }

  /**
   * Change the encoding used by this connection.
   *
   * @param encoding the new encoding to use
   * @throws IOException if something goes wrong
   */
  public void setEncoding(Encoding encoding) throws IOException {
    if (this.encoding != null && this.encoding.name().equals(encoding.name())) {
      return;
    }
    // Close down any old writer.
    if (encodingWriter != null) {
      encodingWriter.close();
    }

    this.encoding = encoding;

    // Intercept flush() downcalls from the writer; our caller
    // will call PGStream.flush() as needed.
    OutputStream interceptor = new FilterOutputStream(pg_output) {
      public void flush() throws IOException {
      }

      public void close() throws IOException {
        super.flush();
      }
    };

    encodingWriter = encoding.getEncodingWriter(interceptor);
  }

  /**
   * <p>Get a Writer instance that encodes directly onto the underlying stream.</p>
   *
   * <p>The returned Writer should not be closed, as it's a shared object. Writer.flush needs to be
   * called when switching between use of the Writer and use of the PGStream write methods, but it
   * won't actually flush output all the way out -- call {@link #flush} to actually ensure all
   * output has been pushed to the server.</p>
   *
   * @return the shared Writer instance
   * @throws IOException if something goes wrong.
   */
  public Writer getEncodingWriter() throws IOException {
    if (encodingWriter == null) {
      throw new IOException(""No encoding has been set on this connection"");
    }
    return encodingWriter;
  }

  /**
   * Sends a single character to the back end.
   *
   * @param val the character to be sent
   * @throws IOException if an I/O error occurs
   */
  public void sendChar(int val) throws IOException {
    pg_output.write(val);
  }

  /**
   * Sends a 4-byte integer to the back end.
   *
   * @param val the integer to be sent
   * @throws IOException if an I/O error occurs
   */
  public void sendInteger4(int val) throws IOException {
    _int4buf[0] = (byte) (val >>> 24);
    _int4buf[1] = (byte) (val >>> 16);
    _int4buf[2] = (byte) (val >>> 8);
    _int4buf[3] = (byte) (val);
    pg_output.write(_int4buf);
  }

  /**
   * Sends a 2-byte integer (short) to the back end.
   *
   * @param val the integer to be sent
   * @throws IOException if an I/O error occurs or {@code val} cannot be encoded in 2 bytes
   */
  public void sendInteger2(int val) throws IOException {
    if (val < Short.MIN_VALUE || val > Short.MAX_VALUE) {
      throw new IOException(""Tried to send an out-of-range integer as a 2-byte value: "" + val);
    }

    _int2buf[0] = (byte) (val >>> 8);
    _int2buf[1] = (byte) val;
    pg_output.write(_int2buf);
  }

  /**
   * Send an array of bytes to the backend.
   *
   * @param buf The array of bytes to be sent
   * @throws IOException if an I/O error occurs
   */
  public void send(byte[] buf) throws IOException {
    pg_output.write(buf);
  }

  /**
   * Send a fixed-size array of bytes to the backend. If {@code buf.length < siz}, pad with zeros.
   * If {@code buf.lengh > siz}, truncate the array.
   *
   * @param buf the array of bytes to be sent
   * @param siz the number of bytes to be sent
   * @throws IOException if an I/O error occurs
   */
  public void send(byte[] buf, int siz) throws IOException {
    send(buf, 0, siz);
  }

  /**
   * Send a fixed-size array of bytes to the backend. If {@code length < siz}, pad with zeros. If
   * {@code length > siz}, truncate the array.
   *
   * @param buf the array of bytes to be sent
   * @param off offset in the array to start sending from
   * @param siz the number of bytes to be sent
   * @throws IOException if an I/O error occurs
   */
  public void send(byte[] buf, int off, int siz) throws IOException {
    int bufamt = buf.length - off;
    pg_output.write(buf, off, bufamt < siz ? bufamt : siz);
    for (int i = bufamt; i < siz; ++i) {
      pg_output.write(0);
    }
  }

  /**
   * Receives a single character from the backend, without advancing the current protocol stream
   * position.
   *
   * @return the character received
   * @throws IOException if an I/O Error occurs
   */
  public int peekChar() throws IOException {
    int c = pg_input.peek();
    if (c < 0) {
      throw new EOFException();
    }
    return c;
  }

  /**
   * Receives a single character from the backend.
   *
   * @return the character received
   * @throws IOException if an I/O Error occurs
   */
  public int receiveChar() throws IOException {
    int c = pg_input.read();
    if (c < 0) {
      throw new EOFException();
    }
    return c;
  }

  /**
   * Receives a four byte integer from the backend.
   *
   * @return the integer received from the backend
   * @throws IOException if an I/O error occurs
   */
  public int receiveInteger4() throws IOException {
    if (pg_input.read(_int4buf) != 4) {
      throw new EOFException();
    }

    return (_int4buf[0] & 0xFF) << 24 | (_int4buf[1] & 0xFF) << 16 | (_int4buf[2] & 0xFF) << 8
        | _int4buf[3] & 0xFF;
  }

  /**
   * Receives a two byte integer from the backend.
   *
   * @return the integer received from the backend
   * @throws IOException if an I/O error occurs
   */
  public int receiveInteger2() throws IOException {
    if (pg_input.read(_int2buf) != 2) {
      throw new EOFException();
    }

    return (_int2buf[0] & 0xFF) << 8 | _int2buf[1] & 0xFF;
  }

  /**
   * Receives a fixed-size string from the backend.
   *
   * @param len the length of the string to receive, in bytes.
   * @return the decoded string
   * @throws IOException if something wrong happens
   */
  public String receiveString(int len) throws IOException {
    if (!pg_input.ensureBytes(len)) {
      throw new EOFException();
    }

    String res = encoding.decode(pg_input.getBuffer(), pg_input.getIndex(), len);
    pg_input.skip(len);
    return res;
  }

  /**
   * Receives a fixed-size string from the backend, and tries to avoid ""UTF-8 decode failed""
   * errors.
   *
   * @param len the length of the string to receive, in bytes.
   * @return the decoded string
   * @throws IOException if something wrong happens
   */
  public EncodingPredictor.DecodeResult receiveErrorString(int len) throws IOException {
    if (!pg_input.ensureBytes(len)) {
      throw new EOFException();
    }

    EncodingPredictor.DecodeResult res;
    try {
      String value = encoding.decode(pg_input.getBuffer(), pg_input.getIndex(), len);
      // no autodetect warning as the message was converted on its own
      res = new EncodingPredictor.DecodeResult(value, null);
    } catch (IOException e) {
      res = EncodingPredictor.decode(pg_input.getBuffer(), pg_input.getIndex(), len);
      if (res == null) {
        Encoding enc = Encoding.defaultEncoding();
        String value = enc.decode(pg_input.getBuffer(), pg_input.getIndex(), len);
        res = new EncodingPredictor.DecodeResult(value, enc.name());
      }
    }
    pg_input.skip(len);
    return res;
  }

  /**
   * Receives a null-terminated string from the backend. If we don't see a null, then we assume
   * something has gone wrong.
   *
   * @return string from back end
   * @throws IOException if an I/O error occurs, or end of file
   */
  public String receiveString() throws IOException {
    int len = pg_input.scanCStringLength();
    String res = encoding.decode(pg_input.getBuffer(), pg_input.getIndex(), len - 1);
    pg_input.skip(len);
    return res;
  }

  /**
   * Read a tuple from the back end. A tuple is a two dimensional array of bytes. This variant reads
   * the V3 protocol's tuple representation.
   *
   * @return tuple from the back end
   * @throws IOException if a data I/O error occurs
   */
  public byte[][] receiveTupleV3() throws IOException, OutOfMemoryError {
    // TODO: use l_msgSize
    int l_msgSize = receiveInteger4();
    int l_nf = receiveInteger2();
    byte[][] answer = new byte[l_nf][];

    OutOfMemoryError oom = null;
    for (int i = 0; i < l_nf; ++i) {
      int l_size = receiveInteger4();
      if (l_size != -1) {
        try {
          answer[i] = new byte[l_size];
          receive(answer[i], 0, l_size);
        } catch (OutOfMemoryError oome) {
          oom = oome;
          skip(l_size);
        }
      }
    }

    if (oom != null) {
      throw oom;
    }

    return answer;
  }

  /**
   * Reads in a given number of bytes from the backend.
   *
   * @param siz number of bytes to read
   * @return array of bytes received
   * @throws IOException if a data I/O error occurs
   */
  public byte[] receive(int siz) throws IOException {
    byte[] answer = new byte[siz];
    receive(answer, 0, siz);
    return answer;
  }

  /**
   * Reads in a given number of bytes from the backend.
   *
   * @param buf buffer to store result
   * @param off offset in buffer
   * @param siz number of bytes to read
   * @throws IOException if a data I/O error occurs
   */
  public void receive(byte[] buf, int off, int siz) throws IOException {
    int s = 0;

    while (s < siz) {
      int w = pg_input.read(buf, off + s, siz - s);
      if (w < 0) {
        throw new EOFException();
      }
      s += w;
    }
  }

  public void skip(int size) throws IOException {
    long s = 0;
    while (s < size) {
      s += pg_input.skip(size - s);
    }
  }


  /**
   * Copy data from an input stream to the connection.
   *
   * @param inStream the stream to read data from
   * @param remaining the number of bytes to copy
   * @throws IOException if a data I/O error occurs
   */
  public void sendStream(InputStream inStream, int remaining) throws IOException {
    int expectedLength = remaining;
    if (streamBuffer == null) {
      streamBuffer = new byte[8192];
    }

    while (remaining > 0) {
      int count = (remaining > streamBuffer.length ? streamBuffer.length : remaining);
      int readCount;

      try {
        readCount = inStream.read(streamBuffer, 0, count);
        if (readCount < 0) {
          throw new EOFException(
              GT.tr(""Premature end of input stream, expected {0} bytes, but only read {1}."",
                  expectedLength, expectedLength - remaining));
        }
      } catch (IOException ioe) {
        while (remaining > 0) {
          send(streamBuffer, count);
          remaining -= count;
          count = (remaining > streamBuffer.length ? streamBuffer.length : remaining);
        }
        throw new PGBindException(ioe);
      }

      send(streamBuffer, readCount);
      remaining -= readCount;
    }
  }


  /**
   * Flush any pending output to the backend.
   *
   * @throws IOException if an I/O error occurs
   */
  @Override
  public void flush() throws IOException {
    if (encodingWriter != null) {
      encodingWriter.flush();
    }
    pg_output.flush();
  }

  /**
   * Consume an expected EOF from the backend.
   *
   * @throws IOException if an I/O error occurs
   * @throws SQLException if we get something other than an EOF
   */
  public void receiveEOF() throws SQLException, IOException {
    int c = pg_input.read();
    if (c < 0) {
      return;
    }
    throw new PSQLException(GT.tr(""Expected an EOF from server, got: {0}"", c),
        PSQLState.COMMUNICATION_ERROR);
  }

  /**
   * Closes the connection.
   *
   * @throws IOException if an I/O Error occurs
   */
  @Override
  public void close() throws IOException {
    if (encodingWriter != null) {
      encodingWriter.close();
    }

    pg_output.close();
    pg_input.close();
    connection.close();
  }

  public void setNetworkTimeout(int milliseconds) throws IOException {
    connection.setSoTimeout(milliseconds);
  }

  public int getNetworkTimeout() throws IOException {
    return connection.getSoTimeout();
  }
}
"
"pgjdbc/src/main/java/org/postgresql/core/PGStream.java:[112,126]:hasMessagePending","  public boolean hasMessagePending() throws IOException {
    if (pg_input.available() > 0) {
      return true;
    }
    // In certain cases, available returns 0, yet there are bytes
    int soTimeout = getNetworkTimeout();
    setNetworkTimeout(1);
    try {
      return pg_input.peek() != -1;
    } catch (SocketTimeoutException e) {
      return false;
    } finally {
      setNetworkTimeout(soTimeout);
    }
  }
"
"pgjdbc/src/main/java/org/postgresql/core/SocketFactoryFactory.java:[23,73]:SocketFactoryFactory","public class SocketFactoryFactory {

  /**
   * Instantiates {@link SocketFactory} based on the {@link PGProperty#SOCKET_FACTORY}.
   *
   * @param info connection properties
   * @return socket factory
   * @throws PSQLException if something goes wrong
   */
  public static SocketFactory getSocketFactory(Properties info) throws PSQLException {
    // Socket factory
    String socketFactoryClassName = PGProperty.SOCKET_FACTORY.get(info);
    if (socketFactoryClassName == null) {
      return SocketFactory.getDefault();
    }
    try {
      return (SocketFactory) ObjectFactory.instantiate(socketFactoryClassName, info, true,
          PGProperty.SOCKET_FACTORY_ARG.get(info));
    } catch (Exception e) {
      throw new PSQLException(
          GT.tr(""The SocketFactory class provided {0} could not be instantiated."",
              socketFactoryClassName),
          PSQLState.CONNECTION_FAILURE, e);
    }
  }

  /**
   * Instantiates {@link SSLSocketFactory} based on the {@link PGProperty#SSL_FACTORY}.
   *
   * @param info connection properties
   * @return SSL socket factory
   * @throws PSQLException if something goes wrong
   */
  public static SSLSocketFactory getSslSocketFactory(Properties info) throws PSQLException {
    String classname = PGProperty.SSL_FACTORY.get(info);
    if (classname == null
        || ""org.postgresql.ssl.jdbc4.LibPQFactory"".equals(classname)
        || ""org.postgresql.ssl.LibPQFactory"".equals(classname)) {
      return new LibPQFactory(info);
    }
    try {
      return (SSLSocketFactory) ObjectFactory.instantiate(classname, info, true,
          PGProperty.SSL_FACTORY_ARG.get(info));
    } catch (Exception e) {
      throw new PSQLException(
          GT.tr(""The SSLSocketFactory class provided {0} could not be instantiated."", classname),
          PSQLState.CONNECTION_FAILURE, e);
    }
  }

}
"
"pgjdbc/src/main/java/org/postgresql/PGProperty.java:[20,635]:PGProperty","public enum PGProperty {

  /**
   * Database name to connect to (may be specified directly in the JDBC URL).
   */
  PG_DBNAME(""PGDBNAME"", null,
      ""Database name to connect to (may be specified directly in the JDBC URL)"", true),

  /**
   * Hostname of the PostgreSQL server (may be specified directly in the JDBC URL).
   */
  PG_HOST(""PGHOST"", null,
      ""Hostname of the PostgreSQL server (may be specified directly in the JDBC URL)"", false),

  /**
   * Port of the PostgreSQL server (may be specified directly in the JDBC URL).
   */
  PG_PORT(""PGPORT"", null,
      ""Port of the PostgreSQL server (may be specified directly in the JDBC URL)""),

  /**
   * Username to connect to the database as.
   */
  USER(""user"", null, ""Username to connect to the database as."", true),

  /**
   * Password to use when authenticating.
   */
  PASSWORD(""password"", null, ""Password to use when authenticating."", false),

  /**
   * Force use of a particular protocol version when connecting, if set, disables protocol version
   * fallback.
   */
  PROTOCOL_VERSION(""protocolVersion"", null,
      ""Force use of a particular protocol version when connecting, currently only version 3 is supported."",
      false, ""3""),

  /**
   * <p>Logger level of the driver. Allowed values: {@code OFF}, {@code DEBUG} or {@code TRACE}.</p>
   *
   * <p>This enable the {@link java.util.logging.Logger} of the driver based on the following mapping
   * of levels:</p>
   * <ul>
   *     <li>FINE -&gt; DEBUG</li>
   *     <li>FINEST -&gt; TRACE</li>
   * </ul>
   *
   * <p><b>NOTE:</b> The recommended approach to enable java.util.logging is using a
   * {@code logging.properties} configuration file with the property
   * {@code -Djava.util.logging.config.file=myfile} or if your are using an application server
   * you should use the appropriate logging subsystem.</p>
   */
  LOGGER_LEVEL(""loggerLevel"", null, ""Logger level of the driver"", false, ""OFF"", ""DEBUG"", ""TRACE""),

  /**
   * <p>File name output of the Logger, if set, the Logger will use a
   * {@link java.util.logging.FileHandler} to write to a specified file. If the parameter is not set
   * or the file can't be created the {@link java.util.logging.ConsoleHandler} will be used instead.</p>
   *
   * <p>Parameter should be use together with {@link PGProperty#LOGGER_LEVEL}</p>
   */
  LOGGER_FILE(""loggerFile"", null, ""File name output of the Logger""),

  /**
   * Sets the default threshold for enabling server-side prepare. A value of {@code -1} stands for
   * forceBinary
   */
  PREPARE_THRESHOLD(""prepareThreshold"", ""5"",
      ""Statement prepare threshold. A value of {@code -1} stands for forceBinary""),

  /**
   * Specifies the maximum number of entries in cache of prepared statements. A value of {@code 0}
   * disables the cache.
   */
  PREPARED_STATEMENT_CACHE_QUERIES(""preparedStatementCacheQueries"", ""256"",
      ""Specifies the maximum number of entries in per-connection cache of prepared statements. A value of {@code 0} disables the cache.""),

  /**
   * Specifies the maximum size (in megabytes) of the prepared statement cache. A value of {@code 0}
   * disables the cache.
   */
  PREPARED_STATEMENT_CACHE_SIZE_MIB(""preparedStatementCacheSizeMiB"", ""5"",
      ""Specifies the maximum size (in megabytes) of a per-connection prepared statement cache. A value of {@code 0} disables the cache.""),

  /**
   * Specifies the maximum number of fields to be cached per connection. A value of {@code 0} disables the cache.
   */
  DATABASE_METADATA_CACHE_FIELDS(""databaseMetadataCacheFields"", ""65536"",
          ""Specifies the maximum number of fields to be cached per connection. A value of {@code 0} disables the cache.""),

  /**
   * Specifies the maximum size (in megabytes) of fields to be cached per connection. A value of {@code 0} disables the cache.
   */
  DATABASE_METADATA_CACHE_FIELDS_MIB(""databaseMetadataCacheFieldsMiB"", ""5"",
          ""Specifies the maximum size (in megabytes) of fields to be cached per connection. A value of {@code 0} disables the cache.""),

  /**
   * Default parameter for {@link java.sql.Statement#getFetchSize()}. A value of {@code 0} means
   * that need fetch all rows at once
   */
  DEFAULT_ROW_FETCH_SIZE(""defaultRowFetchSize"", ""0"",
      ""Positive number of rows that should be fetched from the database when more rows are needed for ResultSet by each fetch iteration""),

  /**
   * Use binary format for sending and receiving data if possible.
   */
  BINARY_TRANSFER(""binaryTransfer"", ""true"",
      ""Use binary format for sending and receiving data if possible""),

  /**
   * Puts this connection in read-only mode.
   */
  READ_ONLY(""readOnly"", ""false"", ""Puts this connection in read-only mode""),

  /**
   * Comma separated list of types to enable binary transfer. Either OID numbers or names
   */
  BINARY_TRANSFER_ENABLE(""binaryTransferEnable"", """",
      ""Comma separated list of types to enable binary transfer. Either OID numbers or names""),

  /**
   * Comma separated list of types to disable binary transfer. Either OID numbers or names.
   * Overrides values in the driver default set and values set with binaryTransferEnable.
   */
  BINARY_TRANSFER_DISABLE(""binaryTransferDisable"", """",
      ""Comma separated list of types to disable binary transfer. Either OID numbers or names. Overrides values in the driver default set and values set with binaryTransferEnable.""),

  /**
   * Bind String to either {@code unspecified} or {@code varchar}. Default is {@code varchar} for
   * 8.0+ backends.
   */
  STRING_TYPE(""stringtype"", null,
      ""The type to bind String parameters as (usually 'varchar', 'unspecified' allows implicit casting to other types)"",
      false, ""unspecified"", ""varchar""),

  /**
   * Specifies the length to return for types of unknown length.
   */
  UNKNOWN_LENGTH(""unknownLength"", Integer.toString(Integer.MAX_VALUE),
      ""Specifies the length to return for types of unknown length""),

  /**
   * When connections that are not explicitly closed are garbage collected, log the stacktrace from
   * the opening of the connection to trace the leak source.
   */
  LOG_UNCLOSED_CONNECTIONS(""logUnclosedConnections"", ""false"",
      ""When connections that are not explicitly closed are garbage collected, log the stacktrace from the opening of the connection to trace the leak source""),

  /**
   * Enable optimization that disables column name sanitiser.
   */
  DISABLE_COLUMN_SANITISER(""disableColumnSanitiser"", ""false"",
      ""Enable optimization that disables column name sanitiser""),

  /**
   * Control use of SSL: empty or {@code true} values imply {@code sslmode==verify-full}
   */
  SSL(""ssl"", null, ""Control use of SSL (any non-null value causes SSL to be required)""),

  /**
   * Parameter governing the use of SSL. The allowed values are {@code disable}, {@code allow},
   * {@code prefer}, {@code require}, {@code verify-ca}, {@code verify-full}.
   * If {@code ssl} property is empty or set to {@code true} it implies {@code verify-full}.
   * Default mode is ""require""
   */
  SSL_MODE(""sslmode"", null, ""Parameter governing the use of SSL"", false,
      ""disable"", ""allow"", ""prefer"", ""require"", ""verify-ca"", ""verify-full""),

  /**
   * Classname of the SSL Factory to use (instance of {@code javax.net.ssl.SSLSocketFactory}).
   */
  SSL_FACTORY(""sslfactory"", null, ""Provide a SSLSocketFactory class when using SSL.""),

  /**
   * The String argument to give to the constructor of the SSL Factory.
   * @deprecated use {@code ..Factory(Properties)} constructor.
   */
  @Deprecated
  SSL_FACTORY_ARG(""sslfactoryarg"", null,
      ""Argument forwarded to constructor of SSLSocketFactory class.""),

  /**
   * Classname of the SSL HostnameVerifier to use (instance of {@code
   * javax.net.ssl.HostnameVerifier}).
   */
  SSL_HOSTNAME_VERIFIER(""sslhostnameverifier"", null,
      ""A class, implementing javax.net.ssl.HostnameVerifier that can verify the server""),

  /**
   * File containing the SSL Certificate. Default will be the file {@code postgresql.crt} in {@code
   * $HOME/.postgresql} (*nix) or {@code %APPDATA%\postgresql} (windows).
   */
  SSL_CERT(""sslcert"", null, ""The location of the client's SSL certificate""),

  /**
   * File containing the SSL Key. Default will be the file {@code postgresql.pk8} in {@code
   * $HOME/.postgresql} (*nix) or {@code %APPDATA%\postgresql} (windows).
   */
  SSL_KEY(""sslkey"", null, ""The location of the client's PKCS#8 SSL key""),

  /**
   * File containing the root certificate when validating server ({@code sslmode} = {@code
   * verify-ca} or {@code verify-full}). Default will be the file {@code root.crt} in {@code
   * $HOME/.postgresql} (*nix) or {@code %APPDATA%\postgresql} (windows).
   */
  SSL_ROOT_CERT(""sslrootcert"", null,
      ""The location of the root certificate for authenticating the server.""),

  /**
   * The SSL password to use in the default CallbackHandler.
   */
  SSL_PASSWORD(""sslpassword"", null,
      ""The password for the client's ssl key (ignored if sslpasswordcallback is set)""),

  /**
   * The classname instantiating {@code javax.security.auth.callback.CallbackHandler} to use.
   */
  SSL_PASSWORD_CALLBACK(""sslpasswordcallback"", null,
      ""A class, implementing javax.security.auth.callback.CallbackHandler that can handle PassworCallback for the ssl password.""),

  /**
   * Enable or disable TCP keep-alive. The default is {@code false}.
   */
  TCP_KEEP_ALIVE(""tcpKeepAlive"", ""false"",
      ""Enable or disable TCP keep-alive. The default is {@code false}.""),

  /**
   * Specify how long to wait for establishment of a database connection. The timeout is specified
   * in seconds.
   */
  LOGIN_TIMEOUT(""loginTimeout"", ""0"",
      ""Specify how long to wait for establishment of a database connection.""),

  /**
   * <p>The timeout value used for socket connect operations. If connecting to the server takes longer
   * than this value, the connection is broken.</p>
   *
   * <p>The timeout is specified in seconds and a value of zero means that it is disabled.</p>
   */
  CONNECT_TIMEOUT(""connectTimeout"", ""10"", ""The timeout value used for socket connect operations.""),

  /**
   * The timeout value used for socket read operations. If reading from the server takes longer than
   * this value, the connection is closed. This can be used as both a brute force global query
   * timeout and a method of detecting network problems. The timeout is specified in seconds and a
   * value of zero means that it is disabled.
   */
  SOCKET_TIMEOUT(""socketTimeout"", ""0"", ""The timeout value used for socket read operations.""),

  /**
   * Cancel command is sent out of band over its own connection, so cancel message can itself get
   * stuck.
   * This property controls ""connect timeout"" and ""socket timeout"" used for cancel commands.
   * The timeout is specified in seconds. Default value is 10 seconds.
   */
  CANCEL_SIGNAL_TIMEOUT(""cancelSignalTimeout"", ""10"", ""The timeout that is used for sending cancel command.""),

  /**
   * Socket factory used to create socket. A null value, which is the default, means system default.
   */
  SOCKET_FACTORY(""socketFactory"", null, ""Specify a socket factory for socket creation""),

  /**
   * The String argument to give to the constructor of the Socket Factory.
   * @deprecated use {@code ..Factory(Properties)} constructor.
   */
  @Deprecated
  SOCKET_FACTORY_ARG(""socketFactoryArg"", null,
      ""Argument forwarded to constructor of SocketFactory class.""),

  /**
   * Socket read buffer size (SO_RECVBUF). A value of {@code -1}, which is the default, means system
   * default.
   */
  RECEIVE_BUFFER_SIZE(""receiveBufferSize"", ""-1"", ""Socket read buffer size""),

  /**
   * Socket write buffer size (SO_SNDBUF). A value of {@code -1}, which is the default, means system
   * default.
   */
  SEND_BUFFER_SIZE(""sendBufferSize"", ""-1"", ""Socket write buffer size""),

  /**
   * Assume the server is at least that version.
   */
  ASSUME_MIN_SERVER_VERSION(""assumeMinServerVersion"", null,
      ""Assume the server is at least that version""),

  /**
   * The application name (require server version &gt;= 9.0).
   */
  APPLICATION_NAME(""ApplicationName"", DriverInfo.DRIVER_NAME, ""Name of the Application (backend >= 9.0)""),

  /**
   * Flag to enable/disable obtaining a GSS credential via JAAS login before authenticating.
   * Useful if setting system property javax.security.auth.useSubjectCredsOnly=false
   * or using native GSS with system property sun.security.jgss.native=true
   */
  JAAS_LOGIN(""jaasLogin"", ""true"", ""Login with JAAS before doing GSSAPI authentication""),

  /**
   * Specifies the name of the JAAS system or application login configuration.
   */
  JAAS_APPLICATION_NAME(""jaasApplicationName"", null,
      ""Specifies the name of the JAAS system or application login configuration.""),

  /**
   * The Kerberos service name to use when authenticating with GSSAPI. This is equivalent to libpq's
   * PGKRBSRVNAME environment variable.
   */
  KERBEROS_SERVER_NAME(""kerberosServerName"", null,
      ""The Kerberos service name to use when authenticating with GSSAPI.""),

  /**
   * Use SPNEGO in SSPI authentication requests.
   */
  USE_SPNEGO(""useSpnego"", ""false"", ""Use SPNEGO in SSPI authentication requests""),

  /**
   * Force one of
   * <ul>
   * <li>SSPI (Windows transparent single-sign-on)</li>
   * <li>GSSAPI (Kerberos, via JSSE)</li>
   * </ul>
   * to be used when the server requests Kerberos or SSPI authentication.
   */
  GSS_LIB(""gsslib"", ""auto"", ""Force SSSPI or GSSAPI"", false, ""auto"", ""sspi"", ""gssapi""),

  /**
   * Specifies the name of the SSPI service class that forms the service class part of the SPN. The
   * default, {@code POSTGRES}, is almost always correct.
   */
  SSPI_SERVICE_CLASS(""sspiServiceClass"", ""POSTGRES"", ""The Windows SSPI service class for SPN""),

  /**
   * When using the V3 protocol the driver monitors changes in certain server configuration
   * parameters that should not be touched by end users. The {@code client_encoding} setting is set
   * by the driver and should not be altered. If the driver detects a change it will abort the
   * connection.
   */
  ALLOW_ENCODING_CHANGES(""allowEncodingChanges"", ""false"", ""Allow for changes in client_encoding""),

  /**
   * Specify the schema to be set in the search-path. This schema will be used to resolve
   * unqualified object names used in statements over this connection.
   */
  CURRENT_SCHEMA(""currentSchema"", null, ""Specify the schema to be set in the search-path""),

  TARGET_SERVER_TYPE(""targetServerType"", ""any"", ""Specifies what kind of server to connect"", false,
      ""any"", ""master"", ""slave"", ""secondary"",  ""preferSlave"", ""preferSecondary""),

  LOAD_BALANCE_HOSTS(""loadBalanceHosts"", ""false"",
      ""If disabled hosts are connected in the given order. If enabled hosts are chosen randomly from the set of suitable candidates""),

  HOST_RECHECK_SECONDS(""hostRecheckSeconds"", ""10"",
      ""Specifies period (seconds) after which the host status is checked again in case it has changed""),

  /**
   * <p>Specifies which mode is used to execute queries to database: simple means ('Q' execute, no parse, no bind, text mode only),
   * extended means always use bind/execute messages, extendedForPrepared means extended for prepared statements only,
   * extendedCacheEverything means use extended protocol and try cache every statement (including Statement.execute(String sql)) in a query cache.</p>
   *
   * <p>This mode is meant for debugging purposes and/or for cases when extended protocol cannot be used (e.g. logical replication protocol)</p>
   */
  PREFER_QUERY_MODE(""preferQueryMode"", ""extended"",
      ""Specifies which mode is used to execute queries to database: simple means ('Q' execute, no parse, no bind, text mode only), ""
          + ""extended means always use bind/execute messages, extendedForPrepared means extended for prepared statements only, ""
          + ""extendedCacheEverything means use extended protocol and try cache every statement (including Statement.execute(String sql)) in a query cache."", false,
      ""extended"", ""extendedForPrepared"", ""extendedCacheEverything"", ""simple""),

  /**
   * Specifies what the driver should do if a query fails. In {@code autosave=always} mode, JDBC driver sets a savepoint before each query,
   * and rolls back to that savepoint in case of failure. In {@code autosave=never} mode (default), no savepoint dance is made ever.
   * In {@code autosave=conservative} mode, savepoint is set for each query, however the rollback is done only for rare cases
   * like 'cached statement cannot change return type' or 'statement XXX is not valid' so JDBC driver rollsback and retries
   */
  AUTOSAVE(""autosave"", ""never"",
      ""Specifies what the driver should do if a query fails. In autosave=always mode, JDBC driver sets a savepoint before each query, ""
          + ""and rolls back to that savepoint in case of failure. In autosave=never mode (default), no savepoint dance is made ever. ""
          + ""In autosave=conservative mode, safepoint is set for each query, however the rollback is done only for rare cases""
          + "" like 'cached statement cannot change return type' or 'statement XXX is not valid' so JDBC driver rollsback and retries"", false,
      ""always"", ""never"", ""conservative""),

  /**
   * Configure optimization to enable batch insert re-writing.
   */
  REWRITE_BATCHED_INSERTS(""reWriteBatchedInserts"", ""false"",
      ""Enable optimization to rewrite and collapse compatible INSERT statements that are batched.""),

  /**
   * <p>Connection parameter passed in the startup message. This parameter accepts two values; ""true""
   * and ""database"". Passing ""true"" tells the backend to go into walsender mode, wherein a small set
   * of replication commands can be issued instead of SQL statements. Only the simple query protocol
   * can be used in walsender mode. Passing ""database"" as the value instructs walsender to connect
   * to the database specified in the dbname parameter, which will allow the connection to be used
   * for logical replication from that database.</p>
   * <p>Parameter should be use together with {@link PGProperty#ASSUME_MIN_SERVER_VERSION} with
   * parameter &gt;= 9.4 (backend &gt;= 9.4)</p>
   */
  REPLICATION(""replication"", null,
      ""Connection parameter passed in startup message, one of 'true' or 'database' ""
          + ""Passing 'true' tells the backend to go into walsender mode, ""
          + ""wherein a small set of replication commands can be issued instead of SQL statements. ""
          + ""Only the simple query protocol can be used in walsender mode. ""
          + ""Passing 'database' as the value instructs walsender to connect ""
          + ""to the database specified in the dbname parameter, ""
          + ""which will allow the connection to be used for logical replication ""
          + ""from that database. ""
          + ""(backend >= 9.4)"");

  private String _name;
  private String _defaultValue;
  private boolean _required;
  private String _description;
  private String[] _choices;

  PGProperty(String name, String defaultValue, String description) {
    this(name, defaultValue, description, false);
  }

  PGProperty(String name, String defaultValue, String description, boolean required) {
    this(name, defaultValue, description, required, (String[]) null);
  }

  PGProperty(String name, String defaultValue, String description, boolean required,
      String... choices) {
    _name = name;
    _defaultValue = defaultValue;
    _required = required;
    _description = description;
    _choices = choices;
  }

  /**
   * Returns the name of the connection parameter. The name is the key that must be used in JDBC URL
   * or in Driver properties
   *
   * @return the name of the connection parameter
   */
  public String getName() {
    return _name;
  }

  /**
   * Returns the default value for this connection parameter.
   *
   * @return the default value for this connection parameter or null
   */
  public String getDefaultValue() {
    return _defaultValue;
  }

  /**
   * Returns the available values for this connection parameter.
   *
   * @return the available values for this connection parameter or null
   */
  public String[] getChoices() {
    return _choices;
  }

  /**
   * Returns the value of the connection parameters according to the given {@code Properties} or the
   * default value.
   *
   * @param properties properties to take actual value from
   * @return evaluated value for this connection parameter
   */
  public String get(Properties properties) {
    return properties.getProperty(_name, _defaultValue);
  }

  /**
   * Set the value for this connection parameter in the given {@code Properties}.
   *
   * @param properties properties in which the value should be set
   * @param value value for this connection parameter
   */
  public void set(Properties properties, String value) {
    if (value == null) {
      properties.remove(_name);
    } else {
      properties.setProperty(_name, value);
    }
  }

  /**
   * Return the boolean value for this connection parameter in the given {@code Properties}.
   *
   * @param properties properties to take actual value from
   * @return evaluated value for this connection parameter converted to boolean
   */
  public boolean getBoolean(Properties properties) {
    return Boolean.valueOf(get(properties));
  }

  /**
   * Return the int value for this connection parameter in the given {@code Properties}. Prefer the
   * use of {@link #getInt(Properties)} anywhere you can throw an {@link java.sql.SQLException}.
   *
   * @param properties properties to take actual value from
   * @return evaluated value for this connection parameter converted to int
   * @throws NumberFormatException if it cannot be converted to int.
   */
  public int getIntNoCheck(Properties properties) {
    String value = get(properties);
    return Integer.parseInt(value);
  }

  /**
   * Return the int value for this connection parameter in the given {@code Properties}.
   *
   * @param properties properties to take actual value from
   * @return evaluated value for this connection parameter converted to int
   * @throws PSQLException if it cannot be converted to int.
   */
  public int getInt(Properties properties) throws PSQLException {
    String value = get(properties);
    try {
      return Integer.parseInt(value);
    } catch (NumberFormatException nfe) {
      throw new PSQLException(GT.tr(""{0} parameter value must be an integer but was: {1}"",
          getName(), value), PSQLState.INVALID_PARAMETER_VALUE, nfe);
    }
  }

  /**
   * Return the {@code Integer} value for this connection parameter in the given {@code Properties}.
   *
   * @param properties properties to take actual value from
   * @return evaluated value for this connection parameter converted to Integer or null
   * @throws PSQLException if unable to parse property as integer
   */
  public Integer getInteger(Properties properties) throws PSQLException {
    String value = get(properties);
    if (value == null) {
      return null;
    }
    try {
      return Integer.parseInt(value);
    } catch (NumberFormatException nfe) {
      throw new PSQLException(GT.tr(""{0} parameter value must be an integer but was: {1}"",
          getName(), value), PSQLState.INVALID_PARAMETER_VALUE, nfe);
    }
  }

  /**
   * Set the boolean value for this connection parameter in the given {@code Properties}.
   *
   * @param properties properties in which the value should be set
   * @param value boolean value for this connection parameter
   */
  public void set(Properties properties, boolean value) {
    properties.setProperty(_name, Boolean.toString(value));
  }

  /**
   * Set the int value for this connection parameter in the given {@code Properties}.
   *
   * @param properties properties in which the value should be set
   * @param value int value for this connection parameter
   */
  public void set(Properties properties, int value) {
    properties.setProperty(_name, Integer.toString(value));
  }

  /**
   * Test whether this property is present in the given {@code Properties}.
   *
   * @param properties set of properties to check current in
   * @return true if the parameter is specified in the given properties
   */
  public boolean isPresent(Properties properties) {
    return getSetString(properties) != null;
  }

  /**
   * Convert this connection parameter and the value read from the given {@code Properties} into a
   * {@code DriverPropertyInfo}.
   *
   * @param properties properties to take actual value from
   * @return a DriverPropertyInfo representing this connection parameter
   */
  public DriverPropertyInfo toDriverPropertyInfo(Properties properties) {
    DriverPropertyInfo propertyInfo = new DriverPropertyInfo(_name, get(properties));
    propertyInfo.required = _required;
    propertyInfo.description = _description;
    propertyInfo.choices = _choices;
    return propertyInfo;
  }

  public static PGProperty forName(String name) {
    for (PGProperty property : PGProperty.values()) {
      if (property.getName().equals(name)) {
        return property;
      }
    }
    return null;
  }

  /**
   * Return the property if exists but avoiding the default. Allowing the caller to detect the lack
   * of a property.
   *
   * @param properties properties bundle
   * @return the value of a set property
   */
  public String getSetString(Properties properties) {
    Object o = properties.get(_name);
    if (o instanceof String) {
      return (String) o;
    }
    return null;
  }
}
"
"pgjdbc/src/main/java/org/postgresql/PGProperty.java:[186,186]:SSL_MODE","  SSL_MODE(""sslmode"", null, ""Parameter governing the use of SSL"", false,
"
