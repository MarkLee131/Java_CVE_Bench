Vul_Path,Vul_Src
"src/main/java/hudson/plugins/active_directory/ActiveDirectorySecurityRealm.java:[208,210]:ActiveDirectorySecurityRealm","    public ActiveDirectorySecurityRealm(String domain, String site, String bindName, String bindPassword, String server) {
        this(domain, site, bindName, bindPassword, server, GroupLookupStrategy.AUTO, false);
    }
"
"src/main/java/hudson/plugins/active_directory/ActiveDirectorySecurityRealm.java:[487,535]:bind","        public DirContext bind(String principalName, String password, List<SocketInfo> ldapServers, Hashtable<String, String> props) {
            // in a AD forest, it'd be mighty nice to be able to login as ""joe""
            // as opposed to ""joe@europe"",
            // but the bind operation doesn't appear to allow me to do so.
            Hashtable<String, String> newProps = new Hashtable<String, String>();

            // Sometimes might be useful to ignore referral. Use this System property is under the user risk
            Boolean ignoreReferrals = Boolean.valueOf(System.getProperty(""hudson.plugins.active_directory.referral.ignore"", ""false""));

            if (!ignoreReferrals) {
                newProps.put(Context.REFERRAL, ""follow"");
            } else {
                newProps.put(Context.REFERRAL, ""ignore"");
            }

            newProps.put(""java.naming.ldap.attributes.binary"",""tokenGroups objectSid"");

            if (FORCE_LDAPS) {
                newProps.put(""java.naming.ldap.factory.socket"", TrustAllSocketFactory.class.getName());
            }
            newProps.putAll(props);
            NamingException namingException = null;

            for (SocketInfo ldapServer : ldapServers) {
                try {
                    LdapContext context = bind(principalName, password, ldapServer, newProps);
                    LOGGER.fine(""Bound to "" + ldapServer);
                    return context;
                } catch (javax.naming.AuthenticationException e) {
                    // if the authentication failed (as opposed to a communication problem with the server),
                    // don't retry, because if this is because of a wrong password, we can end up locking
                    // the user out by causing multiple failed attempts.
                    // error code 49 (LdapClient.LDAP_INVALID_CREDENTIALS) maps to this exception in LdapCtx.mapErrorCode
                    // see http://confluence.atlassian.com/display/CONFKB/LDAP+Error+Code+49 and http://www-01.ibm.com/support/docview.wss?uid=swg21290631
                    // for subcodes within this error.
                    // it seems like we can be clever about checking subcode to decide if we retry or not,
                    // but I'm erring on the safe side as I'm not sure how reliable the code is, and maybe
                    // servers can be configured to hide the distinction between ""no such user"" and ""bad password""
                    // to reveal what user names are available.
                    LOGGER.log(Level.WARNING, ""Failed to authenticate while binding to ""+ldapServer, e);
                    throw new BadCredentialsException(""Either no such user '"" + principalName + ""' or incorrect password"", namingException);
                } catch (NamingException e) {
                    LOGGER.log(Level.WARNING, ""Failed to bind to ""+ldapServer, e);
                    namingException = e; // retry
                }
            }
            // if all the attempts failed
            throw new BadCredentialsException(""Either no such user '"" + principalName + ""' or incorrect password"", namingException);
        }
"
"src/main/java/hudson/plugins/active_directory/ActiveDirectoryUnixAuthenticationProvider.java:[161,195]:ActiveDirectoryUnixAuthenticationProvider","    public ActiveDirectoryUnixAuthenticationProvider(ActiveDirectorySecurityRealm realm) {
        this.site = realm.site;
        this.domains = realm.domains;
        this.groupLookupStrategy = realm.getGroupLookupStrategy();
        this.descriptor = realm.getDescriptor();
        this.cache = realm.cache;

        if (cache == null) {
            this.cache = new CacheConfiguration(0, 0);
        }

        // On startup userCache and groupCache are not created and cache is different from null
        if (cache.getUserCache() == null || cache.getGroupCache() == null) {
            this.cache = new CacheConfiguration(cache.getSize(), cache.getTtl());
        }

        this.userCache = cache.getUserCache();
        this.groupCache = cache.getGroupCache();

        this.threadPoolExecutor = new ThreadPoolExecutor(
                corePoolSize,
                maxPoolSize,
                keepAliveTime,
                TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<Runnable>(queueSize),
                new NamingThreadFactory(new DaemonThreadFactory(), ""ActiveDirectory.updateUserCache""),
                new ThreadPoolExecutor.DiscardPolicy()
        );

        Map<String, String> extraEnvVarsMap = ActiveDirectorySecurityRealm.EnvironmentProperty.toMap(realm.environmentProperties);
        props.put(LDAP_CONNECT_TIMEOUT, System.getProperty(LDAP_CONNECT_TIMEOUT, DEFAULT_LDAP_CONNECTION_TIMEOUT));
        props.put(LDAP_READ_TIMEOUT, System.getProperty(LDAP_READ_TIMEOUT, DEFAULT_LDAP_READ_TIMEOUT));
        // put all the user defined properties into our context environment replacing any mappings that already exist.
        props.putAll(extraEnvVarsMap);
    }
"
"src/main/java/hudson/plugins/active_directory/ActiveDirectoryUnixAuthenticationProvider.java:[295,443]:retrieveUser","    public UserDetails retrieveUser(final String username, final String password, final ActiveDirectoryDomain domain, final List<SocketInfo> ldapServers) {
        UserDetails userDetails;
        String hashKey = username + ""@@"" + DigestUtils.sha1Hex(password);
        final String bindName = domain.getBindName();
        final String bindPassword = Secret.toString(domain.getBindPassword());
        try {
            final ActiveDirectoryUserDetail[] cacheMiss = new ActiveDirectoryUserDetail[1];
            userDetails = userCache.get(hashKey, new Callable<UserDetails>() {
                public UserDetails call() throws AuthenticationException {
                    DirContext context;
                    boolean anonymousBind = false;    // did we bind anonymously?

                    // LDAP treats empty password as anonymous bind, so we need to reject it
                    if (StringUtils.isEmpty(password)) {
                        throw new BadCredentialsException(""Empty password"");
                    }

                    String userPrincipalName = getPrincipalName(username, domain.getName());
                    String samAccountName = userPrincipalName.substring(0, userPrincipalName.indexOf('@'));

                    if (bindName != null) {
                        // two step approach. Use a special credential to obtain DN for the
                        // user trying to login, then authenticate.
                        try {
                            context = descriptor.bind(bindName, bindPassword, ldapServers, props);
                            anonymousBind = false;
                        } catch (BadCredentialsException e) {
                            throw new AuthenticationServiceException(""Failed to bind to LDAP server with the bind name/password"", e);
                        }
                    } else {
                        if (password.equals(NO_AUTHENTICATION)) {
                            anonymousBind = true;
                        }

                        try {
                            // if we are just retrieving the user, try using anonymous bind by empty password (see RFC 2829 5.1)
                            // but if that fails, that's not BadCredentialException but UserMayOrMayNotExistException
                            context = descriptor.bind(userPrincipalName, anonymousBind ? """" : password, ldapServers, props);
                        } catch (BadCredentialsException e) {
                            if (anonymousBind)
                                // in my observation, if we attempt an anonymous bind and AD doesn't allow it, it still passes the bind method
                                // and only fail later when we actually do a query. So perhaps this is a dead path, but I'm leaving it here
                                // anyway as a precaution.
                                throw new UserMayOrMayNotExistException(""Unable to retrieve the user information without bind DN/password configured"");
                            throw e;
                        }
                    }

                    try {
                        // locate this user's record
                        final String domainDN = toDC(domain.getName());

                        Attributes user = new LDAPSearchBuilder(context, domainDN).subTreeScope().searchOne(""(& (userPrincipalName={0})(objectCategory=user))"", userPrincipalName);
                        if (user == null) {
                            // failed to find it. Fall back to sAMAccountName.
                            // see http://www.nabble.com/Re%3A-Hudson-AD-plug-in-td21428668.html
                            LOGGER.log(Level.FINE, ""Failed to find {0} in userPrincipalName. Trying sAMAccountName"", userPrincipalName);
                            user = new LDAPSearchBuilder(context, domainDN).subTreeScope().searchOne(""(& (sAMAccountName={0})(objectCategory=user))"", samAccountName);
                            if (user == null) {
                                throw new UsernameNotFoundException(""Authentication was successful but cannot locate the user information for "" + username);
                            }
                        }
                        LOGGER.fine(""Found user "" + username + "" : "" + user);

                        Object dnObject = user.get(DN_FORMATTED).get();
                        if (dnObject == null) {
                            throw new AuthenticationServiceException(""No distinguished name for "" + username);
                        }

                        String dn = dnObject.toString();
                        LdapName ldapName = new LdapName(dn);
                        String dnFormatted = ldapName.toString();

                        if (bindName != null && !password.equals(NO_AUTHENTICATION)) {
                            // if we've used the credential specifically for the bind, we
                            // need to verify the provided password to do authentication
                            LOGGER.log(Level.FINE, ""Attempting to validate password for DN={0}"", dn);
                            DirContext test = descriptor.bind(dnFormatted, password, ldapServers, props);
                            // Binding alone is not enough to test the credential. Need to actually perform some query operation.
                            // but if the authentication fails this throws an exception
                            try {
                                new LDAPSearchBuilder(test, domainDN).searchOne(""(& (userPrincipalName={0})(objectCategory=user))"", userPrincipalName);
                            } finally {
                                closeQuietly(test);
                            }
                        }

                        Set<GrantedAuthority> groups = resolveGroups(domainDN, dnFormatted, context);
                        groups.add(SecurityRealm.AUTHENTICATED_AUTHORITY);

                        cacheMiss[0] = new ActiveDirectoryUserDetail(username, password, true, true, true, true, groups.toArray(new GrantedAuthority[groups.size()]),
                                getStringAttribute(user, ""displayName""),
                                getStringAttribute(user, ""mail""),
                                getStringAttribute(user, ""telephoneNumber"")
                        );
                        return cacheMiss[0];
                    } catch (NamingException e) {
                        if (anonymousBind && e.getMessage().contains(""successful bind must be completed"") && e.getMessage().contains(""000004DC"")) {
                            // sometimes (or always?) anonymous bind itself will succeed but the actual query will fail.
                            // see JENKINS-12619. On my AD the error code is DSID-0C0906DC
                            throw new UserMayOrMayNotExistException(""Unable to retrieve the user information without bind DN/password configured"");
                        }

                        LOGGER.log(Level.WARNING, String.format(""Failed to retrieve user information for %s"", username), e);
                        throw new BadCredentialsException(""Failed to retrieve user information for "" + username, e);
                    } finally {
                        closeQuietly(context);
                    }
                }
            });
            if (cacheMiss[0] != null) {
                threadPoolExecutor.execute(new Runnable() {
                    @Override
                    public void run() {
                        final String threadName = Thread.currentThread().getName();
                        Thread.currentThread().setName(threadName + "" updating-cache-for-user-"" + cacheMiss[0].getUsername());
                        LOGGER.log(Level.FINEST, ""Starting the cache update {0}"", new Date());
                        try {
                            long t0 = System.currentTimeMillis();
                            cacheMiss[0].updateUserInfo();
                            LOGGER.log(Level.FINEST, ""Finished the cache update {0}"", new Date());
                            long t1 = System.currentTimeMillis();
                            LOGGER.log(Level.FINE, ""The cache for user {0} took {1} msec"", new Object[]{cacheMiss[0].getUsername(), String.valueOf(t1-t0)});
                        } finally {
                            Thread.currentThread().setName(threadName);
                        }
                    }
                });

            }
        } catch (UncheckedExecutionException e) {
           Throwable t = e.getCause();
            if (t instanceof AuthenticationException) {
                AuthenticationException authenticationException= (AuthenticationException)t;
                throw authenticationException;
            } else {
                throw new CacheAuthenticationException(""Authentication failed because there was a problem caching user "" +  username, e);
            }
        } catch (ExecutionException e) {
            LOGGER.log(Level.SEVERE, ""There was a problem caching user ""+ username, e);
            throw new CacheAuthenticationException(""Authentication failed because there was a problem caching user "" +  username, e);
        }
        // We need to check the password when the user is cached so it doesn't get automatically authenticated
        // without verifying the credentials
        if (password != null && !password.equals(NO_AUTHENTICATION) && userDetails != null && !password.equals(userDetails.getPassword())) {
            throw new BadCredentialsException(""Failed to retrieve user information from the cache for ""+ username);
        }
        return userDetails;
    }
"
